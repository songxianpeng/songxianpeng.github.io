---  
lajout: post  
title: JDBC  
tags: JDBC  
categories: Java  
published: true  
---  

## 连接步骤

1. 注册驱动(Driver)
2. 建立连接(Connection)
3. 创建执行声明(Statement)
4. 执行语句
5. 处理结果(ResultSet)
6. 释放资源

### 注册驱动

```java
// 注册时加载一次，new类时静态类加载一次
DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
// DriverManager初始化时会读取参数进行加载
System.setProperty("jdbc.driver", "oracle.jdbc.OracleDriver");
// Driver静态代码块加载 推荐使用
Class.forName("oracle.jdbc.OracleDriver");
```

### 创建连接

数据库连接是稀缺资源，用完后必须马上释放，Connection的使用原则是尽量晚创建，尽量早释放。

```java
String url = "jdbc:oracle:thin:@127.0.0.1:1521:dbname";
String username = "username";
String password = "password";
Connection connection = DriverManager.getConnection(url, username, password);
```

#### 连接字符串

* oracle
    - driverClass：oracle.jdbc.driver.OracleDriver
    - url：jdbc:oracle:thin:@127.0.0.1:1521:dbname
* mysql
    - driverClass：com.mysql.jdbc.Driver
        + 有的时候，mysql的驱动类也也会看到使用org.gjt.mm.mysql.Driver的情况，org.gjt.mm.mysql.Driver是早期的驱动名称，后来就改名为com.mysql.jdbc.Driver，现在一般都推荐使用 com.mysql.jdbc.Driver。在最新版本的mysql jdbc驱动中，为了保持对老版本的兼容，仍然保留了org.gjt.mm.mysql.Driver，但是实际上 org.gjt.mm.mysql.Driver中调用了com.mysql.jdbc.Driver，因此现在这两个驱动没有什么区别。
    - url：jdbc:mysql://localhost:3306/mydb
* DB2
    - driverClass：com.ibm.db2.jcc.DB2Driver
    - url：jdbc:db2://127.0.0.1:50000/dbname
* sybase
    - driverClass：com.sybase.jdbc.SybDriver
    - url：jdbc:sybase:Tds:localhost:5007/dbname
* PostgreSQL
    - driverClass：org.postgresql.Driver
    - url：jdbc:postgresql://localhost/dbname
* Sql Server 2000
    - driverClass：com.microsoft.jdbc.sqlserver.SQLServerDriver
    - url：jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=dbname
* Sql Server 2005
    - driverClass：com.microsoft.sqlserver.jdbc.SQLServerDriver
		+ SQL Server2000和2005的驱动是有区别的，使用错误的时候，会出现下面这个错误。java.sql.SQLException: [Microsoft][SQLServer JDBC Driver][SQLServer]传入的表格格式数据流(TDS)远程过程调用(RPC)协议流不正确。参数 1 (""): 数据类型 0x38 未知。
    - url：jdbc:sqlserver://localhost:1433; DatabaseName=dbname

### 创建执行声明

#### Statement

```java
//String sql = "insert into users (name,birthday) values ('xpress','1991-1-1')";
String sql = "select name,birthday from users where username =" + username;

Statement statement = connection.createStatement();
```

#### PreparedStatement

```java
//String sql = "insert into users (name,birthday) values ('xpress','1991-1-1')";
String sql = "select name,birthday from users where username = ?";
PreparedStatement preparedStatement = connection.prepareStatement(sql);
preparedStatement.setString(1,"xpress");
```

##### PreparedStatement优点

1. 没有sql注入问题
2. Statement会使数据库频繁编译sql，可能造成数据库缓冲区溢出
3. 数据库和驱动可以对PreparedStatement进行优化（只有相关联的数据库链接没有关闭的情况下有效）

### 执行语句

#### Statement

```java
int count = statement.executeUpdate(sql);
ResultSet resultSet = statement.executeQuery(sql);
```

#### PreparedStatement

```java
// 注意executeQuery()没有sql参数，否则调用Statement方法执行
int count = preparedStatement.executeQuery();
ResultSet resultSet = preparedStatement.executeQuery();
```

### 处理结果

```java
while (resultSet.next()) {
    System.out.println(resultSet.getString("name"));
    System.out.println(resultSet.getDate("birthday"));
}
```

### 释放资源

```java
resultSet.close();
statement.close();
connection.close();
```

### 数据类型处理

#### Date

```java
// 使用getTime()转换
preparedStatement.setDate(2,new java.sql.Date(new java.util.Date().getTime()));

// 子类直接赋值给父类完成转换，但是toString()方法包含了格式化处理yyyy-MM-dd
java.util.Date = resultSet.getDate("birthday");
// 使用getTime()转换
java.util.Date = new java.util.Date(resultSet.getDate("birthday").getTime());
```

#### 大文本

```java
Reader reader = new BufferedReader(new FileReader(file));
preparedStatement.setCharacterStream(3,reader,(int)file.length());
// 将reader结果字符串传递给preparedStatement.setString()也是支持的
preparedStatement.setString(3,clobString);

Clob clob = resultSet.getClob("content");
Reader reader = clob.getCharacterStream();
// 直接通过列序号或者列label获取
Reader reader = rresultSet.getCharacterStream("content");
// 使用getString()也可以获取
String clobString = resultSet.getString("content");
```

#### 二进制

```java
InputStream inputStream = new FileInputStream(file);
preparedStatement.setBinaryStream(4,inputStream,(int)file.length());

 Blob blob = resultSet.getBlob("image");
inputStream = blob.getBinaryStream();
// 直接通过列序号或者列label获取
inputStream = resultSet.getBinaryStream(4);
```


## 异常处理



------

*以上概念总结于传智播客JavaWeb课程*