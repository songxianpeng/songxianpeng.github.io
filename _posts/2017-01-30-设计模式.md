---  
layout: post  
title: 设计模式  
tags: 设计模式  
categories: Java  
published: true  
---  

## 面向对象思想设计原则

* 单一职责原则(高内聚，低耦合)
	- 每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个
* 开闭原则
	- 一个对象对扩展开放，对修改关闭，对类的改动是通过增加代码进行的，而不是修改现有代码
		+ 借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。
* 里氏替换原则
	- 在任何父类出现的地方都可以用它的子类来替代。
* 依赖注入原则
	- 要依赖于抽象，不要依赖于具体实现。
		+ 编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。
* 接口分离原则
	- 不应该强迫程序依赖它们不需要使用的方法。
		+ 一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。
* 迪米特原则
	- 一个对象应当对其他对象尽可能少的了解
		+ 降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用

## 设计模式

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

### 设计模式分类

* 创建型模式(对象的创建)(6个)
	- 简单工厂模式（静态工厂方法模式）
	- 工厂方法模式
	- 抽象工厂模式
	- 建造者模式
	- 原型模式
	- 单例模式
* 行为型模式(对象的功能)(7个)
	- 外观模式
	- 适配器模式
	- 代理模式
	- 装饰模式
	- 桥接模式
	- 组合模式
	- 享元模式
* 结构型模式(对象的组成)(10个)
	- 模版方法模式
	- 观察者模式
	- 状态模式
	- 职责链模式
	- 命令模式
	- 访问者模式
	- 策略模式
	- 备忘录模式
	- 迭代器模式
	- 解释器模式

### 简单工厂模式（静态工厂方法模式）

又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责

* 缺点
	- 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护

```java
public class AnimalFactory {

	private AnimalFactory() {
	}

	// public static Dog createDog() {
	// return new Dog();
	// }
	//
	// public static Cat createCat() {
	// return new Cat();
	// }

	public static Animal createAnimal(String type) {
		if ("dog".equals(type)) {
			return new Dog();
		} else if ("cat".equals(type)) {
			return new Cat();
		} else {
			return null;
		}
	}
}

```

### 工厂方法模式

工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性

* 缺点
	- 需要额外的编写代码，增加了工作量

```java
public interface Factory {
	public abstract Animal createAnimal();
}
```

```java
public class DogFactory implements Factory {
	@Override
	public Animal createAnimal() {
		return new Dog();
	}
}
```

```java
public class CatFactory implements Factory {
	@Override
	public Animal createAnimal() {
		return new Cat();
	}
}
```

```java
Factory f = new DogFactory();
Animal a = f.createAnimal();
a.eat();

f = new CatFactory();
a = f.createAnimal();
a.eat();
```


### 单例设计模式

单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。

* 优点
	- 在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
* 缺点
	- 没有抽象层，因此扩展很难。
	- 职责过重，在一定程序上违背了单一职责

#### 设计思想

保证类在内存中只有一个对象

**如何实现类在内存中只有一个对象呢?**

* 构造私有
* 本身提供一个对象
* 通过公共的方法让外界访问

#### 饿汉式(开发)

```java
public class Singleton {
	// 构造私有
	private Singleton() {
	}

	// 自己造一个
	// 静态方法只能访问静态成员变量，加静态
	// 为了不让外界直接访问修改这个值，加private
	private static Singleton s = new Singleton();

	// 提供公共的访问方式
	// 为了保证外界能够直接使用该方法，加静态
	public static Singleton getSingleton() {
		return s;
	}
}
```

#### 懒汉式

线程安全问题

懒加载思想(延迟加载)

```java
public class Singleton {
	private Singleton() {
	}
	// 使用volatile禁止指令重排
	private volatile static  Singleton t = null;
	// 锁范围较大
	public synchronized static Singleton getSingleton() {
		if (t == null) {//这里有线程安全问题 所以要枷加锁
			t = new Singleton();
		}
		return t;
	}
	// 缩小锁范围，但是要做双重检查 jdk 1.5以后有效
	public static Singleton getSingleton() {
		if (t == null) {
			synchronized(Singleton.class){
				if (t == null) {// 双重检查
					t = new Singleton();
				}
			}
		}
		return t;
	}
}
```

#### 枚举式（推荐）

好处

1. 线程安全（枚举底层是线程安全的）
2. 不会因为序列化而产生新的实例（因为它自己实现了readResolve方法）
3. 防止反射攻击。（因为enum实际上是abstract的）

```java
public enum Singleton {
    INSTANCE;
    Singleton() {
    }
    public void operate() {
    }
}
```

### 模版设计模式

模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现

* 优点
	- 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，既兼顾了原则性，有不失灵活性
* 缺点
	- 如果算法骨架有修改的话，则需要修改抽象类

```java
public abstract class GetTime {
	// 需求：请给我计算出一段代码的运行时间
	public long getTime() {
		long start = System.currentTimeMillis();

		code();

		long end = System.currentTimeMillis();

		return end - start;
	}

	public abstract void code();
}
```

```java
public class ForDemo extends GetTime {

	@Override
	public void code() {
		for (int x = 0; x < 100000; x++) {
			System.out.println(x);
		}
	}

}
```

### 装饰设计模式

装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案

* 优点
	- 使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能
* 缺点
	- 正因为可以随意组合，所以就可能出现一些不合理的逻辑

```java
public interface Phone {
	public abstract void call();
}
```

```java
public class IPhone implements Phone {

	@Override
	public void call() {
		System.out.println("手机可以打电话了");
	}

}
```

```java
// 装饰抽象类
public abstract class PhoneDecorate implements Phone {

	private Phone p;

	public PhoneDecorate(Phone p) {
		this.p = p;
	}

	@Override
	public void call() {
		this.p.call();
	}
}
```

```java
public class MusicPhoneDecorate extends PhoneDecorate {

	public MusicPhoneDecorate(Phone p) {
		super(p);
	}

	@Override
	public void call() {
		super.call();
		System.out.println("手机可以听音乐");
	}
}
```

```java
public class RingPhoneDecorate extends PhoneDecorate {

	public RingPhoneDecorate(Phone p) {
		super(p);
	}

	@Override
	public void call() {
		System.out.println("手机可以听彩铃");
		super.call();
	}
}
```

```java
Phone p = new IPhone();
p.call();
System.out.println("------------");

// 需求：我想在接电话前，听彩铃
PhoneDecorate pd = new RingPhoneDecorate(p);
pd.call();// 听彩铃打电话

// 需求：我想在接电话后，听音乐
pd = new MusicPhoneDecorate(p);
pd.call();// 打电话听音乐

// 需求：我要想手机在接前听彩铃，接后听音乐
// 自己提供装饰类，在打电话前听彩铃，打电话后听音乐或者嵌套使用装饰类
pd = new RingPhoneDecorate(new MusicPhoneDecorate(p));
pd.call();// 同时听彩铃打电话听音乐
```

```java
// Jdk中的装饰模式
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Scanner sc = new Scanner(System.in);
```

### 适配器设计模式

将一个类的接口转换成另外一个客户希望的接口。从而使原来不能直接调用的接口变的可以调用。

* 优点
	- 让本来不适合使用的接口变得适合使用
* 缺点
	- 一次只能适配一个类，使用有一定的局限性

```java
/*
 * 针对用户操作的四种功能接口
 */
public interface UserDao {
	public abstract void add();

	public abstract void delete();

	public abstract void update();

	public abstract void find();
}
```

```java
//适配器类
public abstract class UserAdapter implements UserDao {

	@Override
	public void add() {
	}

	@Override
	public void delete() {
	}

	@Override
	public void update() {
	}

	@Override
	public void find() {
	}

}
```

```java
// 适配器模式实现类
public class UserDaoImpl2 extends UserAdapter {
	@Override
	public void add() {
		System.out.println("添加功能");
	}
}
```

### 桥接模式

使用聚合代替继承，解决两个维度排列组合问题

### 享元模式

享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。  
例如IntegerCache和String字符串常量池

### 责任链模式

```java
public interface Filter {
    void doFilter(Request request, Response response, FilterChain filterChain);
}

public class MyFirstFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "first";
        filterChain.doFilter(request, response, filterChain);
        response.output += "first";
    }
}

public class MySecondFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "second";
        filterChain.doFilter(request, response, filterChain);
        response.output += "second";
    }
}
//过滤器链
public class FilterChain {
    private List<Filter> filters = new ArrayList<Filter>();
    Iterator<Filter> iterator;
    public FilterChain addFilter(Filter filter) {
        filters.add(filter);
        return this;
    }
    public FilterChain addFilter(FilterChain filterChain) {
        filters.addAll(filterChain.filters);
        return this;
    }
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        if (iterator == null) {
            iterator = filters.iterator();
        }
        if (iterator.hasNext()) {
            iterator.next().doFilter(request, response, filterChain);
        }
    }
}
```

### 策略模式

具体比较方法交给不同的装配策略实现，AOP中的advice也是策略模式

Comparable和Comparator

```java
public class MyNumber implements Comparable<MyNumber> {
    int value;
    private Comparator<MyNumber> myNumberComparator;
    public MyNumber(Comparator<MyNumber> myNumberComparator) {
        this.myNumberComparator = myNumberComparator;
    }
    @Override
    public int compareTo(MyNumber o) {
        return myNumberComparator.compare(this, o);
    }
    public int getValue() {
        return value;
    }
    public void setValue(int value) {
        this.value = value;
    }
}
```

```java
public class MyComparator implements Comparator<MyNumber> {
    @Override
    public int compare(MyNumber o1, MyNumber o2) {
        return o1.value - o2.value;
    }
}
```

----------

*以上概念总结于传智播客Java基础课程*