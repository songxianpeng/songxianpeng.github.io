---  
layout: post  
title: 设计模式  
tags: 设计模式  
categories: Java  
published: true  
---  

## 面向对象思想设计原则

* 单一职责原则(高内聚，低耦合)
	- 每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个
* 开闭原则
	- 一个对象对扩展开放，对修改关闭，对类的改动是通过增加代码进行的，而不是修改现有代码
		+ 借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。
* 里氏替换原则
	- 在任何父类出现的地方都可以用它的子类来替代。
* 依赖注入原则
	- 要依赖于抽象，不要依赖于具体实现。
		+ 编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。
* 接口分离原则
	- 不应该强迫程序依赖它们不需要使用的方法。
		+ 一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。
* 迪米特原则
	- 一个对象应当对其他对象尽可能少的了解
		+ 降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用

### 设计原则（Head first设计模式）

* 找出程序中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起
* 针对接口编程，而不是针实现编程
* 多用组合，少用继承
* 为了交互对象之前的松耦合设计而努力
	- 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低
* 类应该对扩展开放，对修改关闭
* 要依赖抽象，不要依赖具体类（依赖倒置原则）
	- 变量不可以持有具体类的引用
	- 不要让类派生自具体类
	- 不要覆盖基类中已实现的方法
* 最少知识原则（墨忒耳法则）
	- 减少对象之间的交互（减少对象之间耦合）
	- 只调用以下范围的方法
		+ 该对象本身
		+ 被当做方法的参数而传递进来的对象
		+ 此方法所创建或实例化的任何对象
		+ 对象的任何组件（被实例变量的引用）
	- 会增加封装用于和其他对象交互，复杂度和开发时间上升，并降低了运行时性能
* 好莱坞原则
	- 高层组件对低层组件的依赖方式是：别调用我们，我们会调用你
* 一个类应该只有一个引起变化的原因，尽量让每个类保持单一职责
	- 当一个模块或一个类被设计成只支持一组相关的功能时，我们说他具有高内聚，反之，当被设计成支持一组不相关的功能时，我说他具有低内聚

### 复用机制

* 继承
	- 白箱复用
	- 破坏了封装性
	- 父类子类依赖紧密，父类改变会影响子类
* 对象组合
	- 黑箱复用
	- 不破坏封装性
	- 依赖接口而解耦
	- 有助于保持每个类被封装，并集中在单个任务上
	- 动态的参数化的软件比静态的软件难于理解
	- 运行时效率低（主要）
	- 委托是对象组合的特例

**优先使用对象组合，而不是类继承**

## 设计模式

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。  
模式是在某情境下，针对某问题的某种解决方案

### 设计模式分类

* 创建型模式(对象的创建)(5个)
	- 简单工厂模式（静态工厂方法模式）(Simple Factory)
		+ 简单工厂模式不是GoF总结出来的23种设计模式之一
	- 工厂方法模式(Factory Method)
	- 抽象工厂模式(Abstract Factory)
	- 建造者模式(Builder)
	- 原型模式(Prototype)
	- 单例模式(Singleton)
* 结构型模式(处理类或对象的组合)(7个)
	- 外观模式(Facade)
	- 适配器模式(Adatper)
	- 代理模式(Proxy)
	- 装饰模式(Decorator)
	- 桥接模式(Bridge)
	- 组合模式(Composite)
	- 享元模式(Flyweight)
* 行为型模式(类或对象的交互和职责分配)(11个)
	- 模版方法模式(Template Method)
	- 观察者模式(Observer)
	- 状态模式(State)
	- 职责链模式(Chain of Responsibility)
	- 命令模式(Command)
	- 访问者模式(Visitor)
	- 策略模式(Strategy)
	- 备忘录模式(Memento)
	- 迭代器模式(Iterator)
	- 解释器模式(Interpreter)
	- 中介者模式(Mediator)

|          |  创建型  |     结构性     |  行为型  |
|----------|----------|----------------|----------|
| 用于类   | 工厂方法 | 适配器 （类）  | 解释器   |
|          |          |                | 模板方法 |
| 用于对象 | 抽象工厂 | 适配器（对象） | 责任链   |
|          | 创建者   | 桥接           | 命令     |
|          | 原型     | 组合           | 迭代器   |
|          | 单例     | 装饰           | 中介者   |
|          |          | 外观           | 备忘录   |
|          |          | 享元           | 观察者   |
|          |          | 代理           | 状态     |
|          |          |                | 策略     |
|          |          |                | 访问者   |

* 类模式用户处理类和子类之间的关系，这些关系通过继承建立，是静态的，编译时就确定下来了
* 对象模式处理对象之间的关系，这些关系具有动态性，运行时可变化

![relation](/static/img/Pattern/relation.jpg "relation")

### 简单工厂模式（静态工厂方法模式）

所有工厂模式都用来封装对象的创建

简单工厂模式又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责

* 缺点
	- 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护

```java
public class AnimalFactory {

	private AnimalFactory() {
	}

	// public static Dog createDog() {
	// return new Dog();
	// }
	//
	// public static Cat createCat() {
	// return new Cat();
	// }

	public static Animal createAnimal(String type) {
		if ("dog".equals(type)) {
			return new Dog();
		} else if ("cat".equals(type)) {
			return new Cat();
		} else {
			return null;
		}
	}
}

```

### 工厂方法模式

工厂方法模式定义了创建对象的接口，但由子类决定要实例化的是哪一个，工厂方法让类把实例化推迟到子类

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性

* 缺点
	- 需要额外的编写代码，增加了工作量

```java
public abstract class MethodFactory {
    private void prepare() {
        System.out.println("prepare");
    }
    private void finish() {
        System.out.println("finish");
    }
    protected abstract void operate();
    public void getReady() {
        prepare();
        operate();
        finish();
    }
}

public class MyMethodFactory extends MethodFactory {
    protected void operate() {
        System.out.println("my operate");
    }
}

@Test
public void operate() throws Exception {
    MethodFactory methodFactory = new MyMethodFactory();
    methodFactory.getReady();
    MethodFactory methodFactory = new MyMethodFactory1();
    methodFactory.getReady();
}
```

### 抽象工厂模式

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

```java
public interface AbstractFactory {
	public abstract Animal createAnimal();
}
```

```java
public class DogFactory implements AbstractFactory {
	@Override
	public Animal createAnimal() {
		return new Dog();
	}
}
```

```java
public class CatFactory implements AbstractFactory {
	@Override
	public Animal createAnimal() {
		return new Cat();
	}
}
```

```java
AbstractFactory f = new DogFactory();
Animal a = f.createAnimal();
a.eat();

f = new CatFactory();
a = f.createAnimal();
a.eat();
```

### 工厂方法模式和抽象工厂模式

* 工厂方法模式通过子类创建对象，抽象工厂通过实现类（对象组合）创建对象
* 抽象工厂的方法常以工厂方法模式实现
* 抽象工厂和工厂方法用于实例化具体类的解耦
* 抽象工厂用于创建产品家族和想让制造的相关产品集合起来

> 所有的工厂模式都是用来封装对象的创建  
> 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦  
> 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象  
> 抽象工厂使用组合：对象的创建被实现在工厂接口所暴漏出来的方法中  
> 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合  
> 工厂方法允许类将实例化延迟早子类进行  
> 抽象工厂创建相关的对象家族，而不需要依赖他们的具体类  
> 依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象  
> 工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体编程  

### 创建者模式

创建者模式封装一个产品的构造过程，并允许按步骤构造

* 优点：
	- 将一个复杂对象的创建过程封装起来
	- 允许通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）
	- 向客户隐藏产品内部的实现
	- 产品的实现可以被替换，因为客户只看到一个抽象的接口
* 缺点：
	- 采用创建者模式创建对象的客户，需要具备更多的领域知识

### 原型模式

在创建给定类的实例的过程很昂贵或复杂时，使用原型模式  
原型模式常用来代替抽象工厂  

* 用途：
	- 在一个复杂的类层次中，当系统不洗从其中的许多类型创建新对象时，可以考虑原型
* 优点：
	- 向客户隐藏制造新实例的复杂性
	- 提供让客户能够产生位置类型对象的选项
	- 在某些环境下，复制对象比创建新对象更有效
* 缺点：
	- 对象复制有时相当复杂

### 单例模式

确保一个类只有一个实例，并提供一个全局访问点  
单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。

* 优点
	- 在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
	- 可以延迟实例化
* 缺点
	- 没有抽象层，因此扩展很难。
	- 职责过重，在一定程序上违背了单一职责

> 单例模式确保程序中一个类最多只有一个实例  
> 单例模式也提供访问这个实例的全局点  
> 在Java中实现单例模式需要私有的狗仔器、一个静态方法和一个静态变量  
> 确定在性能和资源上的限制，然后小心的选择适当的方案来实现单例，以解决多线程的问题（我们必须认定所有的程序都是多线程）  
> 如果不采用第五版以后的Java2，双重检查加锁的实现会失效  
> 小心，如果你使用多个类加载器，可能导致单例失效而产生多个实例  
> 如果使用JVM1.2或之前的版本，你必须建立单例注册表，以免垃圾回收器将单例回收  

#### 设计思想

保证类在内存中只有一个对象

**如何实现类在内存中只有一个对象呢?**

* 构造私有
* 本身提供一个对象
* 通过公共的方法让外界访问

#### 饿汉式(开发)

```java
public class Singleton {
	// 构造私有
	private Singleton() {
	}

	// 自己造一个
	// 静态方法只能访问静态成员变量，加静态
	// 为了不让外界直接访问修改这个值，加private
	private static Singleton s = new Singleton();

	// 提供公共的访问方式
	// 为了保证外界能够直接使用该方法，加静态
	public static Singleton getSingleton() {
		return s;
	}
}
```

#### 懒汉式

线程安全问题

懒加载思想(延迟加载)

```java
public class Singleton {
	private Singleton() {
	}
	// 使用volatile禁止指令重排
	private volatile static  Singleton t = null;
	// 锁范围较大
	public synchronized static Singleton getSingleton() {
		if (t == null) {//这里有线程安全问题 所以要枷加锁
			t = new Singleton();
		}
		return t;
	}
	// 缩小锁范围，但是要做双重检查 jdk 1.5以后有效
	public static Singleton getSingleton() {
		if (t == null) {
			synchronized(Singleton.class){
				if (t == null) {// 双重检查
					t = new Singleton();
				}
			}
		}
		return t;
	}
}
```

#### 内部类方式（static holder）

既支持了延迟加载，也是线程安全的，较完美的解决方案

> **多线程缺省同步锁的知识：**
> 解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制，但是在某些情况下，JVM已经隐含的为您执行了同步，不用自己再来进行同步控制。  
> 
> 1. 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时  
> 2. 访问final字段时  
> 3. 在创建线程之前创建对象时  
> 4. 线程可以看见它将要处理的对象时  

> 要想很简单的实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是会浪费一定的时间空间？因为这种实现方式，会在类装载的时候就初始化对象。

> 一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同步实现延迟加载和线程安全。

```java
public class Singleton {
    private static class StaticHolder {
        private static Singleton instance;
        static {
            instance = new Singleton();
        }
    }
    private Singleton(){
    }
    public static Singleton getInstance() {
        return StaticHolder.instance;
    }
}
```

#### 枚举式（推荐）

好处

1. 线程安全（枚举底层是线程安全的）
2. 不会因为序列化而产生新的实例（因为它自己实现了readResolve方法）
3. 防止反射攻击。（因为enum实际上是abstract的）

```java
public enum Singleton {
    INSTANCE;
    Singleton() {
    }
    public void operate() {
    }
}
```

#### 类加载器和jdk1.2垃圾回收问题

*多个类加载器会在各自的命名空间下加载同一个类，造成存在一个类的多一个实例*

解决：指定同一个类加载器加载

*JDK1.2之前会将单例模式认为是没有引用而回收，再次getInstance()又创建一个对象*

解决：建立单例注册表...使用全局引用指向单例？

### 外观模式

提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用  
外观不只是简化接口，也将客户端从组件的子系统中解耦  

```java
public class ProgramFacade {
    private Designer designer;
    private Programmer programmer;
    private Tester tester;
    private Operator operator;
    public ProgramFacade(Designer designer, Programmer programmer, Tester tester, Operator operator) {
        this.designer = designer;
        this.programmer = programmer;
        this.tester = tester;
        this.operator = operator;
    }
    public void buildProgram(Program program){
        designer.design(program);
        programmer.program(program);
        tester.test(program);
        operator.operate(program);
    }
    public void shutdownProgram(Program program){
        operator.shutdown(program);
    }
}

```

### 适配器模式

将一个类的接口转换成另外一个客户希望的接口。从而使原来不能直接调用的接口变的可以调用。  
适配器有两种形式：对象适配器和类适配器，对象适配器使用组合，类适配器需要多继承  

* 优点
	- 让本来不适合使用的接口变得适合使用
* 缺点
	- 一次只能适配一个类，使用有一定的局限性


*接口实现类适配*

```java
/*
 * 针对用户操作的四种功能接口
 */
public interface UserDao {
	public abstract void add();
	public abstract void delete();
	public abstract void update();
	public abstract void find();
}
```

```java
//适配器类
public abstract class UserAdapter implements UserDao {
	@Override
	public void add() {
	}
	@Override
	public void delete() {
	}
	@Override
	public void update() {
	}
	@Override
	public void find() {
	}
}
```

```java
// 适配器模式实现类
public class UserDaoImpl2 extends UserAdapter {
	@Override
	public void add() {
		System.out.println("添加功能");
	}
}
```

*不同接口转换适配*

```java
public class EnumerationIteratorAdaptor implements Iterator {
    private Enumeration enumeration;
    public EnumerationIteratorAdaptor(Enumeration enumeration) {
        this.enumeration = enumeration;
    }
    public boolean hasNext() {
        return enumeration.hasMoreElements();
    }
    public Object next() {
        return enumeration.nextElement();
    }
    public void remove() {
        throw new UnsupportedOperationException("adapter not implement method");
    }
}
```

### 适配器模式和外观模式

外观和适配器可以包装许多类，但是外观的意图是简化接口，而是配置的意图是将接口转换成不同接口

> 当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器  
> 当需要简化并统一一个很大的接口或者一群复杂的接口是，使用外观  
> 适配器改变接口以符合客户的期望  
> 外观将客户从一个复杂的子系统中解耦  
> 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定  
> 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行  
> 适配器模式有两种形式：对象适配器和类适配器，类适配器需要用到多重继承  
> 你可以为一个子系统实现一个以上的外观  
> 适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以新增行为和责任；而外观将一群对象包装起来以简化其接口  

### 代理模式

代理模式为另一个对象提供一个替身或占位符以控制这个对象的访问  
使用代理模式创建爱你代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象

* 远程代理
	- Java的RMI调用
* 虚拟代理（必要时创建被代理对象）
	- 懒加载
* 保护代理
	- 决定对象访问
* 防火墙代理
	- 防火墙系统
* 智能引用代理
* 缓存代理
	- Web服务器代理
* 同步代理
	- JavaSpaces
* 复杂隐藏代理
* 写入时复制代理
	- CopyOnWriteArrayList
* 动态代理
	- java.util.reflect包提供Proxy类实现接口代理
	- cglib的继承代理

> 代理模式为另一个对象提供代表，以遍控制对对象的访问，管理访问的形式有许多种  
> 远程代理管理客户和远程对象之间的交互  
> 虚拟代理控制访问实例化开销大的对象  
> 保护代理基于调用者控制对对象方法的访问  
> 代理模式有许多变体，如：缓存代理、同步代理、防火墙代理和写入时复制代理  
> 代理在结构上类似装饰者，但是目的不同：装饰者模式为对象加上行为，而代理是控制访问  
> Java内置支持代理，可以根据需要建立动态代理，并将所有调用分配到所选处理器  
> 就和其他的包装着（wrapper）一样，代理会造成你的设计中类的数目增加  

```java
// 虚拟代理（此实例可以使用状态模式改写）
public class ImageProxy implements Icon {
    private ImageIcon imageIcon;
    @Override
    public void paintIcon(Component c, Graphics g, int x, int y) {
        if (imageIcon == null) {
            imageIcon.paintIcon(c, g, x, y);
        } else {
            g.drawString("loading....", x, y);
            //imageIcon=.......load image code
        }
    }
    @Override
    public int getIconWidth() {
        if (imageIcon == null) {
            return 800;
        } else {
            return imageIcon.getIconWidth();
        }
    }
    @Override
    public int getIconHeight() {
        if (imageIcon == null) {
            return 800;
        } else {
            return imageIcon.getIconHeight();
        }
    }
}
```

**动态代理**

*参见《反射和动态代理部分》*

### 装饰者模式

动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的方案  
装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案  

* 优点
	- 使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能
* 缺点
	- 正因为可以随意组合，所以就可能出现一些不合理的逻辑

> 继承属于扩展形式之一，单不见得是达到弹性设计的最佳方式  
> 在我们的设计中，应该允许行为被拓展，而无需修改现有的代码  
> 组合和委托可用于在运行时动态的加上行为  
> 除了继承，装饰者模式也可以让我们扩展行为  
> 装饰者模式意味着一群装饰者类，这些类用来包装具体组件  
> 装饰者类反映出被装饰者的组件类型（事实上，他们拥有相同的类型，都经过接口或继承实现）  
> 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者整个替代掉，而达到特定的目的  
> 你可以用无数个装饰者包装一个组件  
> 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型  
> 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂  

```java
public interface Phone {
	public abstract void call();
}
```

```java
public class IPhone implements Phone {
	@Override
	public void call() {
		System.out.println("手机可以打电话了");
	}
}
```

```java
// 装饰抽象类
public abstract class PhoneDecorate implements Phone {
	private Phone p;
	public PhoneDecorate(Phone p) {
		this.p = p;
	}
	@Override
	public void call() {
		this.p.call();
	}
}
```

```java
public class MusicPhoneDecorate extends PhoneDecorate {
	public MusicPhoneDecorate(Phone p) {
		super(p);
	}
	@Override
	public void call() {
		super.call();
		System.out.println("手机可以听音乐");
	}
}
```

```java
public class RingPhoneDecorate extends PhoneDecorate {
	public RingPhoneDecorate(Phone p) {
		super(p);
	}
	@Override
	public void call() {
		System.out.println("手机可以听彩铃");
		super.call();
	}
}
```

```java
Phone p = new IPhone();
p.call();
System.out.println("------------");

// 需求：我想在接电话前，听彩铃
PhoneDecorate pd = new RingPhoneDecorate(p);
pd.call();// 听彩铃打电话

// 需求：我想在接电话后，听音乐
pd = new MusicPhoneDecorate(p);
pd.call();// 打电话听音乐

// 需求：我要想手机在接前听彩铃，接后听音乐
// 自己提供装饰类，在打电话前听彩铃，打电话后听音乐或者嵌套使用装饰类
pd = new RingPhoneDecorate(new MusicPhoneDecorate(p));
pd.call();// 同时听彩铃打电话听音乐
```

```java
// Jdk中的装饰模式
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Scanner sc = new Scanner(System.in);
```

### 桥接模式

使用聚合代替继承，解决两个维度排列组合问题  
使用桥接模式，不止改变你的实现，也改变你的抽象。

* 用途
	- 适合使用在需要跨多个平台的图形和窗口系统上
	- 当需要用不同的方式改变接口和实现时，你会返现桥接模式很好用
* 好处：
	- 将实现予以解耦
	- 抽象和实现可以独立扩展，不会影响到对方
	- 对于“具体的抽象类”所做的改变，不会影响到客户
* 缺点：
	- 增加了复杂度

### 组合模式

组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象及对象组合  
组合模式让我们能使用树形方式创建对象的结构，树里面包含了组合以及个别的对象。  
使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别  

*组合包含组件，组件包含两种：组合和叶子节点元素*

> 组合模式提供一个机构，可同时包容个别对象和组合对象  
> 组合模式允许客户对个别对象以及组合对象一视同仁  
> 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶子节点  
> 在实现组合模式时，有许多设计上的折衷，要根据需要平衡透明性和安全性  

组合模式常和迭代器模式和访问者模式一起使用

#### 组合模式和迭代器模式组合使用

```java
// 组合接口
public interface Composite /*extends Iterable*/{
    // 添加组件
    void add(Composite composite);
    // 删除组件
    void remove(Composite composite);
    // 返回组件的遍历
    Iterator<Composite> iterator();
}
```

```java
// 日程组合
public class Schedule implements Composite {
    private String name;
    public Schedule(String name) {
        this.name = name;
    }
    // 组件
    private ArrayList<Composite> composites = new ArrayList<>();
    @Override
    public void add(Composite composite) {
        composites.add(composite);
    }
    @Override
    public void remove(Composite composite) {
        composites.remove(composite);
    }
    @Override
    public Iterator<Composite> iterator() {
        return composites.iterator();
    }
    @Override
    public String toString() {
        return "Schedule{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
// 会议组件
public class Meeting implements Composite {
    private String name;
    public Meeting(String name) {
        this.name = name;
    }
    @Override
    public void add(Composite composite) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void remove(Composite composite) {
        throw new UnsupportedOperationException();
    }
    @Override
    public Iterator<Composite> iterator() {
        return null;
    }
    @Override
    public String toString() {
        return "Meeting{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java

// 组合模式的迭代器
public class CompositeIterator implements Iterator<Composite> {
    // 用栈保存当前的未进行的迭代器
    private Stack<Iterator<Composite>> iterators = new Stack<>();
    public CompositeIterator(Iterable<Composite> composites) {
        // 将最开始的迭代器进栈
        iterators.push(composites.iterator());
    }
    @Override
    public boolean hasNext() {
        // 如果栈内没有课迭代对象，则结束
        if (iterators.size() == 0) {
            return false;
        } else {
            //查看当前迭代器是否有下一个对象
            Iterator iterator = iterators.peek();
            if (iterator.hasNext()) {// 如果有，可以调用next
                return true;
            } else {
                iterators.pop();//没有则当前迭代器出栈，递归判断下一迭代器
                return hasNext();
            }
        }
    }
    @Override
    public Composite next() {
        // hasNext时取出当前迭代器的next
        Composite next = iterators.peek().next();
        if (next.iterator() != null) {
            // 如果当前遍历对象有子，当前对象迭代器进栈，下次遍历当前对象的子
            iterators.push(next.iterator());
        }
        return next;
    }
}
```

```java
@Test
public void test() throws Exception {
    Schedule today = new Schedule("today");
    Schedule morning = new Schedule("morning");
    morning.add(new Meeting("1"));
    morning.add(new Meeting("2"));
    morning.add(new Meeting("3"));
    today.add(morning);
    Schedule afternoon = new Schedule("afternoon");
    afternoon.add(new Meeting("4"));
    afternoon.add(new Meeting("5"));
    afternoon.add(new Meeting("6"));
    today.add(afternoon);
    Schedule tomorrow = new Schedule("tomorrow");
    tomorrow.add(new Meeting("7"));
    tomorrow.add(new Meeting("8"));
    tomorrow.add(new Meeting("9"));
    Schedule noon = new Schedule("noon");
    noon.add(new Meeting("10"));
    noon.add(new Meeting("11"));
    noon.add(new Meeting("12"));
    tomorrow.add(noon);
    ArrayList<Composite> composites = new ArrayList<>();
    composites.add(today);
    composites.add(tomorrow);

    CompositeIterator compositeIterator = new CompositeIterator(composites);
    while (compositeIterator.hasNext()) {
        System.out.println(compositeIterator.next());
    }
    // Schedule{name='today'}
    // Schedule{name='morning'}
    // Meeting{name='1'}
    // Meeting{name='2'}
    // Meeting{name='3'}
    // Schedule{name='afternoon'}
    // Meeting{name='4'}
    // Meeting{name='5'}
    // Meeting{name='6'}
    // Schedule{name='tomorrow'}
    // Meeting{name='7'}
    // Meeting{name='8'}
    // Meeting{name='9'}
    // Schedule{name='noon'}
    // Meeting{name='10'}
    // Meeting{name='11'}
    // Meeting{name='12'}
}
```

### 享元模式

如果想让某个类的一个实例能用来提供许多“虚拟实例”，就使用享元模式  
享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。  
例如IntegerCache和String字符串常量池

* 用途：
	- 当一个类有许多实例，而这些实例能被同一个方法控制的时候，使用享元模式
* 优点：
	- 减少运行时对象实例的个数，节省内存
	- 将许多的“虚拟”对象的状态集中管理
* 缺点：
	- 一旦你实现了它，那么单个逻辑的实例将无法拥有独立而不同的行为


### 模版方法模式

模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

* 优点
	- 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，既兼顾了原则性，有不失灵活性
* 缺点
	- 如果算法骨架有修改的话，则需要修改抽象类

> 模板方法定义了算法的步骤，把这些步骤实现延迟到子类  
> 模板方法模式为我们提供了一种代码复用的重要技巧  
> 模板方法的抽象类可以定义具体方法、抽象方法和钩子  
> 抽象方法由子类实现  
> 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它  
> 为了防止子类改变模板方法中的算法，可以将模板方法声明为final  
> 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块  
> 你将在真实世界代码中查看到模板方法模式的许多变体，不要期待他们全都是一眼可以被你认出来  
> 策略模式和模板方法模式都封装算法，一个用组合，一个用继承  
> 工厂方法是模板方法的一种特殊版本  

```java
public abstract class GetTime {
    // 需求：请给我计算出一段代码的运行时间
    // final防止子类覆盖
    public final long getTime() {
        long start = System.currentTimeMillis();
        code();
        long end = System.currentTimeMillis();
        if (isTraceMode()) {
            System.out.println("start at:" + start);
            System.out.println("end at:" + end);
        }
        return end - start;
    }
    // 必须实现，使用abstract
    public abstract void code();
    // 可选实现，使用钩子，提供默认实现，子类选择是否覆盖父类方法
    public boolean isTraceMode() {
        return true;
    }
}
```

```java
public class ForDemo extends GetTime {
	@Override
	public void code() {
		for (int x = 0; x < 100000; x++) {
			System.out.println(x);
		}
	}
}
```

### 观察者模式

观察者模式定义了对象之间的一(Subject)对多(Observer)依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新  
JDK自带了观察者模式实现，Observable类和Observer接口，但是Observable是一个类并没有实现任何接口所以很局限  

> 观察者模式定义了对象之间的一对多关系  
> 主题（也就是观察者）用一个共同的接口来更新观察者  
> 观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现类观察者接口  
> 使用此模式时，你可以从被观察者出推（push）或拉（pull）数据，然而，推的方式被认为更正确  
> 有多个观察者时，不可以依赖特定的通知次序（取消订阅会影响顺序）  
> Java有多种观察者模式的实现，包括了通用的java.util.Observable，要注意它的一些问题，如果有必要的话，可以实现Obserable  
> Swing大量使用观察者模式，许多GUI框架也如此  
> 此模式被应用在很多地方，如JavaBeans、RMI  

```java
// 主题
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

public class MySubject implements Subject {
    private String message;
    List<Observer> observers = new ArrayList<Observer>();
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this, this);
        }
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
}
// 观察者
public interface Observer {
    void update(Subject subject, Object args);
}

public class MyObserver implements Observer {
    public MyObserver(Subject subject) {
        subject.registerObserver(this);
    }
    public void update(Subject subject, Object args) {
        if (subject instanceof MySubject) {
            MySubject mySubject = (MySubject) args;
            System.out.println(mySubject.getMessage());
        }
    }
}
//测试
@Test
public void update() throws Exception {
    MySubject subject = new MySubject();
    MyObserver myObserver = new MyObserver(subject);
    MyObserver myObserver1 = new MyObserver(subject);
    MyObserver myObserver2 = new MyObserver(subject);
    MyObserver myObserver3 = new MyObserver(subject);
    MyObserver myObserver4 = new MyObserver(subject);
    subject.setMessage("hello");
    subject.notifyObservers();
}
```

### 状态模式

策略模式和状态模式时双胞胎  
允许对象在内部状态改变时，改变它的行为，对象看起来好像修改了它的类。

> 状态模式允许一个对象基于内部状态而拥有不同的行为  
> 和程序状态机（PSM）不同，状态模式用类代表状态  
> Context会将行为委托给当前状态  
> 通过将每个状态封装进一个类，我们把以后需要做的任何更改都局部化了  
> 状态模式和策略模式有相同的类图，但是他们的意图不同  
> 策略模式通常会用行为或算法来配置Context类  
> 状态模式允许Context随着状态的改变而改变行为  
> 状态转换可以由State类或Context控制  
> 使用状态模式通常会导致类的数目大量增加  
> 状态类可以被多个Context实例共享  

```java
public interface State {
    void handle();
}
```

```java
public abstract class AbstractState implements State {
    TrafficLightContext trafficLightContext;
    private String name;
    private Double i = 1d;
    AbstractState(TrafficLightContext trafficLightContext, String name, Double i) {
        this.trafficLightContext = trafficLightContext;
        this.name = name;
        if (i != null) {
            this.i = i;
        }
    }
    @Override
    public void handle() {
        System.out.println(MessageFormat.format("{0} light", name));
        try {
            Thread.sleep(new Double(i * 1000).longValue());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class GreenState extends AbstractState {
    GreenState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "green", 1d);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getYellowState());
    }
}

public class RedState extends AbstractState {
    RedState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "red", 1d);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getGreenState());
    }
}

public class YellowState extends AbstractState {
    YellowState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "yellow", 0.5);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getRedState());
    }
}
```

```java
public class TrafficLightContext {
    private YellowState yellowState;
    private RedState redState;
    private GreenState greenState;
    private State state;
    TrafficLightContext() {
        this.yellowState = new YellowState(this);
        this.redState = new RedState(this);
        this.greenState = new GreenState(this);
        this.state = redState;
    }
    public void change() {
        state.handle();
    }
    public YellowState getYellowState() {
        return yellowState;
    }
    public RedState getRedState() {
        return redState;
    }
    public GreenState getGreenState() {
        return greenState;
    }
    public void setState(State state) {
        this.state = state;
    }
}
```

```java
@Test
public void change() throws Exception {
    TrafficLightContext trafficLightContext = new TrafficLightContext();
    int i = 10;
    while (i > 0) {
        trafficLightContext.change();
        i--;
    }
}
```

### 责任链模式

当你想让一个以上的对象有你会能够处理某个请求的时候，就使用责任链模式


* 用途：
	- 经常被使用在窗口系统中，处理鼠标和键盘的事件
* 优点：
	- 将请求的发送者和接受者解耦
	- 可以简化你的对象，因为他不需要知道链的结构
	- 通过改变链内部的成员或调动它的次序，允许你动态的增加或删除责任
* 缺点：
	- 并不能保证请求一定会被执行，如果没有任何对象处理它的话，它可能落到链微端之外
	- 可能不容易观察运行时特征，有碍于除错


```java
public interface Filter {
    void doFilter(Request request, Response response, FilterChain filterChain);
}

public class MyFirstFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "first";
        filterChain.doFilter(request, response, filterChain);
        response.output += "first";
    }
}

public class MySecondFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "second";
        filterChain.doFilter(request, response, filterChain);
        response.output += "second";
    }
}
//过滤器链
public class FilterChain {
    private List<Filter> filters = new ArrayList<Filter>();
    Iterator<Filter> iterator;
    public FilterChain addFilter(Filter filter) {
        filters.add(filter);
        return this;
    }
    public FilterChain addFilter(FilterChain filterChain) {
        filters.addAll(filterChain.filters);
        return this;
    }
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        if (iterator == null) {
            iterator = filters.iterator();
        }
        if (iterator.hasNext()) {
            iterator.next().doFilter(request, response, filterChain);
        }
    }
}
```

### 命令模式

将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作

**适用场景**

* 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互
* 需要在不同的时间指定请求、将请求排队
* 系统需要支持命令的撤消(undo)

> 命令模式将发出请求的对象和执行请求的对象解耦  
> 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作  
> 调用者通过调用命令对象的execute()发出请求，这会使得接受者的动作被调用  
> 调用者可以接受命令当做参数，甚至在运行时动态的进行  
> 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态  
> 宏命令是命令的一种简单延伸，允许调用多个命令，红方法也可以支持撤销  
> 实际操作室，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接受者  
> 命令也可以用来实现日志和事务系统  

```java
public class Light {
    public void on() {
        System.out.println("light");
    }
    public void off() {
        System.out.println("...");
    }
}

public interface Command {
    void execute();
    //void undo();通过子类实现undo方法撤销
}

public class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) {
        this.light = light;
    }
    public void execute() {
        light.on();
    }
}
public class LightOffCommand implements Command {
    private Light light;
    public LightOffCommand(Light light) {
        this.light = light;
    }
    public void execute() {
        light.off();
    }
}

public class Invoker {
    Command command;
    //Command lastCommand;
    //void undo(){lastCommond.undo();};
    public Invoker(Command command) {
        this.command = command;
    }
    void invoke() {
        command.execute();
        //lastCommand = command;
    }
    public void setCommand(Command command) {
        this.command = command;
    }
}

public class Client {
    public static void main(String[] args) {
    	    // 实现Light、Car等Reciver和Invoker之间解耦
        Light light = new Light();
        Command command = new LightOnCommand(light);
        Invoker invoker = new Invoker(command);
        invoker.invoke();
        command = new LightOffCommand(light);
        invoker.setCommand(command);
        invoker.invoke();
        Car car = new Car();
        command = new CarDriveCommand(car);
        invoker.setCommand(command);
        invoker.invoke();
    }
}
```

### 访问者模式

当你需要为一个对象的组合增加新的能力，且封装并不重要时，使用访问者模式

* 优点：
	- 允许你对组合结构加入新的操作，而无需改变结构本身
	- 想要加入新的操作，相对容易
	- 访问者所进行的操作，其代码时集中在一起的
* 缺点：
	- 会打破组合类的封装
	- 游走的功能牵涉其中，所以对组合结构的改变就更加困难

### 策略模式

定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户  
具体比较方法交给不同的装配策略实现，AOP中的advice也是策略模式  

Comparable和Comparator

```java
public class MyNumber implements Comparable<MyNumber> {
    int value;
    private Comparator<MyNumber> myNumberComparator;
    public MyNumber(Comparator<MyNumber> myNumberComparator) {
        this.myNumberComparator = myNumberComparator;
    }
    @Override
    public int compareTo(MyNumber o) {
        return myNumberComparator.compare(this, o);
    }
    public int getValue() {
        return value;
    }
    public void setValue(int value) {
        this.value = value;
    }
}
```

```java
public class MyComparator implements Comparator<MyNumber> {
    @Override
    public int compare(MyNumber o1, MyNumber o2) {
        return o1.value - o2.value;
    }
}
```

### 备忘录模式

当你让对象返回之前的状态时，使用备忘录模式

* 目标：
	- 储存系统关键对象的重要状态
	- 维护关键对象的封装
* 优点：
	- 将被储存的状态放在外面，不要和关键对象混在一起
	- 保持关键对象的数据封装
	- 提供了容易实现的恢复能力
* 缺点：
	- 储存和恢复状态的过程可能相当耗时
	- 考虑使用序列化机制替代

### 迭代器模式

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴漏其内部的表示  
把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所  

> 迭代器允许访问聚合的元素，而不需要暴漏它的内在结构  
> 迭代器将遍历聚合的工作封装近一个对象中  
> 当使用迭代器的时候，我们依赖聚合提供遍历  
> 迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制  
> 我们应该努力让一个类只分配一个责任  

```java
// Jdk的Iterator接口
public interface Iterator<E> {
    boolean hasNext();
    E next();
    // defalut方法不用实现
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}

```

```java
public class MyIntegerIterator implements Iterator<Integer> {
    private Integer integer;
    public MyIntegerIterator(Integer integer) {
        this.integer = integer;
    }
    public boolean hasNext() {
        return integer < Integer.MAX_VALUE;
    }
    public Integer next() {
	    //自动拆箱 return this.integer = this.integer.intValue() + 1;
        return ++integer;
    }
}
```

### 解释器模式

* 优点：
	- 将每一个Context规则表示成一个类，方便与实现语言
	- 因为Context由许多类表示，所以你可以轻易的扩展此Context
	- 通过在类结构中加入新的方法，可以在解释的同时增加新的行为
* 缺点：
	- 当Context规则数目太大时，这个模式可能会变的非常繁杂

### 中介者模式

中介者模式集中相关对象之间复杂的沟通和控制方式

* 用途：
	- 常被用于协调相关的GUI组件
* 优点：
	- 通过将对象彼此解耦，可以增加对象的复用性
	- 通过将控制逻辑集中，可以简化系统维护
	- 可以让对象之间所传递的消息变得简单且大幅减少
* 缺点：
	- 设计不当，增加复杂度

## 复合模式（Compound Patter）

模式通常被遗弃使用，并被组合在同一个设计解决方案中  
复合模式在同一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题，如MVC模式  

> MVC是复合模式，结合了观察者模式（Model是被观察者）、策略模式（Controller是策略）和组合模式（View内的控件管理）？？？  
> 模型使用观察者模式，以便观察者更新，同时保持两者之间解耦  
> 控制器是视图的策略，视图可以使用不同的控制器实现  
> 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，如面板、框架和按钮  
> 这些模式携手合作，把MVC模式的三层解耦，这样保持设计的干净又有弹性  
> 适配器模式用来将新的模型适配成已有的视图和控制器  

## 常见设计缺陷及解决

* 显示指定一个类创建对象
	- 工厂模式、原型模式
* 对特殊操作的依赖
	- 责任链模式、命令模式
* 对硬件或软件平台的依赖
	- 抽象工厂模式、桥接模式
* 对对象表示或实现的依赖
	- 抽象工厂模式、桥接模式、记事本模式、代理模式
* 算法依赖
	- 创建者模式、迭代器模式、策略模式、模范方法模式、访问者模式
* 紧耦合
	- 抽象工厂模式、命令模式、外观模式、中介者模式、观察者模式、责任链模式
* 通过生成子类扩展功能
	- 桥接模式、责任链模式、组合模式、装饰模式、观察者模式、策略模式
* 不能方便的对类进行修改
	- 适配器模式、装饰模式、访问者模式

----------

*以上概念总结于传智播客Java基础课程*