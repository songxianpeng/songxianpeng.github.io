---  
layout: post  
title: 设计模式  
tags: 设计模式  
categories: Java  
published: true  
---  

设计是有限度的，不能无限的考虑未来的变更情况，否则会陷入射击的泥潭而不能自拔

## 面向对象思想设计原则

* 单一职责原则(高内聚，低耦合)
	- 每个类（也适用于方法）应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个
		+ 职责和变化原因都是不可度量的，因项目和环境而异
		+ 会引起类的剧增
    + Why
      + 可维护性：仅在一个模块或类中需要进行更改。
    + Why
    	- 最佳实践：接口一定要做到单一职责，类尽量做到单一职责
    	- 应用[Curly's Law](https://blog.codinghorror.com/curlys-law-do-one-thing/)
* 开闭原则
    * 一个对象对扩展开放，对修改关闭，对类的改动是通过增加代码进行的，而不是修改现有代码，一个实体可以允许它的行为被修改而不改变它的源代码。
    * Why
      * 通过最小化对现有代码的更改来提高可维护性和稳定性。
    * How
      * 编写可以扩展的类（与可以修改的类相对）。
      * 仅暴露需要更改的移动部件，隐藏其他所有部件。
      * 借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展
      * 抽象约束
      	* 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现再接口或抽象类中不存在的public方法
      	* 参数类型、引用对象尽量使用接口或抽象类
      	* 抽象层尽量保持稳定，一旦确定即不允许修改
      * 封装变化
      	* 将相同的变化封装到同一个接口或抽象类中
      	* 将不同的变化封装到不同的接口或抽象类中的，不应该有两个不同的变化出现再同一个接口或抽象类中
* 里氏替换原则
	- 在任何父类出现的地方都可以用它的子类来替代，程序中的对象应与其子类型的实例一起替换，而不更改该程序的正确性。
		+ 子类必须完全实现父类的方法
		+ 子类可以有自己的个性
		+ 覆盖或实现父类的方法时输入参数可以被放大（不建议适用，子类不应对父类方法不应该重载，违背父类意图）
			* 子类中方法的前置条件必须与超类中的方法的前置条件相同或者更宽松（子类重载时参数要求要比父类方法宽泛）
		+ 覆写或实现父类的方法时输出结果可以被缩小
	- 最佳实践：避免子类个性化，如果必要个性化，重新提取一个父类
* 依赖倒置原则
	- 要依赖于抽象，不要依赖于具体实现
		+ 编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。
		+ 高层模块不应该依赖低层模块，两者都应该依赖其抽象
			* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口和抽象类产生的
		+ 抽象不应该依赖细节
			* 接口或抽象类不依赖于实现类
		+ 细节应该依赖抽象
			* 实现类依赖接口或抽象类
	- 最佳实践
		+ 每个类尽量都有接口或抽象类，或者兼备
		+ 变量的表面类型尽量是接口或抽象类
			* Util类一般不需要，如果使用类的clone方法，必须使用实现类，这是JDK提供的一个规范
		+ 尽量避免从具体类派生
		+ 尽量不要覆写基类的方法
		+ 结合里氏替换原则使用
* 接口分离原则
    * 将多功能的接口减少到多个更小、更具体的客户端特定接口。应该依赖接口而不是依赖实现。
    * Why
      * 如果类实现不需要的方法，调用方需要知道该类的方法实现。
        * 例如，如果类实现一个引发异常的方法，那么调用方需要知道此方法实际上不应该被调用。
	- 不应该强迫程序依赖它们不需要使用的方法
		+ 一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中
		+ 客户端不应该依赖它不需要的接口
		+ 类间的依赖关系应该建立在最小的接口上
	- 最佳实践：
    	- 类不应该实现违反单一责任原则的方法。
		+ 一个接口只服务与一个子模块和业务逻辑
		+ 通过业务逻辑压缩接口中的pulic方法
		+ 已经被污染了的接口，尽量去修改，若变更的风险很大，则采用适配器模式去转化处理
* 迪米特原则(最少知识原则)
	- 一个对象应当对其他对象尽可能少的了解
		+ 降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用
	- 最佳实践：
		+ 是否可以减少public方法和属性，修改未private、package-private、protected等访问权限，是否可以加上final关键字等
		+ 如果一个方法在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置再本类中
		+ 对象的方法只能调用以下方法：
    		+ 对象本身。
    		+ 该方法的参数。
    		+ 在方法中创建的任何对象。
    		+ 对象的任何直接属性/字段。
* KISS (Keep It Simple Stupid)
  * 如果保持简单而不是复杂，大多数系统都能发挥最佳性能。
  * Why
    * 更少的代码花费更少的时间来编写，具有更少的错误，并且更容易修改。
    * 简单就是极致成熟。
    * 而不是没有什么可补充的代码不是完美的代码，不可精简的代码才是完美的代码，
* YAGNI (you aren't gonna need it)
  * 在必要之前不要实施。不要做过度设计和实现。
  * Why
    * 任何仅用于明天需要的功能的工作意味着从当前迭代需要完成的功能中失去工作量。
    * 这会导致代码膨胀，软件变得更大、更复杂。
  * How
    * 当你真正需要的时候总是去实现它们，而不是当你只是预见到你需要它们的时候。
* Do The Simplest Thing That Could Possibly Work
  * 使用最简单的事情解决问题
  * Why
    * 如果我们只是致力于解决真正的问题，那么对抗真正问题的进展就会最大化。
  * How
    * Ask yourself: "What is the simplest thing that could possibly work?"
* Separation of Concerns
  * 关注点分离。分离关注点是将计算机程序分离成不同的部分的设计原则。这样每个部分都解决了一个单独的关注点。
    * 例如，应用程序的业务逻辑是一个关注点，而用户界面则是另一个关注点。更改用户界面不应要求更改业务逻辑，反之亦然。
    * 即使不完全可能，它仍然是我有效排序一个人思想的唯一可用技术。“将注意力集中在某些方面”：它并不意味着忽视其他方面，它只是公正地从这个方面来看，另一方面是不相关的。
  * Why
    * 简化软件应用程序的开发和维护。
    * 当关注点被很好地分开时，单独的部分可以被重用，也可以独立地开发和更新。
  * How
    * 将程序功能分解为尽可能少重叠的单独模块。
* Keep Things DRY
  * 每一段知识都必须在系统中具有单一，明确，权威的表示。
    * 程序中的每个重要功能都应该在源代码中的一个位置实现。 在通过不同的代码片段执行类似的功能的情况下，通过抽象出变化的部分将它们组合成一个通常是有益的。
  * Why
    * 重复(无意中或有目的重复)可能导致维护噩梦、分解错误和逻辑矛盾。
    * 对系统中任何单个元素的修改不需要更改其他逻辑上无关的元素。
    * 此外，逻辑上相关的元素都可以预测和一致地进行更改，从而保持同步。
  * How
    * 只在一个地方放置业务规则，长表达式，if语句，数学公式，元数据等。
    * 确定系统中使用的每一条知识的单一，权威来源，然后使用该源生成该知识的适用实例（代码，文档，测试等）。
    * 应用[三次法则](https://zh.wikipedia.org/wiki/%E4%B8%89%E6%AC%A1%E6%B3%95%E5%88%99_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1))
* Code For The Maintainer
  * 编码时考虑可维护性
  * Why
    * 维护是任何项目中最昂贵的阶段。
  * How
    * 成为维护者。
    * 编码的时候想着最终维护你代码的人是一个暴力的精神病患者，他知道你住在哪里。
    * 注意编写代码和注释，以便一个初学者拿起你的代码乐于去学习和阅读。
    * 不要让维护者思考。
    * 应用[Principle of least astonishment（最少惊讶原则）](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)
      * If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature.
      * 如果必要的特征具有意料之外的表现，则可能需要重新设计该特征
* Avoid Premature Optimization
  * 避免过早优化，理解代码是否足够成熟是至关重要的
    * 程序员浪费了大量时间来思考或担心程序中非关键部分的速度，而这些效率尝试实际上在考虑调试和维护时会产生很大的负面影响。
    * 我们应该忘记小的效率，大约97％的场景：过早的优化是所有邪恶的根源。
    * 但是，我们不应该放弃那个关键的3％的优化机会。
  * Why
    * 事先不知道瓶颈在哪里。
    * 优化后，可能更难以阅读并因此维护。
  * How
    * 当“正确”也意味着“快”。
    * 在您需要之前不要进行优化，并且只有在分析后才发现瓶颈才能优化。
* Minimise Coupling
  * 最小化耦合
    * 模块/组件之间的耦合是它们相互依赖的程度; 较低的耦合效果更好。
  * Why
    * 一个模块的更改通常会强制其他模块中的更改产生连锁反应。
    * 由于模块间依赖性增加，模块的组装可能需要更多的努力和/或时间。
    * 特定模块可能更难以重用和/或测试，因为必须包含依赖模块。
    * 开发人员可能害怕更改代码，因为他们不确定可能会受到什么影响。
  * How
    * 消除，最小化并减少必要关系的复杂性。
    * 通过隐藏实现细节，减少了耦合。
    * 应用[迪米特法则](https://zh.wikipedia.org/wiki/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B)
* Composition Over Inheritance
  * 组合重于继承
  * Why
    * 类之间的耦合较少。
    * 使用继承，子类很容易做出假设，并破坏LSP（里氏替换原则（Liskov Substitution principle））。
  * How
    * 测试LSP（可替代性）以决定何时继承。
    * "has a" (or "uses a")使用组合, "is a" 实用继承。
* Orthogonality（正交）
  * 正交的基本思想是，在概念上不相关的事物不应在系统中相关。
  * 它与简单性相关;设计正交越多，异常越少。这使得使用编程语言学习、读取和编写程序变得更加容易。正交特征的含义与上下文无关;关键参数是对称性和一致性。
* Robustness Principle（鲁棒性原则）
  * 在你所做的事情上要保守，在你从别人那里接受的东西上要开明。
    * 传参要符合规范，在你从别人那里接受的参数时必须通过制造错误的或不可预期的输入来验证程序的健壮性。
  * Why
    * 为了能够发展服务，您需要确保提供商可以进行更改以支持新需求，同时最大限度地减少对现有客户端的破坏。
  * How
    * 将命令或数据发送到其他计算机（或同一台计算机上的其他程序）的代码应完全符合规范，但接收输入的代码应处理不符合要求的输入，只要含义明确。
* Inversion of Control（控制反转）
  * Why
    * 控制反转用于增加程序的模块性并使其可扩展。
    * 将任务的执行与实现分离。
    * 将模块专注于它的设计任务。
    * 使模块免于假设其他系统如何做他们所做的事情，而是依赖合同。
    * 更换模块时防止副作用。
  * How
    * 使用工厂模式
    * Using Service Locator pattern 使用服务定位器模式
    * 使用依赖注入
    * Using contextualized lookup 使用上下文查找
    * 使用模板方法模式
    * 使用策略模式
* Maximise Cohesion（高内聚）
  * 单个模块/组件的凝聚力是其职责构成有意义单元的程度; 更高的凝聚力更好。
  * Why
    * 模块越多理解模块的难度增加。
    * 维护系统的难度增加，因为域中的逻辑更改会影响多个模块，并一个模块中的更改需要更改相关模块。
    * 由于大多数应用程序不需要模块提供的部分操作集，因此重用模块的难度增加。
  * How
    * 相关的功能组合在一个类中。
* Hide Implementation Details（隐藏实现细节）
  * 软件模块通过提供接口来隐藏信息（即实现细节），而不泄漏任何不必要的信息。
  * Why
    * 当实现发生变化时，客户端使用的接口不必更改。
  * How
    * 最小化类和成员的可访问性。
    * 不要公开公开成员数据。
    * 避免将私有实现细节放入类的接口中。
    * 减少耦合以隐藏更多实现细节。
* Curly's Law（科里定律）
  * Curly定律是为任何特定的代码选择一个明确定义的目标：做一件事。
    * 一个变量应该代表一样东西，并且只能代表一样东西。它不应该在一种情况下代表这个意思，而在另一种情况下又代表不同的意思。它不能一次代表两样东西。它应该只有一个含义，并且自始至终只有一个含义。
* Encapsulate What Changes（封装更改）
  * 一个好的设计可识别最有可能更改的热点，并将它们封装在 API 后面。当预期更改发生时，修改将保持本地。
  * Why
    * 在发生更改时最小化所需的修改
  * How
    * 封装API背后不同的概念
    * 可能将不同的概念分成它自己的模块
* Boy-Scout Rule（童子军原则）
  * 童子军有一条规则：“让营地比你刚来时更干净。”如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。事实上，这条规则的最初说法是“让世界比你刚来时更美好”，出自罗伯特·贝登堡，童子军之父。尝试让模块在提交时比你检出时更干净。
  * Why
    * 在对现有代码库进行更改时，代码质量往往会降低，从而累积技术债务。 按照boyscout规则，我们应该考虑每次提交的质量。 技术债务受到连续重构的抵制，无论多么小。
  * How
    * 每次提交都要确保它不会降低代码库质量。
    * 每当有人看到一些不太清晰的代码时，他们应该抓住机会在那里修复它。
* Command Query Separation（命令查询分离）
  * 命令查询分离原则指出，每种方法应是执行操作的命令，或者是将数据返回给调用方而不是两者行的调用。提出问题不应修改答案。应用这一原理后，程序员可以更有信心地编写代码。查询方法可以按任意顺序在任何地方使用，因为它们不会更改状态。使用命令时，必须更加小心。
  * Why
    * 通过将方法明确地分离为查询和命令，程序员可以在不知道每个方法的实现细节的情况下进行编码。
  * How
    * 将每个方法实现为查询或命令
    * 将命名约定应用于方法名称，该方法名称暗示该方法是查询还是命令

### 设计原则（Head first设计模式）

* 找出程序中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起
* 针对接口编程，而不是针实现编程
* 多用组合，少用继承
* 为了交互对象之前的松耦合设计而努力
	- 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低
* 类应该对扩展开放，对修改关闭
* 要依赖抽象，不要依赖具体类（依赖倒置原则）
	- 变量不可以持有具体类的引用
	- 不要让类派生自具体类
	- 不要覆盖基类中已实现的方法
* 最少知识原则（墨忒耳法则）
	- 减少对象之间的交互（减少对象之间耦合）
	- 只调用以下范围的方法
		+ 该对象本身
		+ 被当做方法的参数而传递进来的对象
		+ 此方法所创建或实例化的任何对象
		+ 对象的任何组件（被实例变量的引用）
	- 会增加封装用于和其他对象交互，复杂度和开发时间上升，并降低了运行时性能
* 好莱坞原则
	- 高层组件对低层组件的依赖方式是：别调用我们，我们会调用你
* 一个类应该只有一个引起变化的原因，尽量让每个类保持单一职责
	- 当一个模块或一个类被设计成只支持一组相关的功能时，我们说他具有高内聚，反之，当被设计成支持一组不相关的功能时，我说他具有低内聚

### 复用机制

* 继承
	- 白箱复用
	- 破坏了封装性
	- 父类子类依赖紧密，父类改变会影响子类
* 对象组合
	- 黑箱复用
	- 不破坏封装性
	- 依赖接口而解耦
	- 有助于保持每个类被封装，并集中在单个任务上
	- 动态的参数化的软件比静态的软件难于理解
	- 运行时效率低（主要）
	- 委托是对象组合的特例

**优先使用对象组合，而不是类继承**

## 设计模式总览

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。  
模式是在某情境下，针对某问题的某种解决方案

### 设计模式分类

* 创建型模式(对象的创建)(5个)
	- 简单工厂模式（静态工厂方法模式）(Simple Factory)
		+ 简单工厂模式不是GoF总结出来的23种设计模式之一
	- 工厂方法模式(Factory Method)
		+ 注重整体对象的创建方法
	- 抽象工厂模式(Abstract Factory)
		+ 创建具有不同分类的产品组合
	- 建造者模式(Builder)
		+ 旨在一步步的精确构造出一个复杂对象
	- 原型模式(Prototype)
	- 单例模式(Singleton)
* 结构型模式(处理类或对象的组合)(7个)
	- 外观模式(Facade)
		+ 封装和隔离内部业务
	- 适配器模式(Adatper)
		+ 不同对象之间相互转换
	- 代理模式(Proxy)
		+ 对代理对象具有控制权
	- 装饰模式(Decorator)
		+ 对类功能的增强或减弱
	- 桥接模式(Bridge)
		+ 解耦抽象与实现
		+ 两个维度的排列组合问题
	- 组合模式(Composite)
		+ 屏蔽部分与整体间的差别
	- 享元模式(Flyweight)
	- Abstract Document
* 行为型模式(类或对象的交互和职责分配)(11个)
	- 模版方法模式(Template Method)
	- 观察者模式(Observer)
	- 状态模式(State)
		+ 封装状态变化，暴漏行为
	- 职责链模式(Chain of Responsibility)
	- 命令模式(Command)
		+ 使用命令将调用者和执行者解耦
	- 访问者模式(Visitor)
	- 策略模式(Strategy)
		+ 封装算法，实现算法自由替换
	- 备忘录模式(Memento)
	- 迭代器模式(Iterator)
	- 解释器模式(Interpreter)
	- 中介者模式(Mediator)
		+ 协调同事类之间关系
* Architectural
  * Api Gateway
  * Aggregator Microservices
  * CQRS
  * Data Bus
  * Data Transfer Object
  * Event Driven Architecture
  * Event Sourcing
  * Hexagonal Architecture
  * Layers
  * Naked Objects
  * Partial Response
  * Serverless
  * Service Layer
  * Unit Of Work

|          | 创建型   | 结构性         | 行为型   |
| -------- | -------- | -------------- | -------- |
| 用于类   | 工厂方法 | 适配器 （类）  | 解释器   |
|          |          |                | 模板方法 |
| 用于对象 | 抽象工厂 | 适配器（对象） | 责任链   |
|          | 创建者   | 桥接           | 命令     |
|          | 原型     | 组合           | 迭代器   |
|          | 单例     | 装饰           | 中介者   |
|          |          | 外观           | 备忘录   |
|          |          | 享元           | 观察者   |
|          |          | 代理           | 状态     |
|          |          |                | 策略     |
|          |          |                | 访问者   |

* 类模式用户处理类和子类之间的关系，这些关系通过继承建立，是静态的，编译时就确定下来了
* 对象模式处理对象之间的关系，这些关系具有动态性，运行时可变化

![relation](/static/img/Pattern/relation.jpg "relation")

### 如何选用设计模式

1. 考虑设计模式是怎样解决问题的
2. 浏览模式的意图部分
3. 研究模式怎样互相关联
4. 研究目的相似的模式
5. 检查重新设计的原因
6. 考虑设计中哪些是可以改变的

| 目的 | 设计模式                | 可变的方面                                               |
| ---- | ----------------------- | -------------------------------------------------------- |
| 创建 | Abstract Factory        | 产品对象家族                                             |
|      | Builder                 | 创建一个组合对象                                         |
|      | Factory Method          | 被实例化的子类                                           |
|      | Prototype               | 被实例化的类                                             |
|      | Singleton               | 一个类的唯一实例                                         |
| 结构 | Adapter                 | 对象的接口                                               |
|      | Bridge                  | 对象的实现                                               |
|      | Composite               | 一个对象的结构和组成                                     |
|      | Decorator               | 一个对象的职责，不生成子类                               |
|      | Facade                  | 一个子系统的接口                                         |
|      | Flyweight               | 对象的存储开销                                           |
|      | Proxy                   | 如何访问一个对象；对象的位置                             |
| 行为 | Chain of Responsibility | 满足一个请求的对象                                       |
|      | Command                 | 何时、怎样满足一个请求                                   |
|      | Interpreter             | 一个语言的问法及解释                                     |
|      | Iterator                | 如何编译、访问一个聚合的各元素                           |
|      | Mediator                | 对象间怎样交互、和谁交互                                 |
|      | Memento                 | 一个对象中那些私有信息存放在对象之外，什么时候存储       |
|      | Observer                | 多个多想依赖于另外一个对象，而这些对象又如何保持一致     |
|      | State                   | 对象的状态                                               |
|      | Strategy                | 算法                                                     |
|      | Template Method         | 算法中的某些步骤                                         |
|      | Visitor                 | 某些可作用于一个（组）对象上的操作，但不修改这些对象的类 |

### 如何使用设计模式

1. 大致浏览一遍模式
2. 回头去研究结构部分、参与者部分和写作部分
3. 看代码示例部分、看看这个模式代码形式的具体例子
4. 选择模式参与者的名字，使他们自应用上下文中有意义
5. 定义类
6. 定义模式中专用于应用的操作名称
7. 实现执行模式中责任和写作的操作

## 设计模式分类

### 简单工厂模式（静态工厂方法模式）

所有工厂模式都用来封装对象的创建

简单工厂模式又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责

* 缺点
	- 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护

```java
public class AnimalFactory {

	private AnimalFactory() {
	}

	// public static Dog createDog() {
	// return new Dog();
	// }
	//
	// public static Cat createCat() {
	// return new Cat();
	// }

	public static Animal createAnimal(String type) {
		if ("dog".equals(type)) {
			return new Dog();
		} else if ("cat".equals(type)) {
			return new Cat();
		} else {
			return null;
		}
	}
}

```

### 工厂方法模式

工厂方法模式定义了创建对象的接口，但由子类决定要实例化的是哪一个，工厂方法让类把实例化推迟到子类

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性

* 缺点
	- 需要额外的编写代码，增加了工作量

```java
public abstract class AbstractFactory {
    public abstract <T extends Product> T createProduct(Class<T> clazz);
}

public class ConcreteFactory extends AbstractFactory {
    @Override
    public <T extends Product> T createProduct(Class<T> clazz) {
        try {
            return (T) Class.forName(clazz.getName()).newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
}

public abstract class Product {
    public void method1() {
        System.out.println("method1");
    }
    public abstract void method2();
}

public class ConcreteProduct1 extends Product {
    @Override
    public void method2() {
        System.out.println("method2");
    }
}
```

```java
AbstractFactory abstractFactory = new ConcreteFactory();
ConcreteProduct1 product = abstractFactory.createProduct(ConcreteProduct1.class);
product.method1();
product.method2();
```

### 抽象工厂模式

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

* 有N个产品族，在抽象工厂类中就应该有N个创建方法
* 有M个产品等级，就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务
* 产品族扩展困难，而产品等级扩展容易

```java
public interface AbstractFactory {
	public abstract Product createProductA();
	public abstract Product createProductB();
}
```

```java
public interface Product {
	public abstract void method();
}
```

```java
public class Product1Factory implements AbstractFactory {
	@Override
	public Product createProductA() {
		return new ConcreteProduct1();
	}
	@Override
	public Product createProductB() {
		return new ConcreteProduct2();
	}
}
```

```java
public class Product2Factory implements AbstractFactory {
	@Override
	public Product createProductA() {
		return new ConcreteProduct3();
	}
	@Override
	public Product createProductB() {
		return new ConcreteProduct4();
	}
}
```

```java
AbstractFactory f = new ConcreteProduct1Factory();
Product a = f.createProductA();
a.method();

f = new ConcreteProduct2Factory();
a = f.createProductB();
a.method();
```

### 工厂方法模式和抽象工厂模式

* 工厂方法模式通过子类创建对象，抽象工厂通过实现类（对象组合）创建对象
* 抽象工厂的方法常以工厂方法模式实现
* 抽象工厂和工厂方法用于实例化具体类的解耦
* 抽象工厂用于创建产品家族和想让制造的相关产品集合起来

> 所有的工厂模式都是用来封装对象的创建  
> 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦  
> 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象  
> 抽象工厂使用组合：对象的创建被实现在工厂接口所暴漏出来的方法中  
> 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合  
> 工厂方法允许类将实例化延迟早子类进行  
> 抽象工厂创建相关的对象家族，而不需要依赖他们的具体类  
> 依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象  
> 工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体编程  

### 创建者模式(生成器模式)

创建者模式封装一个产品的构造过程，并允许按步骤构造  
将一个复杂对象的创建与他的表示分离，使得同样的构建过程可以创建不同的表示

* 优点：
	- 将一个复杂对象的创建过程封装起来
	- 允许通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）
	- 向客户隐藏产品内部的实现
	- 产品的实现可以被替换，因为客户只看到一个抽象的接口
* 缺点：
	- 采用创建者模式创建对象的客户，需要具备更多的领域知识

```java
public interface CarBuilder {
    CarBuilder buildWheel();
    CarBuilder buildEngine();
    CarBuilder buildSeats(int number);
    CarBuilder buildContainer();
    Car getCar();
}
```

```java
public class Car {
    List<String> config = new ArrayList<>();
    public void addConfig(String config) {
        this.config.add(config);
    }
    @Override
    public String toString() {
        return config.stream().reduce("", (x, y) -> x.concat(y).concat("\r\n"));
    }
}

```

```java
public class TrunkBuilder implements CarBuilder {
    private Car car = new Car();
    @Override
    public CarBuilder buildWheel() {
        car.addConfig("car has a big wheel");
        return this;
    }
    @Override
    public CarBuilder buildEngine() {
        car.addConfig("car has a little engine");
        return this;
    }
    @Override
    public CarBuilder buildSeats(int number) {
        car.addConfig(MessageFormat.format("car has a {0} seats", number));
        return this;
    }
    @Override
    public CarBuilder buildContainer() {
        car.addConfig("car has a big containers");
        return this;
    }
    @Override
    public Car getCar() {
        return car;
    }
}

```

```java
Car car = new TrunkBuilder().buildContainer()
        .buildEngine()
        .buildSeats(3)
        .buildWheel()
        .getCar();
System.out.println(car);
car = new TrunkBuilder()
        .buildEngine()
        .buildWheel()
        .getCar();
System.out.println(car);
```

### 原型模式

在创建给定类的实例的过程很昂贵或复杂时，使用原型模式  
原型模式常用来代替抽象工厂  

* 用途：
	- 在一个复杂的类层次中，当系统不惜从其中的许多类型创建新对象时，可以考虑原型
* 优点：
	- 向客户隐藏制造新实例的复杂性
	- 提供让客户能够产生位置类型对象的选项
	- 在某些环境下，复制对象比创建新对象更有效
	- 性能优良
* 缺点：
	- 对象复制有时相当复杂
	- 逃避了构造函数的约束（也可做优点）
* 注意事项：
	- 构造函数不会被执行
	- 深拷贝和浅拷贝问题
	- clone和final冲突（手动拷贝时无法赋值，下面的方式无视）

```java
public interface Prototype {
    Object clone();
}
```

```java
public class ConcretePrototype implements Prototype, Cloneable, Serializable {
    private static final long serialVersionUID = 7231405363797237036L;
    @Override
    public Object clone() {
    	    // 使用json序列化
    	    // Gson gson = new Gson();
    	    // return gson.fromJson(gson.toJson(this), this.getClass());

    	    // 使用流
        try (
                //将对象写到流里
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                ObjectOutputStream oos = new ObjectOutputStream(bos);
        ) {
            oos.writeObject(this);
            try (//从流里读回来
                 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
                 ObjectInputStream ois = new ObjectInputStream(bis);
             ) {
                return ois.readObject();
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

```java
public class PrototypeManager {
	// Singleton implements
    private Map<String, Prototype> prototypeMap = new HashMap<>();
    public void addPrototype(String name, Prototype prototype) {
        prototypeMap.put(name, prototype);
    }
    public void removePrototype(String name) {
        prototypeMap.remove(name);
    }
    public Prototype getPrototype(String name) {
        return (Prototype) prototypeMap.get(name).clone();
    }
}

```

```java
public class Client {
    public static void main(String[] args) {
        PrototypeManager prototypeManager = new PrototypeManager();
        prototypeManager.addPrototype("first",new ConcretePrototype());
        Prototype first = prototypeManager.getPrototype("first");
    }
}
```

### 单例模式

确保一个类只有一个实例，并提供一个全局访问点  
单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。

* 优点
	- 在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
	- 可以延迟实例化0
* 缺点
	- 没有抽象层，因此扩展很难。
	- 职责过重，在一定程序上违背了单一职责

> 单例模式确保程序中一个类最多只有一个实例  
> 单例模式也提供访问这个实例的全局点  
> 在Java中实现单例模式需要私有的狗仔器、一个静态方法和一个静态变量  
> 确定在性能和资源上的限制，然后小心的选择适当的方案来实现单例，以解决多线程的问题（我们必须认定所有的程序都是多线程）  
> 如果不采用第五版以后的Java2，双重检查加锁的实现会失效  
> 小心，如果你使用多个类加载器，可能导致单例失效而产生多个实例  
> 如果使用JVM1.2或之前的版本，你必须建立单例注册表，以免垃圾回收器将单例回收  

#### 设计思想

保证类在内存中只有一个对象

**如何实现类在内存中只有一个对象呢?**

* 构造私有
* 本身提供一个对象
* 通过公共的方法让外界访问

#### 饿汉式(开发)

```java
public class Singleton {
	// 构造私有
	private Singleton() {
	}

	// 自己造一个
	// 静态方法只能访问静态成员变量，加静态
	// 为了不让外界直接访问修改这个值，加private
	private static Singleton s = new Singleton();

	// 提供公共的访问方式
	// 为了保证外界能够直接使用该方法，加静态
	public static Singleton getSingleton() {
		return s;
	}
}
```

#### 懒汉式

线程安全问题

懒加载思想(延迟加载)

```java
public class Singleton {
	private Singleton() {
	}
	// 使用volatile禁止指令重排
	private volatile static Singleton t = null;
	// 锁范围较大，如果可以接受重复初始化，可以不加锁，如基本类型的延迟加载
	public synchronized static Singleton getSingleton() {
		Singleton result = t;// 局部变量保证在t被初始化的情况下读取一次，可以提高性能
		if (result == null) {// 这里有线程安全问题 所以要加锁
			t = result = new Singleton();
		}
		return result;
	}
	// 缩小锁范围，但是要做双重检查 jdk 1.5以后有效
	public static Singleton getSingleton() {
		Singleton result = t;// 局部变量保证在t被初始化的情况下读取一次，可以提高性能
		if (result == null) {
			synchronized(Singleton.class){
				result = t;
				if (result == null) {// 双重检查
					t = result = new Singleton();
				}
			}
		}
		return result;
	}
}
```

#### 内部类方式（static holder）

既支持了延迟加载，也是线程安全的，较完美的解决方案

> **多线程缺省同步锁的知识：**
> 解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制，但是在某些情况下，JVM已经隐含的为您执行了同步，不用自己再来进行同步控制。  
> 
> 1. 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时  
> 2. 访问final字段时  
> 3. 在创建线程之前创建对象时  
> 4. 线程可以看见它将要处理的对象时  

> 要想很简单的实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是会浪费一定的时间空间？因为这种实现方式，会在类装载的时候就初始化对象。

> 一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同步实现延迟加载和线程安全。

```java
public class Singleton {
    private static class StaticHolder {
        private static Singleton instance;
        static {
            instance = new Singleton();
        }
    }
    private Singleton(){
    }
    public static Singleton getInstance() {
        return StaticHolder.instance;
    }
}
```

#### 枚举式（推荐）

好处

1. 线程安全（枚举底层是线程安全的）
2. 不会因为序列化而产生新的实例（因为它自己实现了readResolve方法）
3. 防止反射攻击。（因为enum实际上是abstract的）

```java
// 普通单例需要使用transient和readResolve方法保证反序列化后使用一个实例
private static final transient Singleton INSTANCE = new Singleton();
private Object readResolve() throws ObjectStreamException {
   // instead of the object we're on,
   // return the class variable INSTANCE
  return INSTANCE;
}
```

```java
// 枚举实现
public enum Singleton {
    INSTANCE;
    Singleton() {
    }
    public void operate() {
    }
}
```

#### 类加载器和jdk1.2垃圾回收问题

*多个类加载器会在各自的命名空间下加载同一个类，造成存在一个类的多一个实例*

解决：指定同一个类加载器加载

*JDK1.2之前会将单例模式认为是没有引用而回收，再次getInstance()又创建一个对象*

解决：建立单例注册表...使用全局引用指向单例？

### 外观模式（门面模式）

提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用  
外观不只是简化接口，也将客户端从组件的子系统中解耦  

* 使用场景：
	- 为一个复杂的模块或子系统提供一个供外界访问的接口
	- 子系统相对独立，外界黑箱操作
* 优点：
	- 减少系统的相互依赖
	- 提高了灵活性
	- 提高安全性
* 缺点：
	- 违反开闭原则，有问题要修改门面类
* 最佳实践：
	- 门面十分庞大或子系统可以提供不同的访问路径时，使用多个门面
	- 门面不应参与业务，如果需要就多封装一层，防止子系统业务对门面的依赖

```java
public class ProgramFacade {
    private Designer designer;
    private Programmer programmer;
    private Tester tester;
    private Operator operator;
    public ProgramFacade(Designer designer, Programmer programmer, Tester tester, Operator operator) {
        this.designer = designer;
        this.programmer = programmer;
        this.tester = tester;
        this.operator = operator;
    }
    public void buildProgram(Program program){
        // 这里最好再封装一层，防止依赖倒置
        designer.design(program);
        programmer.program(program);
        tester.test(program);
        operator.operate(program);
    }
    public void shutdownProgram(Program program){
        operator.shutdown(program);
    }
}

```

### 适配器模式

将一个类的接口转换成另外一个客户希望的接口。从而使原来不能直接调用的接口变的可以调用。  
适配器有两种形式：对象适配器和类适配器，对象适配器使用组合，类适配器需要多继承  

* 优点
	- 让本来不适合使用的接口变得适合使用
* 缺点
	- 一次只能适配一个类，使用有一定的局限性

*接口实现类适配*

```java
/*
 * 针对用户操作的四种功能接口
 */
public interface UserDao {
	public abstract void add();
	public abstract void delete();
	public abstract void update();
	public abstract void find();
}
```

```java
//适配器类
public abstract class UserAdapter implements UserDao {
	@Override
	public void add() {
	}
	@Override
	public void delete() {
	}
	@Override
	public void update() {
	}
	@Override
	public void find() {
	}
}
```

```java
// 适配器模式实现类
public class UserDaoImpl2 extends UserAdapter {
	@Override
	public void add() {
		System.out.println("添加功能");
	}
}
```

*不同接口转换适配*

```java
public class EnumerationIteratorAdaptor implements Iterator {
    private Enumeration enumeration;
    public EnumerationIteratorAdaptor(Enumeration enumeration) {
        this.enumeration = enumeration;
    }
    public boolean hasNext() {
        return enumeration.hasMoreElements();
    }
    public Object next() {
        return enumeration.nextElement();
    }
    public void remove() {
        throw new UnsupportedOperationException("adapter not implement method");
    }
}
```

### 适配器模式和外观模式

外观和适配器可以包装许多类，但是外观的意图是简化接口，而是配置的意图是将接口转换成不同接口

> 当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器  
> 当需要简化并统一一个很大的接口或者一群复杂的接口是，使用外观  
> 适配器改变接口以符合客户的期望  
> 外观将客户从一个复杂的子系统中解耦  
> 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定  
> 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行  
> 适配器模式有两种形式：对象适配器和类适配器，类适配器需要用到多重继承  
> 你可以为一个子系统实现一个以上的外观  
> 适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以新增行为和责任；而外观将一群对象包装起来以简化其接口  

### 代理模式（委托模式）

代理模式为另一个对象提供一个替身或占位符以控制这个对象的访问  
使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象

**分类**

* 远程代理
	- Java的RMI调用
* 虚拟代理（必要时创建被代理对象）
	- 懒加载
* 保护代理
	- 决定对象访问
* 防火墙代理
	- 防火墙系统
* 智能引用代理
* 缓存代理
	- Web服务器代理
* 同步代理
	- JavaSpaces
* 复杂隐藏代理
* 写入时复制代理
	- CopyOnWriteArrayList
* 动态代理
	- java.util.reflect包提供Proxy类实现接口代理
	- cglib的继承代理

> 代理模式为另一个对象提供代表，以遍控制对对象的访问，管理访问的形式有许多种  
> 远程代理管理客户和远程对象之间的交互  
> 虚拟代理控制访问实例化开销大的对象  
> 保护代理基于调用者控制对对象方法的访问  
> 代理模式有许多变体，如：缓存代理、同步代理、防火墙代理和写入时复制代理  
> 代理在结构上类似装饰者，但是目的不同：装饰者模式为对象加上行为，而代理是控制访问  
> Java内置支持代理，可以根据需要建立动态代理，并将所有调用分配到所选处理器  
> 就和其他的包装着（wrapper）一样，代理会造成你的设计中类的数目增加  

```java
// 虚拟代理（此实例可以使用状态模式改写）
public class ImageProxy implements Icon {
    private ImageIcon imageIcon;
    @Override
    public void paintIcon(Component c, Graphics g, int x, int y) {
        if (imageIcon == null) {
            imageIcon.paintIcon(c, g, x, y);
        } else {
            g.drawString("loading....", x, y);
            //imageIcon=.......load image code
        }
    }
    @Override
    public int getIconWidth() {
        if (imageIcon == null) {
            return 800;
        } else {
            return imageIcon.getIconWidth();
        }
    }
    @Override
    public int getIconHeight() {
        if (imageIcon == null) {
            return 800;
        } else {
            return imageIcon.getIconHeight();
        }
    }
}
```

**动态代理**

*参见《反射和动态代理部分》*

### 装饰者模式

动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的方案  
装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案  

* 优点
	- 使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能
* 缺点
	- 正因为可以随意组合，所以就可能出现一些不合理的逻辑
	- 多层装饰的复杂性

> 继承属于扩展形式之一，单不见得是达到弹性设计的最佳方式  
> 在我们的设计中，应该允许行为被拓展，而无需修改现有的代码  
> 组合和委托可用于在运行时动态的加上行为  
> 除了继承，装饰者模式也可以让我们扩展行为  
> 装饰者模式意味着一群装饰者类，这些类用来包装具体组件  
> 装饰者类反映出被装饰者的组件类型（事实上，他们拥有相同的类型，都经过接口或继承实现）  
> 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者整个替代掉，而达到特定的目的  
> 你可以用无数个装饰者包装一个组件  
> 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型  
> 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂  

```java
public interface Phone {
	public abstract void call();
}
```

```java
public class IPhone implements Phone {
	@Override
	public void call() {
		System.out.println("手机可以打电话了");
	}
}
```

```java
// 装饰抽象类
public abstract class PhoneDecorate implements Phone {
	private Phone p;
	public PhoneDecorate(Phone p) {
		this.p = p;
	}
	@Override
	public void call() {
		this.p.call();
	}
}
```

```java
public class MusicPhoneDecorate extends PhoneDecorate {
	public MusicPhoneDecorate(Phone p) {
		super(p);
	}
	@Override
	public void call() {
		super.call();
		System.out.println("手机可以听音乐");
	}
}
```

```java
public class RingPhoneDecorate extends PhoneDecorate {
	public RingPhoneDecorate(Phone p) {
		super(p);
	}
	@Override
	public void call() {
		System.out.println("手机可以听彩铃");
		super.call();
	}
}
```

```java
Phone p = new IPhone();
p.call();
System.out.println("------------");

// 需求：我想在接电话前，听彩铃
PhoneDecorate pd = new RingPhoneDecorate(p);
pd.call();// 听彩铃打电话

// 需求：我想在接电话后，听音乐
pd = new MusicPhoneDecorate(p);
pd.call();// 打电话听音乐

// 需求：我要想手机在接前听彩铃，接后听音乐
// 自己提供装饰类，在打电话前听彩铃，打电话后听音乐或者嵌套使用装饰类
pd = new RingPhoneDecorate(new MusicPhoneDecorate(p));
pd.call();// 同时听彩铃打电话听音乐
```

```java
// Jdk中的装饰模式
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Scanner sc = new Scanner(System.in);
```

### 桥接模式（桥梁模式）

使用聚合代替继承，解决两个维度排列组合问题  
使用桥接模式，不止改变你的实现，也改变你的抽象，将抽象的部分与它的实现部分分离，使它们都可以独立的变化。

* 用途
	- 类的抽象及他的实现都可以通过生成子类的方法加以扩充
	- 当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用
	- 不希望或不适用使用继承的场景
	- 重用性要求较高的场景
* 好处：
	- 将实现予以解耦
	- 抽象和实现可以独立扩展，不会影响到对方
	- 对于“具体的抽象类”所做的改变，不会影响到客户
* 缺点：
	- 增加了复杂度

![bridge.png](/static/img/Pattern/bridge.png "bridge.png")

```java
public abstract class Abstraction {
    Bridge bridge;
    public Abstraction(Bridge bridge) {
        this.bridge = bridge;
    }
    void operation() {
        bridge.operate();
    }
}
```

```java
public interface Bridge {
    void operate();
}
```

```java
public class BridgeImpl implements Bridge {
    @Override
    public void operate() {
        System.out.println("operate");
    }
}
```

```java
public class AnotherBridgeImpl implements Bridge {
    @Override
    public void operate() {
        System.out.println("another operate");
    }
}
```

```java
public class RefineAbstraction extends Abstraction {
    public RefineAbstraction(Bridge bridge) {
        super(bridge);
    }
    public void run() {
        System.out.println("run");
    }
}

```

### 组合模式（部分-整体模式）

组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象及对象组合  
组合模式让我们能使用树形方式创建对象的结构，树里面包含了组合以及个别的对象。  
使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别  
与依赖倒置原则冲突，直接使用了实现类，限制了接口的影响范围

*组合包含组件，组件包含两种：组合和叶子节点元素*

> 组合模式提供一个机构，可同时包容个别对象和组合对象  
> 组合模式允许客户对个别对象以及组合对象一视同仁  
> 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶子节点  
> 在实现组合模式时，有许多设计上的折衷，要根据需要平衡透明性和安全性  

**透明模式和安全模式**

透明模式：叶子节点和分支节点有相同的结构，通过判断getChildren()判断（基本遵循了依赖倒置原则）
安全模式：叶子节点和分支节点不相同的结构

组合模式常和迭代器模式和访问者模式一起使用

#### 组合模式和迭代器模式组合使用

```java
// 组合接口
public interface Composite /*extends Iterable*/{
    // 添加组件
    void add(Composite composite);
    // 删除组件
    void remove(Composite composite);
    // 返回组件的遍历
    Iterator<Composite> iterator();
}
```

```java
// 日程组合
public class Schedule implements Composite {
    private String name;
    public Schedule(String name) {
        this.name = name;
    }
    // 组件
    private ArrayList<Composite> composites = new ArrayList<>();
    @Override
    public void add(Composite composite) {
        composites.add(composite);
    }
    @Override
    public void remove(Composite composite) {
        composites.remove(composite);
    }
    @Override
    public Iterator<Composite> iterator() {
        return composites.iterator();
    }
    @Override
    public String toString() {
        return "Schedule{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
// 会议组件
public class Meeting implements Composite {
    private String name;
    public Meeting(String name) {
        this.name = name;
    }
    @Override
    public void add(Composite composite) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void remove(Composite composite) {
        throw new UnsupportedOperationException();
    }
    @Override
    public Iterator<Composite> iterator() {
        return null;
    }
    @Override
    public String toString() {
        return "Meeting{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java

// 组合模式的迭代器
public class CompositeIterator implements Iterator<Composite> {
    // 用栈保存当前的未进行的迭代器
    private Stack<Iterator<Composite>> iterators = new Stack<>();
    public CompositeIterator(Iterable<Composite> composites) {
        // 将最开始的迭代器进栈
        iterators.push(composites.iterator());
    }
    @Override
    public boolean hasNext() {
        // 如果栈内没有课迭代对象，则结束
        if (iterators.size() == 0) {
            return false;
        } else {
            //查看当前迭代器是否有下一个对象
            Iterator iterator = iterators.peek();
            if (iterator.hasNext()) {// 如果有，可以调用next
                return true;
            } else {
                iterators.pop();//没有则当前迭代器出栈，递归判断下一迭代器
                return hasNext();
            }
        }
    }
    @Override
    public Composite next() {
        // hasNext时取出当前迭代器的next
        Composite next = iterators.peek().next();
        if (next.iterator() != null) {
            // 如果当前遍历对象有子，当前对象迭代器进栈，下次遍历当前对象的子
            iterators.push(next.iterator());
        }
        return next;
    }
}
```

```java
@Test
public void test() throws Exception {
    Schedule today = new Schedule("today");
    Schedule morning = new Schedule("morning");
    morning.add(new Meeting("1"));
    morning.add(new Meeting("2"));
    morning.add(new Meeting("3"));
    today.add(morning);
    Schedule afternoon = new Schedule("afternoon");
    afternoon.add(new Meeting("4"));
    afternoon.add(new Meeting("5"));
    afternoon.add(new Meeting("6"));
    today.add(afternoon);
    Schedule tomorrow = new Schedule("tomorrow");
    tomorrow.add(new Meeting("7"));
    tomorrow.add(new Meeting("8"));
    tomorrow.add(new Meeting("9"));
    Schedule noon = new Schedule("noon");
    noon.add(new Meeting("10"));
    noon.add(new Meeting("11"));
    noon.add(new Meeting("12"));
    tomorrow.add(noon);
    ArrayList<Composite> composites = new ArrayList<>();
    composites.add(today);
    composites.add(tomorrow);

    CompositeIterator compositeIterator = new CompositeIterator(composites);
    while (compositeIterator.hasNext()) {
        System.out.println(compositeIterator.next());
    }
    // Schedule{name='today'}
    // Schedule{name='morning'}
    // Meeting{name='1'}
    // Meeting{name='2'}
    // Meeting{name='3'}
    // Schedule{name='afternoon'}
    // Meeting{name='4'}
    // Meeting{name='5'}
    // Meeting{name='6'}
    // Schedule{name='tomorrow'}
    // Meeting{name='7'}
    // Meeting{name='8'}
    // Meeting{name='9'}
    // Schedule{name='noon'}
    // Meeting{name='10'}
    // Meeting{name='11'}
    // Meeting{name='12'}
}
```

#### 规格模式(Specification Pattern)

这个模式是组合模式的一个扩展

```java
public interface ISpecification<T> {
    boolean isSatisfiedBy(T candidate);
    ISpecification and(ISpecification specification);
    ISpecification or(ISpecification specification);
    ISpecification not();
}
// 父类依赖子类的场景，只有再非常明确不会变化的场景中存在，它缺乏扩展性
public abstract class CompositeSpecification<T> implements ISpecification<T> {
    @Override
    public ISpecification and(ISpecification specification) {
        return new AndSpecification(this, specification);
    }
    @Override
    public ISpecification or(ISpecification specification) {
        return new OrSpecification(this, specification);
    }
    @Override
    public ISpecification not() {
        return new NotSpecification(this);
    }
}
```

```java
public class AndSpecification<T> extends CompositeSpecification<T> {
    private ISpecification left;
    private ISpecification right;
    public AndSpecification(ISpecification left, ISpecification right) {
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean isSatisfiedBy(T candidate) {
        return left.isSatisfiedBy(candidate) && right.isSatisfiedBy(candidate);
    }
}
public class OrSpecification extends CompositeSpecification {
    private ISpecification left;
    private ISpecification right;
    public OrSpecification(ISpecification left, ISpecification right) {
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean isSatisfiedBy(Object candidate) {
        return left.isSatisfiedBy(candidate) || right.isSatisfiedBy(candidate);
    }
}
public class NotSpecification extends CompositeSpecification {
    private ISpecification specification;
    public NotSpecification(ISpecification specification) {
        this.specification = specification;
    }
    @Override
    public boolean isSatisfiedBy(Object candidate) {
        return !specification.isSatisfiedBy(candidate);
    }
}
```

```java
public class CustomSpecification extends CompositeSpecification<Integer> {
    Integer object;
    public CustomSpecification(Integer object) {
        this.object = object;
    }
    @Override
    public boolean isSatisfiedBy(Integer candidate) {
        return candidate > object;
    }
}
```

```java
// 大于15或者大于20
ISpecification<Integer> integerISpecification15 = new CustomSpecification(15);
ISpecification<Integer> integerISpecification20 = new CustomSpecification(20);
IntStream.range(0, 31)
        .filter(
                i -> integerISpecification15.or(integerISpecification20).isSatisfiedBy(i)
        )
        .forEach(System.out::println);
```

### 享元模式

如果想让某个类的一个实例能用来提供许多“虚拟实例”，就使用享元模式（有效的支持大量细粒度的对象）  
享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。  
例如IntegerCache和String字符串常量池

* 使用场景：
	- 当一个类有许多实例，而这些实例能被同一个方法控制的时候，使用享元模式
* 优点：
	- 减少运行时对象实例的个数，节省内存
	- 将许多的“虚拟”对象的状态集中管理
* 缺点：
	- 一旦你实现了它，那么单个逻辑的实例将无法拥有独立而不同的行为
* 注意事项：
	- 线程安全问题

```java
public interface Flyweight {
    // 参数state是外蕴状态
    void operate(String state);
}
```

```java
public class ConcreteFlyweight implements Flyweight {
    private Integer code = null;
    // 构造函数，内蕴状态作为参数传入
    public ConcreteFlyweight(Integer code) {
        this.code = code;
    }
    /**
     * 外蕴状态作为参数传入方法中，改变方法的行为，
     * 但是并不改变对象的内蕴状态。
     */
    @Override
    public void operate(String message) {
        System.out.println("Intrinsic State = " + this.code);
        System.out.println("Extrinsic State = " + message);
    }
}
```

```java
public class FlyweightFactory {
    private Map<Integer, Flyweight> files = new HashMap<Integer, Flyweight>();
    public Flyweight factory(Integer state) {
        //先从缓存中查找对象
        Flyweight fly = files.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            files.put(state, fly);
        }
        return fly;
    }
}
```

```java
FlyweightFactory factory = new FlyweightFactory();
Flyweight fly = factory.factory(1);
fly.operate("First Call");

fly = factory.factory(2);
fly.operate("Second Call");

fly = factory.factory(1);
fly.operate("Third Call");
// Intrinsic State = 1
// Extrinsic State = First Call
// Intrinsic State = 2
// Extrinsic State = Second Call
// Intrinsic State = 1
// Extrinsic State = Third Call
```

### 模版方法模式

模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

* 优点
	- 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，既兼顾了原则性，有不失灵活性
		+ 封装不变部分，扩展可变部分
		+ 提取公共部分代码便于维护
		+ 行为由父类控制，子类实现
* 缺点
	- 如果算法骨架有修改的话，则需要修改抽象类

> 模板方法定义了算法的步骤，把这些步骤实现延迟到子类  
> 模板方法模式为我们提供了一种代码复用的重要技巧  
> 模板方法的抽象类可以定义具体方法、抽象方法和钩子  
> 抽象方法由子类实现  
> 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它  
> 为了防止子类改变模板方法中的算法，可以将模板方法声明为final  
> 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块  
> 你将在真实世界代码中查看到模板方法模式的许多变体，不要期待他们全都是一眼可以被你认出来  
> 策略模式和模板方法模式都封装算法，一个用组合，一个用继承  
> 工厂方法是模板方法的一种特殊版本  

```java
public abstract class GetTime {
    // 需求：请给我计算出一段代码的运行时间
    // final防止子类覆盖
    public final long getTime() {
        long start = System.currentTimeMillis();
        code();
        long end = System.currentTimeMillis();
        if (isTraceMode()) {
            System.out.println("start at:" + start);
            System.out.println("end at:" + end);
        }
        return end - start;
    }
    // 必须实现，使用abstract 模版方法使用protected降低访问权限，符合迪米特法则
    protected abstract void code();
    // 可选实现，使用钩子，提供默认实现，子类选择是否覆盖父类方法
    public boolean isTraceMode() {
        return true;
    }
}
```

```java
public class ForDemo extends GetTime {
	@Override
	protected void code() {
		for (int x = 0; x < 100000; x++) {
			System.out.println(x);
		}
	}
}
```

### 观察者模式（订阅模式）

观察者模式定义了对象之间的一(Subject)对多(Observer)依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新  
JDK自带了观察者模式实现，Observable类和Observer接口，但是Observable是一个类并没有实现任何接口所以很局限  

> 观察者模式定义了对象之间的一对多关系  
> 主题（也就是观察者）用一个共同的接口来更新观察者  
> 观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现类观察者接口  
> 使用此模式时，你可以从被观察者出推（push）或拉（pull）数据，然而，推的方式被认为更正确  
> 有多个观察者时，不可以依赖特定的通知次序（取消订阅会影响顺序）  
> Java有多种观察者模式的实现，包括了通用的java.util.Observable，要注意它的一些问题(不是接口，扩展和多继承问题)，如果有必要的话，可以实现Obserable  
> Swing大量使用观察者模式，许多GUI框架也如此  
> 此模式被应用在很多地方，如JavaBeans、RMI  

* 使用场景：
	- 关联行为场景
	- 时间多级触发场景
	- 跨系统的消息交换场景，如消息队列待处理机制
* 缺点：
	- 调试复杂
	- 顺序执行的消息通知会造成效率问题，一般考虑采用异步的方式
* 注意事项：
	- 广播链最好控制在两次以内
	- 异步的线程安全和队列问题，参考消息队列

```java
// 主题
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

public class MySubject implements Subject {
    private String message;
    List<Observer> observers = new ArrayList<Observer>();
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this, this);
        }
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
}
// 观察者
public interface Observer {
    void update(Subject subject, Object args);
}

public class MyObserver implements Observer {
    public MyObserver(Subject subject) {
        subject.registerObserver(this);
    }
    public void update(Subject subject, Object args) {
        if (subject instanceof MySubject) {
            MySubject mySubject = (MySubject) args;
            System.out.println(mySubject.getMessage());
        }
    }
}
//测试
@Test
public void update() throws Exception {
    MySubject subject = new MySubject();
    MyObserver myObserver = new MyObserver(subject);
    MyObserver myObserver1 = new MyObserver(subject);
    MyObserver myObserver2 = new MyObserver(subject);
    MyObserver myObserver3 = new MyObserver(subject);
    MyObserver myObserver4 = new MyObserver(subject);
    subject.setMessage("hello");
    subject.notifyObservers();
}
```

### 状态模式

策略模式和状态模式是双胞胎  
允许对象在内部状态改变时，改变它的行为，对象看起来好像修改了它的类。

* 使用场景：
	- 行为随状态改变而改变的场景
	- 条件、分支语句的替代者
* 优点：
	- 结构清晰，避免了多重判断
	- 遵循开闭原则和单一职责原则
	- 封装性好，外部不知道因为状态改变引起行为改变
* 缺点：
	- 状态类膨胀
* 注意事项：
	- 行为受状态约束的情况下使用状态模式

> 状态模式允许一个对象基于内部状态而拥有不同的行为  
> 和程序状态机（PSM）不同，状态模式用类代表状态  
> Context会将行为委托给当前状态  
> 通过将每个状态封装进一个类，我们把以后需要做的任何更改都局部化了  
> 状态模式和策略模式有相同的类图，但是他们的意图不同  
> 策略模式通常会用行为或算法来配置Context类  
> 状态模式允许Context随着状态的改变而改变行为  
> 状态转换可以由State类或Context控制  
> 使用状态模式通常会导致类的数目大量增加  
> 状态类可以被多个Context实例共享  

```java
public interface State {
    void handle();
}
```

```java
public abstract class AbstractState implements State {
    TrafficLightContext trafficLightContext;
    private String name;
    private Double i = 1d;
    AbstractState(TrafficLightContext trafficLightContext, String name, Double i) {
        this.trafficLightContext = trafficLightContext;
        this.name = name;
        if (i != null) {
            this.i = i;
        }
    }
    @Override
    public void handle() {
        System.out.println(MessageFormat.format("{0} light", name));
        try {
            Thread.sleep(new Double(i * 1000).longValue());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class GreenState extends AbstractState {
    GreenState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "green", 1d);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getYellowState());
    }
}

public class RedState extends AbstractState {
    RedState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "red", 1d);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getGreenState());
    }
}

public class YellowState extends AbstractState {
    YellowState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "yellow", 0.5);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getRedState());
    }
}
```

```java
public class TrafficLightContext {
	// TODO:状态对象应该定义成常量
    private YellowState yellowState;
    private RedState redState;
    private GreenState greenState;
    private State state;
    TrafficLightContext() {
        this.yellowState = new YellowState(this);
        this.redState = new RedState(this);
        this.greenState = new GreenState(this);
        this.state = redState;
    }
    public void change() {
    		// 委托执行
        state.handle();
    }
    public YellowState getYellowState() {
        return yellowState;
    }
    public RedState getRedState() {
        return redState;
    }
    public GreenState getGreenState() {
        return greenState;
    }
    public void setState(State state) {
        this.state = state;
    }
}
```

```java
@Test
public void change() throws Exception {
    TrafficLightContext trafficLightContext = new TrafficLightContext();
    int i = 10;
    while (i > 0) {
        trafficLightContext.change();
        i--;
    }
}
```

### 责任链模式

当你想让一个以上的对象有你会能够处理某个请求的时候，就使用责任链模式

* 用途：
	- 经常被使用在窗口系统中，处理鼠标和键盘的事件
* 优点：
	- 将请求的发送者和接受者解耦
	- 可以简化你的对象，因为他不需要知道链的结构
	- 通过改变链内部的成员或调动它的次序，允许你动态的增加或删除责任
* 缺点：
	- 并不能保证请求一定会被执行，如果没有任何对象处理它的话，它可能落到链微端之外
	- 可能不容易观察运行时特征，有碍于除错
	- 节点过多引发的性能问题，调试也变的困难

#### 纯的与不纯的责任链模式

一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。

* 在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；
* 在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。

**纯的的责任链模式**

```java
public abstract class Handler {
    /**
     * 持有后继的责任对象
     */
    protected Handler successor;
    /**
     * 示意处理请求的方法，虽然这个示意方法是没有传入参数的
     * 但实际是可以传入参数的，根据具体需要来选择是否传递参数
     */
    public abstract void handleRequest();
    /**
     * 取值方法
     */
    public Handler getSuccessor() {
        return successor;
    }
    /**
     * 赋值方法，设置后继的责任对象
     */
    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
}
```

```java
public class ConcreteHandler extends Handler {
    /**
     * 处理方法，调用此方法处理请求
     */
    @Override
    public void handleRequest() {
        // 首先判断是否应该处理请求
        // ..
        // 然后判断是否应该放过请求

        /**
         * 判断是否有后继的责任对象
         * 如果有，就转发请求给后继的责任对象
         * 如果没有，则处理请求
         */
        if (getSuccessor() != null) {
            System.out.println("放过请求");
            getSuccessor().handleRequest();
        } else {
            System.out.println("处理请求");
        }
    }
}
```

```java
//组装责任链
Handler handler1 = new ConcreteHandler();
Handler handler2 = new ConcreteHandler();
handler1.setSuccessor(handler2);
//提交请求
handler1.handleRequest();
```

**不纯的责任链模式**

```java
public interface Filter {
    void doFilter(Request request, Response response, FilterChain filterChain);
}

public class MyFirstFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "first";
        filterChain.doFilter(request, response, filterChain);
        response.output += "first";
    }
}

public class MySecondFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "second";
        filterChain.doFilter(request, response, filterChain);
        response.output += "second";
    }
}
//过滤器链
public class FilterChain {
    private List<Filter> filters = new ArrayList<Filter>();
    Iterator<Filter> iterator;
    public FilterChain addFilter(Filter filter) {
        filters.add(filter);
        return this;
    }
    public FilterChain addFilter(FilterChain filterChain) {
        filters.addAll(filterChain.filters);
        return this;
    }
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        if (iterator == null) {
            iterator = filters.iterator();
        }
        if (iterator.hasNext()) {
            iterator.next().doFilter(request, response, filterChain);
        }
    }
}
```

### 命令模式

将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作

**适用场景**

* 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互
* 需要在不同的时间指定请求、将请求排队
* 系统需要支持命令的撤消(undo)

> 命令模式将发出请求的对象和执行请求的对象解耦  
> 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作  
> 调用者通过调用命令对象的execute()发出请求，这会使得接受者的动作被调用  
> 调用者可以接受命令当做参数，甚至在运行时动态的进行  
> 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态  
> 宏命令是命令的一种简单延伸，允许调用多个命令，宏方法也可以支持撤销  
> 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接受者  
> 命令也可以用来实现日志和事务系统  
> 命令模式可以结合责任链模式，实现命令族的解析任务
> 命令模式可以结合模版方法模式，减少命令子类的膨胀

```java
public class Light {
    public void on() {
        System.out.println("light");
    }
    public void off() {
        System.out.println("...");
    }
}

public interface Command {
    void execute();
    //void undo();通过子类实现undo方法撤销
}

public class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) {
        this.light = light;
    }
    public void execute() {
        light.on();
    }
}
public class LightOffCommand implements Command {
    private Light light;
    public LightOffCommand(Light light) {
        this.light = light;
    }
    public void execute() {
        light.off();
    }
}

public class Invoker {
    Command command;
    //Command lastCommand;
    //void undo(){lastCommond.undo();};
    public Invoker(Command command) {
        this.command = command;
    }
    void invoke() {
        command.execute();
        //lastCommand = command;
    }
    public void setCommand(Command command) {
        this.command = command;
    }
}

public class Client {
    public static void main(String[] args) {
    	    // 实现Light、Car等Reciver和Invoker之间解耦
        Light light = new Light();
        Command command = new LightOnCommand(light);
        Invoker invoker = new Invoker(command);
        invoker.invoke();
        command = new LightOffCommand(light);
        invoker.setCommand(command);
        invoker.invoke();
        Car car = new Car();
        command = new CarDriveCommand(car);
        invoker.setCommand(command);
        invoker.invoke();
    }
}
```

#### 雇工模式(仆人模式)(Servant Design Pattern)

雇工模式是命令模式的简化

```java
public interface IServiced {
    void serviced();
}
public class BreakfastServiced implements IServiced {
    @Override
    public void serviced() {
        System.out.println("breakfast serviced");
    }
}
public class DinnerServiced implements IServiced {
    @Override
    public void serviced() {
        System.out.println("dinner serviced");
    }
}
```

```java
//雇工父类
public class Servant {
    public void services(IServiced serviced) {
        //委托给serviced对象去实现
        serviced.serviced();
    }
}
```

### 访问者模式

封装一些作用于某数种数据结构中的各元素的操作，它可以再不改变数据结构的前提下定义作用于这些元素的新的操作
当你需要为一个对象的组合增加新的能力，且封装并不重要时，使用访问者模式  
访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。

* 使用场景：
	- 一个对象结构包含很多结构不同的类对象，迭代器模式无法胜任的时候（避免instanceOf检查）
	- 需要对一个对象结构中进行很多不同且不相关的操作的时候
	- 使用访问者模式避免污染类对象，封装操作
* 优点：
	- 允许你对组合结构加入新的操作，而无需改变结构本身
	- 想要加入新的操作，相对容易
	- 访问者所进行的操作，其代码时集中在一起的，符合单一职责原则，扩展性优秀
* 缺点：
	- 会打破组合类的封装，不符合迪米特法则
	- 游走的功能牵涉其中，所以对组合结构的改变就更加困难
	- 违背了依赖倒置原则

```java
public interface Visitor {
    /**
     * 对应于NodeA的访问操作
     */
    public void visit(NodeA node);
    /**
     * 对应于NodeB的访问操作
     */
    public void visit(NodeB node);
}
```

```java
public class VisitorA implements Visitor {
    /**
     * 对应于NodeA的访问操作
     */
    @Override
    public void visit(NodeA node) {
        System.out.println(node.operationA());
    }
    /**
     * 对应于NodeB的访问操作
     */
    @Override
    public void visit(NodeB node) {
        System.out.println(node.operationB());
    }
}
```

```java
public class VisitorB implements Visitor {
    /**
     * 对应于NodeA的访问操作
     */
    @Override
    public void visit(NodeA node) {
        System.out.println(node.operationA());
    }
    /**
     * 对应于NodeB的访问操作
     */
    @Override
    public void visit(NodeB node) {
        System.out.println(node.operationB());
    }
}
```

```java
public abstract class Node {
    /**
     * 接受操作
     */
    public abstract void accept(Visitor visitor);
}
```

```java
public class NodeA extends Node{
    /**
     * 接受操作
     */
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    /**
     * NodeA特有的方法
     */
    public String operationA(){
        return "NodeA";
    }
}
```

```java
public class NodeB extends Node{
    /**
     * 接受方法
     */
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    /**
     * NodeB特有的方法
     */
    public String operationB(){
        return "NodeB";
    }
}
```

```java
// 结构对象角色类，这个结构对象角色持有一个聚集，并向外界提供add()方法作为对聚集的管理操作。
// 通过调用这个方法，可以动态地增加一个新的节点。
// 虽然在这个示意性的实现里并没有出现一个复杂的具有多个树枝节点的对象树结构，
// 但是，在实际系统中访问者模式通常是用来处理复杂的对象树结构的，而且访问者模式可以用来处理跨越多个等级结构的树结构问题。
public class ObjectStructure {
    private List<Node> nodes = new ArrayList<Node>();
    /**
     * 执行方法操作
     */
    public void action(Visitor visitor){
        for(Node node : nodes) {
            node.accept(visitor);
        }
    }
    /**
     * 添加一个新元素
     */
    public void add(Node node){
        nodes.add(node);
    }
}
```

```java
ObjectStructure os = new ObjectStructure();
//给结构增加一个节点
os.add(new NodeA());
//给结构增加一个节点
os.add(new NodeB());
//创建一个访问者
Visitor visitor = new VisitorA();
os.action(visitor);
```

### 策略模式

定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户  
具体比较方法交给不同的装配策略实现，AOP中的advice也是策略模式  

* 适用场景：
	- 多个类只有算法或者行为上略有不同的场景
	- 算法需要自由切换的场景
	- 需要屏蔽算法规则的场景
* 优点：
	- 算法可以自由切换
	- 避免多重条件判断
	- 扩展性良好
* 缺点：
	- 策略类数量膨胀
	- 所有策略类都要对外暴漏，违背了迪米特法则
		+ 使用工厂方法模式、代理模式、享元模式弥补
* 注意事项：
	- 如果一个算法家族的具体策略超过四个，考虑使用复合模式防止策略类膨胀

Comparable和Comparator

```java
public class MyNumber implements Comparable<MyNumber> {
    int value;
    private Comparator<MyNumber> myNumberComparator;
    public MyNumber(Comparator<MyNumber> myNumberComparator) {
        this.myNumberComparator = myNumberComparator;
    }
    @Override
    public int compareTo(MyNumber o) {
        return myNumberComparator.compare(this, o);
    }
    public int getValue() {
        return value;
    }
    public void setValue(int value) {
        this.value = value;
    }
}
```

```java
public class MyComparator implements Comparator<MyNumber> {
    @Override
    public int compare(MyNumber o1, MyNumber o2) {
        return o1.value - o2.value;
    }
}
```

### 备忘录模式

当你让对象返回之前的状态时，使用备忘录模式  
在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态

* 目标：
	- 储存系统关键对象的重要状态
	- 维护关键对象的封装
* 优点：
	- 将被储存的状态放在外面，不要和关键对象混在一起
	- 保持关键对象的数据封装
	- 提供了容易实现的恢复能力
* 缺点：
	- 储存和恢复状态的过程可能相当耗时
	- 考虑使用序列化机制替代
* 注意事项：
	- 备忘录就近使用，建立即使用，不使用即废弃，等待垃圾回收
	- 大对象建立备忘录耗费资源
	- 不要在建立备份频繁的场景使用，无法控制备忘录建立的对象数量

* “白箱”备忘录模式
	- 备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。(Memento作为公开的外部类)
* “黑箱”备忘录模式
	- 备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口(Memento作为内部类，向外提供MementoIF接口的实现类，而不暴漏Memento具体类)

**多重检查点(白箱)**

```java
// 发起人角色
public class Originator {
    private List<String> states;
    // 检查点指数
    private int index;
    // 构造函数
    public Originator(){
        states = new ArrayList<String>();
        index = 0;
    }
    // 工厂方法，返还一个新的备忘录对象
    public Memento createMemento(){
        return new Memento(states , index);
    }
    // 将发起人恢复到备忘录对象记录的状态上
    public void restoreMemento(Memento memento){
        states = memento.getStates();
        index = memento.getIndex();
    }
    // 状态的赋值方法
    public void setState(String state){
        states.add(state);
        index++;
    }
    // 辅助方法，打印所有状态
    public void printStates(){
        for(String state : states){
            System.out.println(state);
        }
    }
}
```

```java
public class Memento {
    private List<String> states;
    private int index;
    public Memento(List<String> states , int index){
        this.states = new ArrayList<String>(states);
        this.index = index;
    }
    public List<String> getStates() {
        return states;
    }
    public int getIndex() {
        return index;
    }
}
```

```java
public class Caretaker {
    private Originator o;
    private List<Memento> mementos = new ArrayList<Memento>();
    private int current;
    public Caretaker(Originator o){
        this.o = o;
        current = 0;
    }
    // 创建一个新的检查点
    public int createMemento(){
        Memento memento = o.createMemento();
        mementos.add(memento);
        return current++;
    }
    // 将发起人恢复到某个检查点
    public void restoreMemento(int index){
        Memento memento = mementos.get(index);
        o.restoreMemento(memento);
    }
    // 将某个检查点删除
    public void removeMemento(int index){
        mementos.remove(index);
    }
}
```

```java
Originator o = new Originator();
Caretaker c = new Caretaker(o);
//改变状态
o.setState("state 0");
//建立一个检查点
c.createMemento();
//改变状态
o.setState("state 1");
//建立一个检查点
c.createMemento();
//改变状态
o.setState("state 2");
//建立一个检查点
c.createMemento();
//改变状态
o.setState("state 3");
//建立一个检查点
c.createMemento();
//打印出所有检查点
o.printStates();
System.out.println("-----------------恢复检查点-----------------");
//恢复到第二个检查点
c.restoreMemento(2);
//打印出所有检查点
o.printStates();
```

### 迭代器模式

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴漏其内部的表示  
把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所  

> 迭代器允许访问聚合的元素，而不需要暴漏它的内在结构  
> 迭代器将遍历聚合的工作封装近一个对象中  
> 当使用迭代器的时候，我们依赖聚合提供遍历  
> 迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制  
> 我们应该努力让一个类只分配一个责任  

```java
// Jdk的Iterator接口
public interface Iterator<E> {
    boolean hasNext();
    E next();
    // defalut方法不用实现
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}

```

```java
public class MyIntegerIterator implements Iterator<Integer> {
    private Integer integer;
    public MyIntegerIterator(Integer integer) {
        this.integer = integer;
    }
    public boolean hasNext() {
        return integer < Integer.MAX_VALUE;
    }
    public Integer next() {
	    //自动拆箱 return this.integer = this.integer.intValue() + 1;
        return ++integer;
    }
}
```

### 解释器模式

给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子

* 使用场景：
	- 重复发生的问题可以使用解释器模式（终结符表达式相同，非终结符表达式定制）
	- 简单语法解析，复杂使用其他替代库
* 优点：
	- 将每一个Context规则表示成一个类，方便与实现语言
	- 因为Context由许多类表示，所以你可以轻易的扩展此Context（扩展表达式）
	- 通过在类结构中加入新的方法，可以在解释的同时增加新的行为
* 缺点：
	- 当Context规则数目太大时，这个模式可能会变的非常繁杂
	- 表达式类膨胀
	- 递归导致调试困难
	- 递归和循环导致效率低下
* 注意事项：
	- 不要在重要模块中使用解释器模式，使用shell、JRuby、Groovy等脚本替代解释器模式
	- 考虑使用Expression4J、MESP（Math Expression String Parser）、Jep等开源的解析包替代

```java
public interface Expression<T> {
    T interpret(Context context);
}
public class VarExpression implements Expression<Integer> {
    private String key;
    public VarExpression(String key) {
        this.key = key;
    }
    public Integer interpret(Context context) {
        return (Integer) context.getExpression(this.key).interpret(context);
    }
}
public abstract class SymbolExpression<T> implements Expression<T> {
    protected Expression<T> left;
    protected Expression<T> right;
    //所有的解析公式都应只关心自己左右两个表达式的结果
    public SymbolExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
}
public class AddExpression implements Expression<Integer> {
    private Expression<Integer> left;
    private Expression<Integer> right;
    public AddExpression(Expression<Integer> left, Expression<Integer> right) {
        this.left = left;
        this.right = right;
    }
    @Override
    public Integer interpret(Context context) {
        return left.interpret(context) + right.interpret(context);
    }
}
public class SubExpression extends SymbolExpression {
    private Expression<Integer> left;
    private Expression<Integer> right;
    public SubExpression(Expression left, Expression right) {
        super(left, right);
        this.left = left;
        this.right = right;
    }
    @Override
    public Integer interpret(Context context) {
        return left.interpret(context) - right.interpret(context);
    }
}
```

```java
public class Context {
    private Map<String, Expression> stringExpressionMap = new HashMap<>();
    public Context() {
        stringExpressionMap.put("1", context -> (1));
        stringExpressionMap.put("2", context -> (2));
        stringExpressionMap.put("3", context -> (3));
        stringExpressionMap.put("4", context -> (4));
        stringExpressionMap.put("5", context -> (5));
        stringExpressionMap.put("6", context -> (6));
        stringExpressionMap.put("7", context -> (7));
        stringExpressionMap.put("8", context -> (8));
        stringExpressionMap.put("9", context -> (9));
        stringExpressionMap.put("0", context -> (0));
    }
    public Expression getExpression(String str) {
        return stringExpressionMap.get(str);
    }
    public void addExpression(String str, Expression expression) {
        this.stringExpressionMap.put(str, expression);
    }
}
```

```java
public class Calculator<T> {
    //定义表达式
    private Expression expression;
    //构造函数传参，并解析
    public Calculator(String expStr) {
        //定义一个栈，安排运算的先后顺序
        Stack<Expression> stack = new Stack<Expression>();
        //表达式拆分为字符数组
        char[] charArray = expStr.toCharArray();
        //运算
        Expression left = null;
        Expression right = null;
        for (int i = 0; i < charArray.length; i++) {
            switch (charArray[i]) {
                case '+': //加法
                    //加法结果放到栈中
                    left = stack.pop();
                    right = new VarExpression(String.valueOf(charArray[++i]));
                    stack.push(new AddExpression(left, right));
                    break;
                case '-':
                    left = stack.pop();
                    right = new VarExpression(String.valueOf(charArray[++i]));
                    stack.push(new SubExpression(left, right));
                    break;
                default:  //公式中的变量
                    stack.push(new VarExpression(String.valueOf(charArray[i])));
            }
        }
        //把运算结果抛出来
        this.expression = stack.pop();
    }
    //开始运算
    public T run(Context context) {
        return (T) this.expression.interpret(context);
    }
}
```

```java
System.out.println(new Calculator<Integer>("1-2+3-4-6+5+7-8+9+0").run(new Context()));
```

### 中介者模式（调停者模式）

中介者模式集中相关对象之间复杂的沟通和控制方式

* 用途：
	- 常被用于协调相关的GUI组件
* 优点：
	- 通过将对象彼此解耦（一对多依赖转换为一对一依赖），可以增加对象的复用性
	- 通过将控制逻辑集中，可以简化系统维护
	- 可以让对象之间所传递的消息变得简单且大幅减少
* 缺点：
	- 设计不当，增加复杂度，同事类越多，中介者越复杂
	- 往往与依赖倒置原则冲突，具有继承带来的侵入性
* 最佳实践：
	- N个对象之间产生了相互依赖（N>2）
	- 多个对象之间有依赖，但依赖关系尚不确定或有发生改变的可能，使用中介者模式降低风险扩散

```java
// 抽象中介者，做同事类注入（同事类拥有相同方法使用抽象类，没有使用实现类）
public abstract class Mediator {
    //定义同事类(多个)
    protected ConcreteColleague concreteColleague;
    //通过getter/setter方法把同事类注入进来
    public ConcreteColleague getConcreteColleague() {
        return concreteColleague;
    }
    public void setConcreteColleague(ConcreteColleague concreteColleague) {
        this.concreteColleague = concreteColleague;
    }
    //中介者模式的业务逻辑
    public abstract void doSomething();
}
public class ConcreteMediator extends Mediator {
	//多个特定方法调用特定同事功能
    @Override
    public void doSomething() {
        //调用同事类的方法，只要是public方法都可以调用
        super.concreteColleague.selfMethod();
    }
}
```

```java
// 抽象同事类，注入中介者
public abstract class Colleague {
    protected Mediator mediator;
    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
}

public class ConcreteColleague extends Colleague {
    private String self;
    //通过构造函数传递中介者
    public ConcreteColleague(Mediator mediator, String self) {
        super(mediator);
        this.self = self;
    }
    //自有方法 self-method
    public void selfMethod() {
        //处理自己的业务逻辑
        System.out.println("invoked self" + self);
    }
    //依赖方法 dep-method
    public void depMethod() {
        //处理自己的业务逻辑
        //自己不能处理的业务逻辑，委托给中介者处理
        super.mediator.doSomething();
    }
}
```

```java
// 中介者使用setter方法注入同事类，同事类使用构造函数注入中介者
Mediator mediator = new ConcreteMediator();
ConcreteColleague concreteColleague = new ConcreteColleague(mediator, "1");
ConcreteColleague concreteColleague1 = new ConcreteColleague(mediator, "2");
mediator.setConcreteColleague(concreteColleague);
concreteColleague1.selfMethod();
concreteColleague1.depMethod();
// invoked self2
// invoked self1
```

### API Gateway（API 网关）

#### 意图

在单个位置聚合调用微服务：API网关。 用户只需调用API网关，然后API网关就会调用每个相关的微服务。

![API Gateway](/static/img/2017-01-30-设计模式/2019-08-18-22-02-15.png)

#### 适用性

* 当使用微服务模式，并且需要为微服务调用提供单点聚合

#### 案例

* [microservices.io - API Gateway](https://www.nginx.com/blog/building-microservices-using-an-api-gateway/)
* [NGINX - Building Microservices: Using an API Gateway](https://microservices.io/patterns/apigateway.html)

```java
@RestController
public class ApiGateway {
    @Resource
    private ImageClient imageClient;
    @Resource
    private PriceClient priceClient;

    /**
     * Retrieves product information that desktop clients need
     *
     * @return Product information for clients on a desktop
     */
    @RequestMapping("/desktop")
    public DesktopProduct getProductDesktop() {
        DesktopProduct desktopProduct = new DesktopProduct();
        desktopProduct.setImagePath(imageClient.getImagePath());
        desktopProduct.setPrice(priceClient.getPrice());
        return desktopProduct;
    }

    /**
     * Retrieves product information that mobile clients need
     *
     * @return Product information for clients on a mobile device
     */
    @RequestMapping("/mobile")
    public MobileProduct getProductMobile() {
        MobileProduct mobileProduct = new MobileProduct();
        mobileProduct.setPrice(priceClient.getPrice());
        return mobileProduct;
    }
}
```

```java
/**
 * Exposes the Image microservice's endpoints
 */
@RestController
public class ImageController {

  /**
   * An endpoint for a user to retrieve an image path
   * @return An image path
   */
  @RequestMapping(value = "/image-path", method = RequestMethod.GET)
  public String getImagePath() {
    return "/product-image.png";
  }
}
```

```java
/**
 * Exposes the Price microservice's endpoints
 */
@RestController
public class PriceController {

    /**
     * An endpoint for a user to retrieve a product's price
     *
     * @return A product's price
     */
    @RequestMapping(value = "/price", method = RequestMethod.GET)
    public String getPrice() {
        return "20";
    }
}
```

### Aggregator Microservices（聚合器微服务）

#### 意图

用户对聚合器进行一次调用，然后聚合器调用每个相关的微服务并收集数据，将业务逻辑应用于它，并进一步发布作为REST端点。

聚合器的更多变化是：

* 代理微服务设计模式：根据业务需要调用不同的微服务。
* 链式微服务设计模式：在这种情况下，每个微服务依赖/链接到一系列其他微服务。

![Aggregator Microservices](/static/img/2017-01-30-设计模式/2019-08-19-08-26-32.png)

#### 适用性

当需要为各种微服务提供统一的API时，无论客户端设备如何，都可以使用聚合器微服务模式。

#### 案例

* [Microservice Design Patterns](http://blog.arungupta.me/microservice-design-patterns/)

```java
/**
 * The aggregator aggregates calls on various micro-services, collects
 * data and further publishes them under a REST endpoint.
 */
@RestController
public class Aggregator {
    @Resource
    private ProductInformationClient informationClient;
    @Resource
    private ProductInventoryClient inventoryClient;
    /**
     * Retrieves product data.
     *
     * @return a Product.
     */
    @RequestMapping("/product")
    public Product getProduct() {
        Product product = new Product();
        product.setTitle(informationClient.getProductTitle());
        product.setProductInventories(inventoryClient.getProductInventories());
        return product;
    }
}
```

```java
/**
 * Encapsulates all the data for a Product that clients will request.
 */
@Data
public class Product {
    /**
     * The title of the product.
     */
    private String title;
    /**
     * The inventories of the product.
     */
    private int productInventories;
}
```

```java
/**
 * Interface for the Information micro-service.
 */
public interface ProductInformationClient {
    String getProductTitle();
}

/**
 * An adapter to communicate with information micro-service.
 */
@Component
public class ProductInformationClientImpl implements ProductInformationClient {
    private static final Logger LOGGER = LoggerFactory.getLogger(ProductInformationClientImpl.class);
    @Override
    public String getProductTitle() {
        String response = null;
        try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
            HttpGet httpGet = new HttpGet("http://localhost:51515/information");
            try (CloseableHttpResponse httpResponse = httpClient.execute(httpGet)) {
                response = EntityUtils.toString(httpResponse.getEntity());
            }
        } catch (IOException e) {
            LOGGER.error("Exception caught.", e);
        }
        return response;
    }
}

/**
 * Interface to Inventory micro-service.
 */
public interface ProductInventoryClient {
    int getProductInventories();
}

/**
 * An adapter to communicate with inventory micro-service.
 */
@Component
public class ProductInventoryClientImpl implements ProductInventoryClient {
    private static final Logger LOGGER = LoggerFactory.getLogger(ProductInventoryClientImpl.class);
    @Override
    public int getProductInventories() {
        String response = "0";
        try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
            HttpGet httpGet = new HttpGet("http://localhost:51516/inventories");
            try (CloseableHttpResponse httpResponse = httpClient.execute(httpGet)) {
                response = EntityUtils.toString(httpResponse.getEntity());
            }
        } catch (IOException e) {
            LOGGER.error("Exception caught.", e);
        }
        return Integer.parseInt(response);
    }
}

```

```java
/**
 * Controller providing endpoints to retrieve information about products
 */
@RestController
public class InformationController {
    /**
     * Endpoint to retrieve a product's informations.
     *
     * @return product inventory.
     */
    @RequestMapping(value = "/information", method = RequestMethod.GET)
    public String getProductTitle() {
        return "The Product Title.";
    }
}
/**
 * Controller providing endpoints to retrieve product inventories
 */
@RestController
public class InventoryController {

    /**
     * Endpoint to retrieve a product's inventories.
     *
     * @return product inventory.
     */
    @RequestMapping(value = "/inventories", method = RequestMethod.GET)
    public int getProductInventories() {
        return 5;
    }
}
```

### CQRS（命令查询分离）

#### 意图

CQRS命令查询责任隔离-将查询侧与命令端分开。

![CQRS](/static/img/2017-01-30-设计模式/2019-08-19-08-35-54.png)

#### 适用性

* 想要独立地扩展查询和命令。
* 希望为查询和命令使用不同的数据模型。处理复杂域时很有用。
* 希望使用事件源或基于任务的UI等架构。

#### 案例

* [Greg Young - CQRS, Task Based UIs, Event Sourcing agh!](http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/)
* [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)
* [Oliver Wolf - CQRS for Great Good](https://www.youtube.com/watch?v=Ge53swja9Dw)

```java
/**
 * This interface represents the commands of the CQRS pattern
 */
public interface ICommandService {
    void authorCreated(String username, String name, String email);
    void bookAddedToAuthor(String title, double price, String username);
    void authorNameUpdated(String username, String name);
    void authorUsernameUpdated(String oldUsername, String newUsername);
    void authorEmailUpdated(String username, String email);
    void bookTitleUpdated(String oldTitle, String newTitle);
    void bookPriceUpdated(String title, double price);
}
/**
 * This class is an implementation of {@link ICommandService} interface. It uses Hibernate as an api for persistence.
 */
public class CommandServiceImpl implements ICommandService {
    private SessionFactory sessionFactory = HibernateUtil.getSessionFactory();
    private Author getAuthorByUsername(String username) {
        Author author = null;
        try (Session session = sessionFactory.openSession()) {
            Query query = session.createQuery("from Author where username=:username");
            query.setParameter("username", username);
            author = (Author) query.uniqueResult();
        }
        if (author == null) {
            HibernateUtil.getSessionFactory().close();
            throw new NullPointerException("Author " + username + " doesn't exist!");
        }
        return author;
    }
    private Book getBookByTitle(String title) {
        Book book = null;
        try (Session session = sessionFactory.openSession()) {
            Query query = session.createQuery("from Book where title=:title");
            query.setParameter("title", title);
            book = (Book) query.uniqueResult();
        }
        if (book == null) {
            HibernateUtil.getSessionFactory().close();
            throw new NullPointerException("Book " + title + " doesn't exist!");
        }
        return book;
    }
    @Override
    public void authorCreated(String username, String name, String email) {
        Author author = new Author(username, name, email);
        try (Session session = sessionFactory.openSession()) {
            session.beginTransaction();
            session.save(author);
            session.getTransaction().commit();
        }
    }
    @Override
    public void bookAddedToAuthor(String title, double price, String username) {
        Author author = getAuthorByUsername(username);
        Book book = new Book(title, price, author);
        try (Session session = sessionFactory.openSession()) {
            session.beginTransaction();
            session.save(book);
            session.getTransaction().commit();
        }
    }
    @Override
    public void authorNameUpdated(String username, String name) {
        Author author = getAuthorByUsername(username);
        author.setName(name);
        try (Session session = sessionFactory.openSession()) {
            session.beginTransaction();
            session.update(author);
            session.getTransaction().commit();
        }
    }
    @Override
    public void authorUsernameUpdated(String oldUsername, String newUsername) {
        Author author = getAuthorByUsername(oldUsername);
        author.setUsername(newUsername);
        try (Session session = sessionFactory.openSession()) {
            session.beginTransaction();
            session.update(author);
            session.getTransaction().commit();
        }
    }
    @Override
    public void authorEmailUpdated(String username, String email) {
        Author author = getAuthorByUsername(username);
        author.setEmail(email);
        try (Session session = sessionFactory.openSession()) {
            session.beginTransaction();
            session.update(author);
            session.getTransaction().commit();
        }
    }
    @Override
    public void bookTitleUpdated(String oldTitle, String newTitle) {
        Book book = getBookByTitle(oldTitle);
        book.setTitle(newTitle);
        try (Session session = sessionFactory.openSession()) {
            session.beginTransaction();
            session.update(book);
            session.getTransaction().commit();
        }
    }
    @Override
    public void bookPriceUpdated(String title, double price) {
        Book book = getBookByTitle(title);
        book.setPrice(price);
        try (Session session = sessionFactory.openSession()) {
            session.beginTransaction();
            session.update(book);
            session.getTransaction().commit();
        }
    }
}

/**
 * This interface represents the query methods of the CQRS pattern
 */
public interface IQueryService {
    Author getAuthorByUsername(String username);
    Book getBook(String title);
    List<Book> getAuthorBooks(String username);
    BigInteger getAuthorBooksCount(String username);
    BigInteger getAuthorsCount();
}

/**
 * This class is an implementation of {@link IQueryService}. It uses Hibernate native queries to return DTOs from the
 * database.
 *
 */
public class QueryServiceImpl implements IQueryService {
    private SessionFactory sessionFactory = HibernateUtil.getSessionFactory();
    @Override
    public Author getAuthorByUsername(String username) {
        Author authorDTo = null;
        try (Session session = sessionFactory.openSession()) {
            SQLQuery sqlQuery = session
                    .createSQLQuery("SELECT a.username as \"username\", a.name as \"name\", a.email as \"email\""
                            + "FROM Author a where a.username=:username");
            sqlQuery.setParameter(AppConstants.USER_NAME, username);
            authorDTo = (Author) sqlQuery.setResultTransformer(Transformers.aliasToBean(Author.class)).uniqueResult();
        }
        return authorDTo;
    }
    @Override
    public Book getBook(String title) {
        Book bookDTo = null;
        try (Session session = sessionFactory.openSession()) {
            SQLQuery sqlQuery = session
                    .createSQLQuery("SELECT b.title as \"title\", b.price as \"price\"" + " FROM Book b where b.title=:title");
            sqlQuery.setParameter("title", title);
            bookDTo = (Book) sqlQuery.setResultTransformer(Transformers.aliasToBean(Book.class)).uniqueResult();
        }
        return bookDTo;
    }
    @Override
    public List<Book> getAuthorBooks(String username) {
        List<Book> bookDTos = null;
        try (Session session = sessionFactory.openSession()) {
            SQLQuery sqlQuery = session.createSQLQuery("SELECT b.title as \"title\", b.price as \"price\""
                    + " FROM Author a , Book b where b.author_id = a.id and a.username=:username");
            sqlQuery.setParameter(AppConstants.USER_NAME, username);
            bookDTos = sqlQuery.setResultTransformer(Transformers.aliasToBean(Book.class)).list();
        }
        return bookDTos;
    }
    @Override
    public BigInteger getAuthorBooksCount(String username) {
        BigInteger bookcount = null;
        try (Session session = sessionFactory.openSession()) {
            SQLQuery sqlQuery = session.createSQLQuery(
                    "SELECT count(b.title)" + " FROM  Book b, Author a where b.author_id = a.id and a.username=:username");
            sqlQuery.setParameter(AppConstants.USER_NAME, username);
            bookcount = (BigInteger) sqlQuery.uniqueResult();
        }
        return bookcount;
    }
    @Override
    public BigInteger getAuthorsCount() {
        BigInteger authorcount = null;
        try (Session session = sessionFactory.openSession()) {
            SQLQuery sqlQuery = session.createSQLQuery("SELECT count(id) from Author");
            authorcount = (BigInteger) sqlQuery.uniqueResult();
        }
        return authorcount;
    }
}

```

```java
// DOMAIN MODEL
/**
 * This is an Author entity. It is used by Hibernate for persistence.
 */
@Data
@Entity
public class Author {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String username;
    private String name;
    private String email;
    /**
     *
     * @param username
     *          username of the author
     * @param name
     *          name of the author
     * @param email
     *          email of the author
     */
    public Author(String username, String name, String email) {
        this.username = username;
        this.name = name;
        this.email = email;
    }
    protected Author() {
    }
}

/**
 * This is a Book entity. It is used by Hibernate for persistence. Many books can be written by one {@link Author}
 */
@Data
@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String title;
    private double price;
    @ManyToOne
    private Author author;
    /**
     *
     * @param title
     *          title of the book
     * @param price
     *          price of the book
     * @param author
     *          author of the book
     */
    public Book(String title, double price, Author author) {
        this.title = title;
        this.price = price;
        this.author = author;
    }
    protected Book() {
    }
}

// DTO
/**
 * This is a DTO (Data Transfer Object) author, contains only useful information to be returned
 */
@Data
public class Author {
    private String name;
    private String email;
    private String username;
    /**
     *
     * @param name
     *          name of the author
     * @param email
     *          email of the author
     * @param username
     *          username of the author
     */
    public Author(String name, String email, String username) {
        this.name = name;
        this.email = email;
        this.username = username;
    }
    public Author() {
    }
}

/**
 * This is a DTO (Data Transfer Object) book, contains only useful information to be returned
 */
@Data
public class Book {
    private String title;
    private double price;
    /**
     * @param title title of the book
     * @param price price of the book
     */
    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }
    public Book() {
    }
}

```

### Data Bus（数据总线）

#### 意图

允许在应用程序的组件之间发送消息/事件，而无需彼此了解。他们只需要知道正在发送的消息/事件的类型。

![Data Bus](/static/img/2017-01-30-设计模式/2019-08-19-08-55-10.png)

#### 适用性

* 希望组件自己决定要接收哪些消息/事件
* 想要多对多的沟通
* 希望你的组件对彼此一无所知

#### 关联模式

* 中介模式，由数据总线成员自己决定是否接受任何给定的消息。
* 支持多到多通信的观察员模式
* 发布/订阅模式，数据总线将发布者和订阅者分离

#### 案例

```java
/**
 * The Data-Bus implementation.
 *
 * <p>This implementation uses a Singleton.</p>
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
public class DataBus {
    private static final DataBus INSTANCE = new DataBus();
    private final Set<Member> listeners = new HashSet<>();
    public static DataBus getInstance() {
        return INSTANCE;
    }
    /**
     * Register a member with the data-bus to start receiving events.
     *
     * @param member The member to register
     */
    public void subscribe(final Member member) {
        this.listeners.add(member);
    }
    /**
     * Deregister a member to stop receiving events.
     *
     * @param member The member to deregister
     */
    public void unsubscribe(final Member member) {
        this.listeners.remove(member);
    }
    /**
     * Publish and event to all members.
     *
     * @param event The event
     */
    public void publish(final DataType event) {
        event.setDataBus(this);
        listeners.forEach(listener -> listener.accept(event));
    }
}
```

```java
/**
 * Events are sent via the Data-Bus.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
public interface DataType {
    /**
     * Returns the data-bus the event is being sent on.
     *
     * @return The data-bus
     */
    DataBus getDataBus();
    /**
     * Set the data-bus the event will be sent on.
     *
     * @param dataBus The data-bus
     */
    void setDataBus(DataBus dataBus);
}

/**
 * Base for data to send via the Data-Bus.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
@Data
public class AbstractDataType implements DataType {
    private DataBus dataBus;
}

/**
 * An event raised when a string message is sent.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
@AllArgsConstructor
public class MessageData extends AbstractDataType {
    @Getter
    private final String message;
    public static DataType of(final String message) {
        return new MessageData(message);
    }
}

/**
 * An event raised when applications starts, containing the start time of the application.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
@AllArgsConstructor
public class StartingData extends AbstractDataType {
    @Getter
    private final LocalDateTime when;
    public static DataType of(final LocalDateTime when) {
        return new StartingData(when);
    }
}

/**
 * An event raised when applications stops, containing the stop time of the application.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
@AllArgsConstructor
public class StoppingData extends AbstractDataType {
    @Getter
    private final LocalDateTime when;
    public static DataType of(final LocalDateTime when) {
        return new StoppingData(when);
    }
}
```

```java
/**
 * Members receive events from the Data-Bus.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
public interface Member extends Consumer<DataType> {
    void accept(DataType event);
}

/**
 * Receiver of Data-Bus events that collects the messages from each {@link MessageData}.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
public class MessageCollectorMember implements Member {
    private static final Logger LOGGER = Logger.getLogger(MessageCollectorMember.class.getName());
    private final String name;
    private List<String> messages = new ArrayList<>();
    public MessageCollectorMember(String name) {
        this.name = name;
    }
    @Override
    public void accept(final DataType data) {
        if (data instanceof MessageData) {
            handleEvent((MessageData) data);
        }
    }
    private void handleEvent(MessageData data) {
        LOGGER.info(String.format("%s sees message %s", name, data.getMessage()));
        messages.add(data.getMessage());
    }
    public List<String> getMessages() {
        return Collections.unmodifiableList(messages);
    }
}

/**
 * Receiver of Data-Bus events.
 *
 * @author Paul Campbell (pcampbell@kemitix.net)
 */
public class StatusMember implements Member {
    private static final Logger LOGGER = Logger.getLogger(StatusMember.class.getName());
    private final int id;
    private LocalDateTime started;
    private LocalDateTime stopped;
    public StatusMember(int id) {
        this.id = id;
    }
    @Override
    public void accept(final DataType data) {
        if (data instanceof StartingData) {
            handleEvent((StartingData) data);
        } else if (data instanceof StoppingData) {
            handleEvent((StoppingData) data);
        }
    }
    private void handleEvent(StartingData data) {
        started = data.getWhen();
        LOGGER.info(String.format("Receiver #%d sees application started at %s", id, started));
    }
    private void handleEvent(StoppingData data) {
        stopped = data.getWhen();
        LOGGER.info(String.format("Receiver #%d sees application stopping at %s", id, stopped));
        LOGGER.info(String.format("Receiver #%d sending goodbye message", id));
        data.getDataBus().publish(MessageData.of(String.format("Goodbye cruel world from #%d!", id)));
    }
    public LocalDateTime getStarted() {
        return started;
    }
    public LocalDateTime getStopped() {
        return stopped;
    }
}
```

### Data Transfer Object（数据传输对象）

#### 意图

从客户端到服务器一次性传递具有多个属性的数据，以避免多次调用远程服务器。

![Data Transfer Object](/static/img/2017-01-30-设计模式/2019-08-19-09-08-51.png)

#### 适用性

* 客户要求提供多种信息。而且信息是相关的。
* 想提高性能以获取资源时。
* 希望减少远程调用的数量。

#### 案例

* [Design Pattern - Transfer Object Pattern](https://www.tutorialspoint.com/design_pattern/transfer_object_pattern.htm)
* [Data Transfer Object](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff649585(v=pandp.10))

```java
/**
 * The resource class which serves customer information.
 * This class act as server in the demo. Which has all customer details.
 */
public class CustomerResource {
    private List<CustomerDto> customers;
    /**
     * @param customers initialize resource with existing customers. Act as database.
     */
    public CustomerResource(List<CustomerDto> customers) {
        this.customers = customers;
    }
    /**
     * @return : all customers in list.
     */
    public List<CustomerDto> getAllCustomers() {
        return customers;
    }
    /**
     * @param customer save new customer to list.
     */
    public void save(CustomerDto customer) {
        customers.add(customer);
    }
    /**
     * @param customerId delete customer with id {@code customerId}
     */
    public void delete(String customerId) {
        customers.removeIf(customer -> customer.getId().equals(customerId));
    }
}
```

```java
/**
 * {@link CustomerDto} is a data transfer object POJO. Instead of sending individual information to client
 * We can send related information together in POJO.
 * <p>
 * Dto will not have any business logic in it.
 */
public class CustomerDto {
    private final String id;
    private final String firstName;
    private final String lastName;
    /**
     * @param id        customer id
     * @param firstName customer first name
     * @param lastName  customer last name
     */
    public CustomerDto(String id, String firstName, String lastName) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
    }
    public String getId() {
        return id;
    }
    public String getFirstName() {
        return firstName;
    }
    public String getLastName() {
        return lastName;
    }
}
```

### Event Driven Architecture（事件驱动架构）

#### 意图

使用事件驱动架构将对象的状态更改发送并通知给其他应用程序。

![Event Driven Architecture](/static/img/2017-01-30-设计模式/2019-08-19-09-13-43.png)

#### 适用性

* 想创建一个松散耦合的系统
* 想建立一个响应更快的系统
* 想要一个更容易扩展的系统

#### 案例

* SendGrid是一个电子邮件API，每当处理，传递，打开电子邮件等时都会发送事件
* Chargify是一种结算API，通过各种活动公开付款活动
* Amazon的AWS Lambda允许您执行代码以响应事件，例如Amazon S3存储桶的更改，Amazon DynamoDB表的更新或应用程序或设备生成的自定义事件。
* MySQL根据事件（如数据库表上发生的插入和更新事件）运行触发器。
* [Event-driven architecture - Wikipedia](https://en.wikipedia.org/wiki/Event-driven_architecture)
* [Fundamental Components of an Event-Driven Architecture](http://giocc.com/fundamental-components-of-an-event-driven-architecture.html)
* [Real World Applications/Event Driven Applications](https://wiki.haskell.org/Real_World_Applications/Event_Driven_Applications)
* [Event-driven architecture definition](http://searchsoa.techtarget.com/definition/event-driven-architecture)

```java
/**
 * A {@link Event} is an object with a specific type that is associated
 * to a specific {@link Handler}.
 */
public interface Event {
    /**
     * Returns the message type as a {@link Class} object. In this example the message type is
     * used to handle events by their type.
     * @return the message type as a {@link Class}.
     */
    Class<? extends Event> getType();
}

/**
 * The {@link AbstractEvent} class serves as a base class for defining custom events happening with your
 * system. In this example we have two types of events defined.
 * <ul>
 *   <li>{@link UserCreatedEvent} - used when a user is created</li>
 *   <li>{@link UserUpdatedEvent} - used when a user is updated</li>
 * </ul>
 * Events can be distinguished using the {@link #getType() getType} method.
 */
public abstract class AbstractEvent implements Event {

    /**
     * Returns the event type as a {@link Class} object
     * In this example, this method is used by the {@link EventDispatcher} to
     * dispatch events depending on their type.
     *
     * @return the AbstractEvent type as a {@link Class}.
     */
    @Override
    public Class<? extends Event> getType() {
        return getClass();
    }
}

/**
 * The {@link UserCreatedEvent} should should be dispatched whenever a user has been created.
 * This class can be extended to contain details about the user has been created. In this example,
 * the entire {@link User} object is passed on as data with the event.
 */
@AllArgsConstructor
public class UserCreatedEvent extends AbstractEvent {
    @Getter
    private User user;
}

/**
 * The {@link UserUpdatedEvent} should should be dispatched whenever a user has been updated.
 * This class can be extended to contain details about the user has been updated. In this example,
 * the entire {@link User} object is passed on as data with the event.
 */
@AllArgsConstructor
public class UserUpdatedEvent extends AbstractEvent {
    @Getter
    private User user;
}

/**
 * This {@link User} class is a basic pojo used to demonstrate user data sent along with
 * the {@link UserCreatedEvent} and {@link UserUpdatedEvent} events.
 */
@AllArgsConstructor
public class User {
    @Getter
    private String username;
}
```

```java
/**
 * Handles the routing of {@link Event} messages to associated handlers.
 * A {@link HashMap} is used to store the association between events and their respective handlers.
 */
public class EventDispatcher {
    private Map<Class<? extends Event>, Handler<? extends Event>> handlers;
    public EventDispatcher() {
        handlers = new HashMap<>();
    }
    /**
     * Links an {@link Event} to a specific {@link Handler}.
     *
     * @param eventType The {@link Event} to be registered
     * @param handler   The {@link Handler} that will be handling the {@link Event}
     */
    public <E extends Event> void registerHandler(Class<E> eventType, Handler<E> handler) {
        handlers.put(eventType, handler);
    }
    /**
     * Dispatches an {@link Event} depending on it's type.
     *
     * @param event The {@link Event} to be dispatched
     */
    @SuppressWarnings("unchecked")
    public <E extends Event> void dispatch(E event) {
        Handler<E> handler = (Handler<E>) handlers.get(event.getClass());
        if (handler != null) {
            handler.onEvent(event);
        }
    }
}
```

```java
/**
 * This interface can be implemented to handle different types of messages.
 * Every handler is responsible for a single of type message
 * @param <E> Handler can handle events of type E
 */
public interface Handler<E extends Event> {
    /**
     * The onEvent method should implement and handle behavior related to the event.
     * This can be as simple as calling another service to handle the event on publishing the event on
     * a queue to be consumed by other sub systems.
     * @param event the {@link Event} object to be handled.
     */
    void onEvent(E event);
}

/**
 * Handles the {@link UserCreatedEvent} message.
 */
public class UserCreatedEventHandler implements Handler<UserCreatedEvent> {
    private static final Logger LOGGER = LoggerFactory.getLogger(UserCreatedEventHandler.class);
    @Override
    public void onEvent(UserCreatedEvent event) {
        LOGGER.info("User '{}' has been Created!", event.getUser().getUsername());
    }
}

/**
 * Handles the {@link UserUpdatedEvent} message.
 */
public class UserUpdatedEventHandler implements Handler<UserUpdatedEvent> {
    private static final Logger LOGGER = LoggerFactory.getLogger(UserUpdatedEventHandler.class);
    @Override
    public void onEvent(UserUpdatedEvent event) {
        LOGGER.info("User '{}' has been Updated!", event.getUser().getUsername());
    }
}

```

### Event Sourcing（事件溯源）

#### 意图

不要仅仅存储域中数据的当前状态，而是使用仅附加存储来记录对该数据采取的全部操作。存储充当记录系统，并可用于转换成域对象。
这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能，可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护可以实现补偿操作的完整审计跟踪和历史记录。

![Event Sourcing](/static/img/2017-01-30-设计模式/2019-08-19-23-11-14.png)

#### 适用性

* 即使应用程序状态具有复杂的关系数据结构，也需要非常高的性能来保持应用程序状态。
* 需要记录应用程序状态的更改以及恢复任何时刻状态的能力。
* 需要通过重播过去的事件来调试生产问题。

#### 案例

* [The Lmax Architecture](https://martinfowler.com/articles/lmax.html)
* [Martin Fowler - Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
* [Event Sourcing	Microsoft Docs](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)
* [Reference 3: Introducing Event Sourcing](https://msdn.microsoft.com/en-us/library/jj591559.aspx)

```java
/**
 * This is the base class for domain events. All events must extend this class.
 */
@Data
public abstract class DomainEvent implements Serializable {
    private final long sequenceId;
    private final long createdTime;
    private final String eventClassName;
    private boolean realTime = true;
    /**
     * Instantiates a new Domain event.
     *
     * @param sequenceId     the sequence id
     * @param createdTime    the created time
     * @param eventClassName the event class name
     */
    public DomainEvent(long sequenceId, long createdTime, String eventClassName) {
        this.sequenceId = sequenceId;
        this.createdTime = createdTime;
        this.eventClassName = eventClassName;
    }
    /**
     * Process.
     */
    public abstract void process();
}
/**
 * This is the class that implements account create event.
 * Holds the necessary info for an account create event.
 * Implements the process function that finds the event related
 * domain objects and calls the related domain object's handle event functions
 */
public class AccountCreateEvent extends DomainEvent {
    @Getter
    private final int accountNo;
    @Getter
    private final String owner;

    /**
     * Instantiates a new Account create event.
     *
     * @param sequenceId  the sequence id
     * @param createdTime the created time
     * @param accountNo   the account no
     * @param owner       the owner
     */
    public AccountCreateEvent(long sequenceId, long createdTime, int accountNo, String owner) {
        super(sequenceId, createdTime, "AccountCreateEvent");
        this.accountNo = accountNo;
        this.owner = owner;
    }

    @Override
    public void process() {
        Account account = AccountAggregate.getAccount(accountNo);
        if (account != null) {
            throw new RuntimeException("Account already exists");
        }
        account = new Account(accountNo, owner);
        account.handleEvent(this);
    }
}
/**
 * This is the class that implements money deposit event.
 * Holds the necessary info for a money deposit event.
 * Implements the process function that finds the event related
 * domain objects and calls the related domain object's handle event functions
 */
public class MoneyDepositEvent extends DomainEvent {
    @Getter
    private final BigDecimal money;
    @Getter
    private final int accountNo;

    /**
     * Instantiates a new Money deposit event.
     *
     * @param sequenceId  the sequence id
     * @param createdTime the created time
     * @param accountNo   the account no
     * @param money       the money
     */
    public MoneyDepositEvent(long sequenceId, long createdTime, int accountNo, BigDecimal money) {
        super(sequenceId, createdTime, "MoneyDepositEvent");
        this.money = money;
        this.accountNo = accountNo;
    }

    @Override
    public void process() {
        Account account = AccountAggregate.getAccount(accountNo);
        if (account == null) {
            throw new RuntimeException("Account not found");
        }
        account.handleEvent(this);
    }
}
/**
 * This is the class that implements money transfer event.
 * Holds the necessary info for a money transfer event.
 * Implements the process function that finds the event related
 * domain objects and calls the related domain object's handle event functions
 */
public class MoneyTransferEvent extends DomainEvent {
    @Getter
    private final BigDecimal money;
    @Getter
    private final int accountNoFrom;
    @Getter
    private final int accountNoTo;

    /**
     * Instantiates a new Money transfer event.
     *
     * @param sequenceId    the sequence id
     * @param createdTime   the created time
     * @param money         the money
     * @param accountNoFrom the account no from
     * @param accountNoTo   the account no to
     */
    public MoneyTransferEvent(long sequenceId, long createdTime, BigDecimal money, int accountNoFrom,
                              int accountNoTo) {
        super(sequenceId, createdTime, "MoneyTransferEvent");
        this.money = money;
        this.accountNoFrom = accountNoFrom;
        this.accountNoTo = accountNoTo;
    }

    @Override
    public void process() {
        Account accountFrom = AccountAggregate.getAccount(accountNoFrom);
        if (accountFrom == null) {
            throw new RuntimeException("Account not found " + accountNoFrom);
        }
        Account accountTo = AccountAggregate.getAccount(accountNoTo);
        if (accountTo == null) {
            throw new RuntimeException("Account not found " + accountNoTo);
        }

        accountFrom.handleTransferFromEvent(this);
        accountTo.handleTransferToEvent(this);
    }
}
```

```java

/**
 * This is the Account class that holds the account info, the account number,
 * account owner name and money of the account. Account class also have the business logic of events
 * that effects this account.
 */
@Data
public class Account {
    private static final Logger LOGGER = LoggerFactory.getLogger(Account.class);
    private final int accountNo;
    private final String owner;
    private BigDecimal money;
    private static final String MSG = "Some external api for only realtime execution could be called here.";
    /**
     * Instantiates a new Account.
     *
     * @param accountNo the account no
     * @param owner     the owner
     */
    public Account(int accountNo, String owner) {
        this.accountNo = accountNo;
        this.owner = owner;
        money = BigDecimal.ZERO;
    }
    /**
     * Copy account.
     *
     * @return the account
     */
    public Account copy() {
        Account account = new Account(accountNo, owner);
        account.setMoney(money);
        return account;
    }
    private void depositMoney(BigDecimal money) {
        this.money = this.money.add(money);
    }
    private void withdrawMoney(BigDecimal money) {
        this.money = this.money.subtract(money);
    }
    private void handleDeposit(BigDecimal money, boolean realTime) {
        depositMoney(money);
        AccountAggregate.putAccount(this);
        if (realTime) {
            LOGGER.info(MSG);
        }
    }
    private void handleWithdrawal(BigDecimal money, boolean realTime) {
        if (this.money.compareTo(money) == -1) {
            throw new RuntimeException("Insufficient Account Balance");
        }
        withdrawMoney(money);
        AccountAggregate.putAccount(this);
        if (realTime) {
            LOGGER.info(MSG);
        }
    }
    /**
     * Handles the MoneyDepositEvent.
     *
     * @param moneyDepositEvent the money deposit event
     */
    public void handleEvent(MoneyDepositEvent moneyDepositEvent) {
        handleDeposit(moneyDepositEvent.getMoney(), moneyDepositEvent.isRealTime());
    }
    /**
     * Handles the AccountCreateEvent.
     *
     * @param accountCreateEvent the account create event
     */
    public void handleEvent(AccountCreateEvent accountCreateEvent) {
        AccountAggregate.putAccount(this);
        if (accountCreateEvent.isRealTime()) {
            LOGGER.info(MSG);
        }
    }
    /**
     * Handles transfer from account event.
     *
     * @param moneyTransferEvent the money transfer event
     */
    public void handleTransferFromEvent(MoneyTransferEvent moneyTransferEvent) {
        handleWithdrawal(moneyTransferEvent.getMoney(), moneyTransferEvent.isRealTime());
    }

    /**
     * Handles transfer to account event.
     *
     * @param moneyTransferEvent the money transfer event
     */
    public void handleTransferToEvent(MoneyTransferEvent moneyTransferEvent) {
        handleDeposit(moneyTransferEvent.getMoney(), moneyTransferEvent.isRealTime());
    }
}
```

```java
/**
 * This is the static accounts map holder class.
 * This class holds the state of the accounts.
 */
public class AccountAggregate {
    private static Map<Integer, Account> accounts = new HashMap<>();
    private AccountAggregate() {
    }
    /**
     * Put account.
     *
     * @param account the account
     */
    public static void putAccount(Account account) {
        accounts.put(account.getAccountNo(), account);
    }
    /**
     * Gets account.
     *
     * @param accountNo the account no
     * @return the copy of the account or null if not found
     */
    public static Account getAccount(int accountNo) {
        Account account = accounts.get(accountNo);
        if (account == null) {
            return null;
        }
        return account.copy();
    }
    /**
     * Reset state.
     */
    public static void resetState() {
        accounts = new HashMap<>();
    }
}
```

```java
/**
 * This is the implementation of event processor.
 * All events are processed by this class.
 * This processor uses processorJournal to persist and recover events.
 */
public class DomainEventProcessor {
    private final JsonFileJournal processorJournal = new JsonFileJournal();
    /**
     * Process.
     *
     * @param domainEvent the domain event
     */
    public void process(DomainEvent domainEvent) {
        domainEvent.process();
        processorJournal.write(domainEvent);
    }
    /**
     * Reset.
     */
    public void reset() {
        processorJournal.reset();
    }
    /**
     * Recover.
     */
    public void recover() {
        DomainEvent domainEvent;
        while (true) {
            domainEvent = processorJournal.readNext();
            if (domainEvent == null) {
                break;
            } else {
                domainEvent.process();
            }
        }
    }
}
```

```java
/**
 * This is the implementation of event journal.
 * This implementation serialize/deserialize the events with JSON
 * and writes/reads them on a Journal.json file at the working directory.
 */
public class JsonFileJournal {
    private final File aFile;
    private final List<String> events = new ArrayList<>();
    private int index = 0;
    /**
     * Instantiates a new Json file journal.
     */
    public JsonFileJournal() {
        aFile = new File("Journal.json");
        if (aFile.exists()) {
            try (BufferedReader input = new BufferedReader(
                    new InputStreamReader(new FileInputStream(aFile), "UTF-8"))) {
                String line;
                while ((line = input.readLine()) != null) {
                    events.add(line);
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        } else {
            reset();
        }
    }
    /**
     * Write.
     *
     * @param domainEvent the domain event
     */
    public void write(DomainEvent domainEvent) {
        Gson gson = new Gson();
        JsonElement jsonElement;
        if (domainEvent instanceof AccountCreateEvent) {
            jsonElement = gson.toJsonTree(domainEvent, AccountCreateEvent.class);
        } else if (domainEvent instanceof MoneyDepositEvent) {
            jsonElement = gson.toJsonTree(domainEvent, MoneyDepositEvent.class);
        } else if (domainEvent instanceof MoneyTransferEvent) {
            jsonElement = gson.toJsonTree(domainEvent, MoneyTransferEvent.class);
        } else {
            throw new RuntimeException("Journal Event not recegnized");
        }

        try (Writer output = new BufferedWriter(
                new OutputStreamWriter(new FileOutputStream(aFile, true), "UTF-8"))) {
            String eventString = jsonElement.toString();
            output.write(eventString + "\r\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * Reset.
     */
    public void reset() {
        aFile.delete();
    }
    /**
     * Read next domain event.
     *
     * @return the domain event
     */
    public DomainEvent readNext() {
        if (index >= events.size()) {
            return null;
        }
        String event = events.get(index);
        index++;

        JsonParser parser = new JsonParser();
        JsonElement jsonElement = parser.parse(event);
        String eventClassName = jsonElement.getAsJsonObject().get("eventClassName").getAsString();
        Gson gson = new Gson();
        DomainEvent domainEvent;
        if (eventClassName.equals("AccountCreateEvent")) {
            domainEvent = gson.fromJson(jsonElement, AccountCreateEvent.class);
        } else if (eventClassName.equals("MoneyDepositEvent")) {
            domainEvent = gson.fromJson(jsonElement, MoneyDepositEvent.class);
        } else if (eventClassName.equals("MoneyTransferEvent")) {
            domainEvent = gson.fromJson(jsonElement, MoneyTransferEvent.class);
        } else {
            throw new RuntimeException("Journal Event not recegnized");
        }

        domainEvent.setRealTime(false);
        return domainEvent;
    }
}
```

### Hexagonal Architecture（六边形架构）

同名：

* Ports and Adapters Architecture
* Clean Architecture清洁架构
* Onion Architecture洋葱建筑

#### 意图

允许应用程序对等的由用户、程序、自动测试或批处理脚本驱动，并与其最终的运行时设备和数据库隔离开发和测试。

洋葱架构、整洁架构：

![The Clean Architecture](/static/img/2017-01-30-设计模式/2019-08-21-08-30-26.png)

![The Clean Architecture](/static/img/2017-01-30-设计模式/2019-08-21-08-28-51.png)

* **依赖原则（The dependency rules）**：总得来说，越往里面，代码级别越高。外层的圆是（实现）机制，而内层的圆是原则（Policies）。越往里面抽象级别越高，最外层的圆是低级别的具体细节。越往里面内容越抽象，并且封装更高级别的原则（Policies）。最里面的圆是最通用的。
* **Entities**:Entities封装了企业级的业务规则。一个Entity可以是一个带方法的对象，也可以是一个数据结构和方法集。
  * Entities可以被用于企业的其他应用。如果你没有加入企业，而是仅仅在写一个简单的应用，那么这些Entities就是这个应用的业务对象。它们封装了最通用、最上层的原则。
  * 它们是最不容易改变的，即使外部的东西改变了。例如，你不想让这些对象受到页面导航、安全的影响。应用的任何操作变化都不应该影响Entities Layer。
* **Use Casess**:这一层包含了应用特有的业务规则。它封装和实现了系统的所有用例。
  * 这些用例协调数据从entities的流入和流出，并且指导entities使用它们的企业级业务规则来达到用例的目标。
  * 我们不希望这一层的改变影响到Entities，同时也不希望这一层被外层的改变影响，如外层的数据库，UI或者任何Frameworks的改变，这一层独立于这些关注点。
* **Interface Adapters**:这一层包含一个adapters set（数据适配器集），它们把适用于Use Casess和entities的数据转换为适用于外部服务（external agency，如Database或Web）的格式。例如，这一层可以完全包括GUI的MVX架构，Presenters, Views和Controllers都属于这里。
  * Models可能仅仅是从Controllers传到Use Casess的数据结构，然后从Use Casess返回给Presenters和Views。这一层的数据会被转换，从适用于entities和Use Casess的格式转换到适用于所使用的持久化框架的格式（如数据库）。这个圆以内的代码不应该知道关于数据库的任何东西。同样，这一层也需要一些其他必要的Adapter来把外部的数据格式（如来自于外部服务的格式），转换为适用于Use Casess和entities的格式。
* **Frameworks and Drivers**:最外面的一层通常由Frameworks和Tools组成，如Database,Web Framework等。一般来说，除了用于和内层圆交互的连接代码，你不会在这一层写很多代码。
  * 这一层是实现所有细节的地方。Web和Database都是需要实现的细节。我们把这些东西放在外面以减轻来自于它们的伤害（即减轻对他们的依赖）。
* **跨界**:通常用依赖倒置原则来解决这个明显的矛盾。比如，在Java这样的语言里，我们可以使用接口和继承关系在合适的地方让源码依赖与控制流反向来跨界。
  * 例如，假设Use Cases需要访问Presenter，当然，不能是直接访问,不然会违反依赖原则，所以我们让内圆的Use Cases访问一个接口（如图中的Use Cases output port），然后外圆的Presenter实现这个接口。在这个架构中，同样的技术也被用于跨越其他的边界。我们利用运行时多态来创建与控制流相反的SourceCode依赖以满足依赖原则，无论控制流是如何流向的。
  * 在图的右下角是一个我们应该如何跨界的例子。它展示了Controllers、Presenters与下一层的Use Casess的交互。注意控制的流向，它开始于Controller，经过Use Casess，最终在Presenter中执行。
  * 同时也请注意Source Code依赖，它们每一个都指向内部的Use Casess。例如，很多的数据库框架对于query返回一个方便的数据格式，我们可以称之为Row Structure，我们不想向内部传递这个row structure。这会让内圆知道外圆的内容而违反了依赖原则。所以，我们应该以最适用于内圆使用的格式来传递跨界的数据。

![The Clean Architecture](/static/img/2017-01-30-设计模式/2019-08-21-08-41-26.png)

![Hexagonal Architecture](/static/img/2017-01-30-设计模式/2019-08-20-08-57-45.png)

#### 适用性

* 当应用程序需要独立于任何框架时
* 当应用程序的高可维护性和可测试非常重要时

#### 案例

* [Build Maintainable Systems With Hexagonal Architecture](http://java-design-patterns.com/blog/build-maintainable-systems-with-hexagonal-architecture/)
* [Hexagonal Architecture](https://github.com/iluwatar/java-design-patterns/blob/master/hexagonal/etc/presentation.html)
* [Apache Isis](https://isis.apache.org/) builds generic UI and REST API directly from the underlying domain objects
* [Alistair Cockburn - Hexagonal Architecture](http://alistair.cockburn.us/Hexagonal+architecture)

[Github source](https://github.com/iluwatar/java-design-patterns/tree/master/hexagonal)

### Layers（分层架构）

#### 意图

分层是一种架构风格，其中软件职责在应用程序的不同层之间分配

![Layers](/static/img/2017-01-30-设计模式/2019-08-21-09-19-16.png)

#### 适用性

* 将软件职责明确划分为程序的不同部分
* 防止更改在整个应用程序中传播
* 使应用程序更易于维护和可测试

#### 案例

* [Pattern Oriented Software Architecture Vol I-V](http://www.amazon.com/Pattern-Oriented-Software-Architecture-Volume-Patterns/dp/0471958697)

```java
@Entity
@Data
public class Cake {
    @Id
    @GeneratedValue
    private Long id;
    @OneToOne(cascade = CascadeType.REMOVE)
    private CakeTopping topping;
    @OneToMany(cascade = CascadeType.REMOVE, fetch = FetchType.EAGER)
    private Set<CakeLayer> layers;
    public Cake() {
        setLayers(new HashSet<>());
    }
}

/**
 * CRUD repository for cakes
 */
@Repository
public interface CakeDao extends CrudRepository<Cake, Long> {}

/**
 * DTO for cakes
 */
@ToString
public class CakeInfo {
    public final Optional<Long> id;
    public final CakeToppingInfo cakeToppingInfo;
    public final List<CakeLayerInfo> cakeLayerInfos;
    /**
     * Constructor
     */
    public CakeInfo(Long id, CakeToppingInfo cakeToppingInfo, List<CakeLayerInfo> cakeLayerInfos) {
        this.id = Optional.of(id);
        this.cakeToppingInfo = cakeToppingInfo;
        this.cakeLayerInfos = cakeLayerInfos;
    }
    /**
     * Constructor
     */
    public CakeInfo(CakeToppingInfo cakeToppingInfo, List<CakeLayerInfo> cakeLayerInfos) {
        this.id = Optional.empty();
        this.cakeToppingInfo = cakeToppingInfo;
        this.cakeLayerInfos = cakeLayerInfos;
    }
    /**
     * Calculate calories
     */
    public int calculateTotalCalories() {
        int total = cakeToppingInfo != null ? cakeToppingInfo.calories : 0;
        total += cakeLayerInfos.stream().mapToInt(c -> c.calories).sum();
        return total;
    }
}
```

```java
/**
 * CakeLayer entity
 */
@Entity
@Data
@NoArgsConstructor
public class CakeLayer {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    private int calories;
    @ManyToOne(cascade = CascadeType.ALL)
    private Cake cake;
    public CakeLayer(String name, int calories) {
        this.setName(name);
        this.setCalories(calories);
    }
}

/**
 * CRUD repository for cake layers
 */
@Repository
public interface CakeLayerDao extends CrudRepository<CakeLayer, Long> {}

/**
 * DTO for cake layers
 */
@AllArgsConstructor
@ToString
public class CakeLayerInfo {
    public final Optional<Long> id;
    public final String name;
    public final int calories;
    /**
     * Constructor
     */
    public CakeLayerInfo(Long id, String name, int calories) {
        this.id = Optional.of(id);
        this.name = name;
        this.calories = calories;
    }
    /**
     * Constructor
     */
    public CakeLayerInfo(String name, int calories) {
        this.id = Optional.empty();
        this.name = name;
        this.calories = calories;
    }
}
```

```java
/**
 * CakeTopping entity
 */
@Entity
@Data
@NoArgsConstructor
public class CakeTopping {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    private int calories;
    @OneToOne(cascade = CascadeType.ALL)
    private Cake cake;
    public CakeTopping(String name, int calories) {
        this.setName(name);
        this.setCalories(calories);
    }
}

/**
 * CRUD repository cake toppings
 */
@Repository
public interface CakeToppingDao extends CrudRepository<CakeTopping, Long> {}

/**
 * DTO for cake toppings
 */
@ToString
public class CakeToppingInfo {
    public final Optional<Long> id;
    public final String name;
    public final int calories;
    /**
     * Constructor
     */
    public CakeToppingInfo(Long id, String name, int calories) {
        this.id = Optional.of(id);
        this.name = name;
        this.calories = calories;
    }
    /**
     * Constructor
     */
    public CakeToppingInfo(String name, int calories) {
        this.id = Optional.empty();
        this.name = name;
        this.calories = calories;
    }
}
```

```java
/**
 * Service for cake baking operations
 */
public interface CakeBakingService {
    /**
     * Bakes new cake according to parameters
     */
    void bakeNewCake(CakeInfo cakeInfo) throws CakeBakingException;
    /**
     * Get all cakes
     */
    List<CakeInfo> getAllCakes();
    /**
     * Store new cake topping
     */
    void saveNewTopping(CakeToppingInfo toppingInfo);
    /**
     * Get available cake toppings
     */
    List<CakeToppingInfo> getAvailableToppings();
    /**
     * Add new cake layer
     */
    void saveNewLayer(CakeLayerInfo layerInfo);
    /**
     * Get available cake layers
     */
    List<CakeLayerInfo> getAvailableLayers();
}


/**
 * Implementation of CakeBakingService
 */
@Service
@Transactional
public class CakeBakingServiceImpl implements CakeBakingService {
    private AbstractApplicationContext context;
    public CakeBakingServiceImpl() {
        this.context = new ClassPathXmlApplicationContext("applicationContext.xml");
    }
    @Override
    public void bakeNewCake(CakeInfo cakeInfo) throws CakeBakingException {
        List<CakeTopping> allToppings = getAvailableToppingEntities();
        List<CakeTopping> matchingToppings =
                allToppings.stream().filter(t -> t.getName().equals(cakeInfo.cakeToppingInfo.name))
                        .collect(Collectors.toList());
        if (matchingToppings.isEmpty()) {
            throw new CakeBakingException(String.format("Topping %s is not available",
                    cakeInfo.cakeToppingInfo.name));
        }
        List<CakeLayer> allLayers = getAvailableLayerEntities();
        Set<CakeLayer> foundLayers = new HashSet<>();
        for (CakeLayerInfo info : cakeInfo.cakeLayerInfos) {
            Optional<CakeLayer> found =
                    allLayers.stream().filter(layer -> layer.getName().equals(info.name)).findFirst();
            if (!found.isPresent()) {
                throw new CakeBakingException(String.format("Layer %s is not available", info.name));
            } else {
                foundLayers.add(found.get());
            }
        }
        CakeToppingDao toppingBean = context.getBean(CakeToppingDao.class);
        CakeTopping topping = toppingBean.findOne(matchingToppings.iterator().next().getId());
        CakeDao cakeBean = context.getBean(CakeDao.class);
        Cake cake = new Cake();
        cake.setTopping(topping);
        cake.setLayers(foundLayers);
        cakeBean.save(cake);
        topping.setCake(cake);
        toppingBean.save(topping);
        CakeLayerDao layerBean = context.getBean(CakeLayerDao.class);
        for (CakeLayer layer : foundLayers) {
            layer.setCake(cake);
            layerBean.save(layer);
        }
    }
    @Override
    public void saveNewTopping(CakeToppingInfo toppingInfo) {
        CakeToppingDao bean = context.getBean(CakeToppingDao.class);
        bean.save(new CakeTopping(toppingInfo.name, toppingInfo.calories));
    }
    @Override
    public void saveNewLayer(CakeLayerInfo layerInfo) {
        CakeLayerDao bean = context.getBean(CakeLayerDao.class);
        bean.save(new CakeLayer(layerInfo.name, layerInfo.calories));
    }
    private List<CakeTopping> getAvailableToppingEntities() {
        CakeToppingDao bean = context.getBean(CakeToppingDao.class);
        List<CakeTopping> result = new ArrayList<>();
        Iterator<CakeTopping> iterator = bean.findAll().iterator();
        while (iterator.hasNext()) {
            CakeTopping topping = iterator.next();
            if (topping.getCake() == null) {
                result.add(topping);
            }
        }
        return result;
    }
    @Override
    public List<CakeToppingInfo> getAvailableToppings() {
        CakeToppingDao bean = context.getBean(CakeToppingDao.class);
        List<CakeToppingInfo> result = new ArrayList<>();
        Iterator<CakeTopping> iterator = bean.findAll().iterator();
        while (iterator.hasNext()) {
            CakeTopping next = iterator.next();
            if (next.getCake() == null) {
                result.add(new CakeToppingInfo(next.getId(), next.getName(), next.getCalories()));
            }
        }
        return result;
    }
    private List<CakeLayer> getAvailableLayerEntities() {
        CakeLayerDao bean = context.getBean(CakeLayerDao.class);
        List<CakeLayer> result = new ArrayList<>();
        Iterator<CakeLayer> iterator = bean.findAll().iterator();
        while (iterator.hasNext()) {
            CakeLayer next = iterator.next();
            if (next.getCake() == null) {
                result.add(next);
            }
        }
        return result;
    }
    @Override
    public List<CakeLayerInfo> getAvailableLayers() {
        CakeLayerDao bean = context.getBean(CakeLayerDao.class);
        List<CakeLayerInfo> result = new ArrayList<>();
        Iterator<CakeLayer> iterator = bean.findAll().iterator();
        while (iterator.hasNext()) {
            CakeLayer next = iterator.next();
            if (next.getCake() == null) {
                result.add(new CakeLayerInfo(next.getId(), next.getName(), next.getCalories()));
            }
        }
        return result;
    }
    @Override
    public List<CakeInfo> getAllCakes() {
        CakeDao cakeBean = context.getBean(CakeDao.class);
        List<CakeInfo> result = new ArrayList<>();
        Iterator<Cake> iterator = cakeBean.findAll().iterator();
        while (iterator.hasNext()) {
            Cake cake = iterator.next();
            CakeToppingInfo cakeToppingInfo =
                    new CakeToppingInfo(cake.getTopping().getId(), cake.getTopping().getName(), cake
                            .getTopping().getCalories());
            List<CakeLayerInfo> cakeLayerInfos = new ArrayList<>();
            for (CakeLayer layer : cake.getLayers()) {
                cakeLayerInfos.add(new CakeLayerInfo(layer.getId(), layer.getName(), layer.getCalories()));
            }
            CakeInfo cakeInfo = new CakeInfo(cake.getId(), cakeToppingInfo, cakeLayerInfos);
            result.add(cakeInfo);
        }
        return result;
    }
}


/**
 * Custom exception used in cake baking
 */
public class CakeBakingException extends Exception {
    private static final long serialVersionUID = 1L;
    public CakeBakingException() {
    }
    public CakeBakingException(String message) {
        super(message);
    }
}
```

### Naked Objects（裸对象模式）

#### 意图

裸对象结构模式非常适合快速原型设计。使用该模式，您只需要编写域对象，其他所有内容都由框架自动生成。

![Naked Objects](/static/img/2017-01-30-设计模式/2019-08-22-09-06-50.png)

#### 适用性

* 你是原型，需要快速的开发周期
* 自动生成的用户界面就足够了
* 希望自动将域发布为REST服务

#### 案例

* [Apache Isis](https://isis.apache.org/)
* [Richard Pawson - Naked Objects](http://downloads.nakedobjects.net/resources/Pawson%20thesis.pdf)

[Github source](https://github.com/iluwatar/java-design-patterns/tree/master/naked-objects)

### Partial Response（部分响应）

#### 意图

根据需要从服务器发送部分响应。客户端将指定服务器所需的字段，而不是提供资源的所有详细信息。

![ Partial Response](/static/img/2017-01-30-设计模式/2019-08-22-09-17-41.png)

#### 适用性

* 客户端只需要来自资源的数据子集。
* 避免过多的数据传输

#### 案例

* [Common Design Patterns](https://cloud.google.com/apis/design/design_patterns)
* [Partial Response in RESTful API Design](http://yaoganglian.com/2013/07/01/partial-response/)

```java
/**
 * {@link Video} is a entity to serve from server.It contains all video related information..
 * <p>
 */
@AllArgsConstructor
@ToString
public class Video {
    private final Integer id;
    private final String title;
    private final Integer length;
    private final String description;
    private final String director;
    private final String language;
}

/**
 * The resource class which serves video information.
 * This class act as server in the demo. Which has all video details.
 */
public class VideoResource {
    private FieldJsonMapper fieldJsonMapper;
    private Map<Integer, Video> videos;
    /**
     * @param fieldJsonMapper map object to json.
     * @param videos          initialize resource with existing videos. Act as database.
     */
    public VideoResource(FieldJsonMapper fieldJsonMapper, Map<Integer, Video> videos) {
        this.fieldJsonMapper = fieldJsonMapper;
        this.videos = videos;
    }
    /**
     * @param id     video id
     * @param fields fields to get information about
     * @return full response if no fields specified else partial response for given field.
     */
    public String getDetails(Integer id, String... fields) throws Exception {
        if (fields.length == 0) {
            return videos.get(id).toString();
        }
        return fieldJsonMapper.toJson(videos.get(id), fields);
    }
}
/**
 * Map a video to json
 */
public class FieldJsonMapper {
    /**
     * @param video  object containing video information
     * @param fields fields information to get
     * @return json of required fields from video
     */
    public String toJson(Video video, String[] fields) throws Exception {
        StringBuilder json = new StringBuilder().append("{");

        for (int i = 0, fieldsLength = fields.length; i < fieldsLength; i++) {
            json.append(getString(video, Video.class.getDeclaredField(fields[i])));
            if (i != fieldsLength - 1) {
                json.append(",");
            }
        }
        json.append("}");
        return json.toString();
    }
    private String getString(Video video, Field declaredField) throws IllegalAccessException {
        declaredField.setAccessible(true);
        Object value = declaredField.get(video);
        if (declaredField.get(video) instanceof Integer) {
            return "\"" + declaredField.getName() + "\"" + ": " + value;
        }
        return "\"" + declaredField.getName() + "\"" + ": " + "\"" + value.toString() + "\"";
    }
}

public static void main(String[] args) throws Exception {
    Map<Integer, Video> videos = new HashMap<>();
    videos.put(1, new Video(1, "Avatar", 178, "epic science fiction film", "James Cameron", "English"));
    videos.put(2, new Video(2, "Godzilla Resurgence", 120, "Action & drama movie|", "Hideaki Anno", "Japanese"));
    videos.put(3, new Video(3, "Interstellar", 169, "Adventure & Sci-Fi", "Christopher Nolan", "English"));
    VideoResource videoResource = new VideoResource(new FieldJsonMapper(), videos);
    String videoDetails = videoResource.getDetails(1);
    LOGGER.info(videoDetails);
    String specificFieldsDetails = videoResource.getDetails(3, "id", "title", "director");
    LOGGER.info(specificFieldsDetails);
    String videoLength = videoResource.getDetails(3, "id", "length");
}
```

### Serverless

#### 解释

术语“Serverless”令人困惑，因为这些应用程序在某处运行服务器硬件和服务器进程，但与正常方法的不同之处在于，构建和支持“无服务器”应用程序的组织不关注硬件或进程 -  他们将此外包给供应商。

Serverless消除了规划基础架构的需要，让您专注于您的应用程序。

以下是在构建无服务器应用程序时应注意的优化点：

* **精益功能**
  * **简洁逻辑**：使用函数进行转换，而不是传输（利用提供程序提供的某些集成进行传输），并确保只读取所需内容
  * **高效/单一用途代码**：避免条件/路由逻辑并分解为单个函数，避免“胖”/单片函数并控制函数部署包中的依赖关系以减少函数的加载时间
  * **短暂的环境**：利用容器启动进行昂贵的初始化
* **事件调用**
  * **简洁的有效负载**：尽可能仔细检查事件，并监视有效负载限制（异步-128K）
  * **弹性路由**：了解重试策略并利用死信队列（SQS或SNS进行重放）并记住重试计数为调用
  * **并发执行**：Amazon Lambda认为它在并发性方面的规模，而不是基于请求/基于持续时间。 Lambda将根据请求调整实例数。
* **协调调用**
  * **通过API解耦**：设置应用程序的最佳做法是将API作为合同来确保关注点分离
  * **规模匹配的下游**：确保当Lambda调用下游组件时，您将匹配扩展配置（通过基于下游服务指定最大并发）
  * **安全**：总是问一个问题，我需要一个VPC吗？
* **服务性操作**
  * **自动化**：使用自动化工具来管理和维护堆栈
  * **受监控的应用程序**：使用监控服务来全面查看Serverless应用程序

Serverless计算是云计算执行模型，其中云提供商动态地管理机器资源的分配。 定价基于应用程序消耗的实际资源量，而不是预先购买的容量单位。

(Function as a Service or "FaaS")

#### 意图

无论是降低基础架构成本，缩短花在操作任务上的时间，简化部署流程，实现无限可扩展性，无服务器都能将上市时间缩短一半。

#### 案例

* [serverless docs](https://serverless.com/framework/docs/)
* [Serverless Architectures](https://martinfowler.com/articles/serverless.html)
* [Serverless Black Belt](https://youtu.be/oQFORsso2go)

### Service Layer（服务层）

#### 意图

服务层是域逻辑的抽象。

通常，应用程序需要多种接口来存储它们存储的数据和它们实现的逻辑：数据加载器，用户界面，集成网关等。 尽管它们的目的不同，但这些接口通常需要与应用程序进行通用交互才能访问和操作其数据并调用其业务逻辑。

服务层履行此职责。

![Service Layer](/static/img/2017-01-30-设计模式/2019-08-23-09-25-56.png)

#### 适用性

* 您想在API下封装域逻辑
* 需要使用通用逻辑和数据实现多个接口

#### 案例

* [Martin Fowler - Service Layer](http://martinfowler.com/eaaCatalog/serviceLayer.html)
* [Patterns of Enterprise Application Architecture](http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420)

```java
/**
 * Service interface.
 */
public interface MagicService {
    List<Wizard> findAllWizards();
    List<Spellbook> findAllSpellbooks();
    List<Spell> findAllSpells();
    List<Wizard> findWizardsWithSpellbook(String name);
    List<Wizard> findWizardsWithSpell(String name);
}

/**
 * Service implementation.
 */
public class MagicServiceImpl implements MagicService {
    private WizardDao wizardDao;
    private SpellbookDao spellbookDao;
    private SpellDao spellDao;
    /**
     * Constructor
     */
    public MagicServiceImpl(WizardDao wizardDao, SpellbookDao spellbookDao, SpellDao spellDao) {
        this.wizardDao = wizardDao;
        this.spellbookDao = spellbookDao;
        this.spellDao = spellDao;
    }
    @Override
    public List<Wizard> findAllWizards() {
        return wizardDao.findAll();
    }
    @Override
    public List<Spellbook> findAllSpellbooks() {
        return spellbookDao.findAll();
    }
    @Override
    public List<Spell> findAllSpells() {
        return spellDao.findAll();
    }
    @Override
    public List<Wizard> findWizardsWithSpellbook(String name) {
        Spellbook spellbook = spellbookDao.findByName(name);
        return new ArrayList<>(spellbook.getWizards());
    }
    @Override
    public List<Wizard> findWizardsWithSpell(String name) {
        Spell spell = spellDao.findByName(name);
        Spellbook spellbook = spell.getSpellbook();
        return new ArrayList<>(spellbook.getWizards());
    }
}

/**
 * SpellDao interface.
 */
public interface SpellDao extends Dao<Spell> {
    Spell findByName(String name);
}
/**
 * SpellbookDao interface.
 */
public interface SpellbookDao extends Dao<Spellbook> {
    Spellbook findByName(String name);
}
/**
 * WizardDao interface.
 */
public interface WizardDao extends Dao<Wizard> {
    Wizard findByName(String name);
}
```

### Unit Of Work（单元化）

#### 意图

当业务事务完成时，所有这些更新将作为一个大的工作单元一次性发送到数据库中，以便最大限度地减少数据库交互。

![Unit Of Work](/static/img/2017-01-30-设计模式/2019-08-26-08-58-00.png)

#### 适用性

* 优化数据库事务所需的时间。
* 将更改作为工作单元发送到数据库，以确保事务的原子性。
* 减少数据库调用次数。

#### 案例

* [Design Pattern - Unit Of Work Pattern](https://www.codeproject.com/Articles/581487/Unit-of-Work-Design-Pattern)
* [Unit Of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html)

```java
/**
 * @param <T> Any generic entity
 */
public interface IUnitOfWork<T> {
    String INSERT = "INSERT";
    String DELETE = "DELETE";
    String MODIFY = "MODIFY";
    /**
     * Any register new operation occurring on UnitOfWork is only going to be performed on commit.
     */
    void registerNew(T entity);
    /**
     * Any register modify operation occurring on UnitOfWork is only going to be performed on commit.
     */
    void registerModified(T entity);
    /**
     * Any register delete operation occurring on UnitOfWork is only going to be performed on commit.
     */
    void registerDeleted(T entity);
    /***
     * All UnitOfWork operations batched together executed in commit only.
     */
    void commit();
}

/**
 * {@link StudentRepository} Student database repository.
 * supports unit of work for student data.
 */
public class StudentRepository implements IUnitOfWork<Student> {
    private static final Logger LOGGER = LoggerFactory.getLogger(StudentRepository.class);
    private Map<String, List<Student>> context;
    private StudentDatabase studentDatabase;
    /**
     * @param context         set of operations to be perform during commit.
     * @param studentDatabase Database for student records.
     */
    public StudentRepository(Map<String, List<Student>> context, StudentDatabase studentDatabase) {
        this.context = context;
        this.studentDatabase = studentDatabase;
    }
    @Override
    public void registerNew(Student student) {
        LOGGER.info("Registering {} for insert in context.", student.getName());
        register(student, IUnitOfWork.INSERT);
    }
    @Override
    public void registerModified(Student student) {
        LOGGER.info("Registering {} for modify in context.", student.getName());
        register(student, IUnitOfWork.MODIFY);

    }
    @Override
    public void registerDeleted(Student student) {
        LOGGER.info("Registering {} for delete in context.", student.getName());
        register(student, IUnitOfWork.DELETE);
    }
    private void register(Student student, String operation) {
        List<Student> studentsToOperate = context.get(operation);
        if (studentsToOperate == null) {
            studentsToOperate = new ArrayList<>();
        }
        studentsToOperate.add(student);
        context.put(operation, studentsToOperate);
    }
    /**
     * All UnitOfWork operations are batched and executed together on commit only.
     */
    @Override
    public void commit() {
        if (context == null || context.size() == 0) {
            return;
        }
        LOGGER.info("Commit started");
        if (context.containsKey(IUnitOfWork.INSERT)) {
            commitInsert();
        }
        if (context.containsKey(IUnitOfWork.MODIFY)) {
            commitModify();
        }
        if (context.containsKey(IUnitOfWork.DELETE)) {
            commitDelete();
        }
        LOGGER.info("Commit finished.");
    }
    private void commitInsert() {
        List<Student> studentsToBeInserted = context.get(IUnitOfWork.INSERT);
        for (Student student : studentsToBeInserted) {
            LOGGER.info("Saving {} to database.", student.getName());
            studentDatabase.insert(student);
        }
    }
    private void commitModify() {
        List<Student> modifiedStudents = context.get(IUnitOfWork.MODIFY);
        for (Student student : modifiedStudents) {
            LOGGER.info("Modifying {} to database.", student.getName());
            studentDatabase.modify(student);
        }
    }
    private void commitDelete() {
        List<Student> deletedStudents = context.get(IUnitOfWork.DELETE);
        for (Student student : deletedStudents) {
            LOGGER.info("Deleting {} to database.", student.getName());
            studentDatabase.delete(student);
        }
    }
}

```

### Abstract Document（抽象文档）

#### 意图

实现非类型化语言的灵活性，保持类型安全。

![Abstract Document](/static/img/2017-01-30-设计模式/2019-08-18-23-01-36.png)

#### 适用性

* 需要动态添加新属性
* you want a flexible way to organize domain in tree like structure
  * 你想要一种灵活的方式来组织树状结构中的域
* 你想要更松散耦合的系统

#### 案例

* [Wikipedia: Abstract Document Pattern](https://en.wikipedia.org/wiki/Abstract_Document_Pattern)
* [Martin Fowler: Dealing with properties](https://martinfowler.com/apsupp/properties.pdf)

```java
/**
 * Document interface
 */
public interface Document {

    /**
     * Puts the value related to the key
     *
     * @param key   element key
     * @param value element value
     * @return Void
     */
    Void put(String key, Object value);

    /**
     * Gets the value for the key
     *
     * @param key element key
     * @return value or null
     */
    Object get(String key);

    /**
     * Gets the stream of child documents
     *
     * @param key         element key
     * @param constructor constructor of child class
     * @return child documents
     */
    <T> Stream<T> children(String key, Function<Map<String, Object>, T> constructor);
}
```

```java
/**
 * Abstract implementation of Document interface
 */
public abstract class AbstractDocument implements Document {

    private final Map<String, Object> properties;

    protected AbstractDocument(Map<String, Object> properties) {
        Objects.requireNonNull(properties, "properties map is required");
        this.properties = properties;
    }

    @Override
    public Void put(String key, Object value) {
        properties.put(key, value);
        return null;
    }

    @Override
    public Object get(String key) {
        return properties.get(key);
    }

    @Override
    public <T> Stream<T> children(String key, Function<Map<String, Object>, T> constructor) {
        Optional<List<Map<String, Object>>> any = Stream.of(get(key))
                .filter(Objects::nonNull)
                .map(el -> (List<Map<String, Object>>) el)
                .findAny();
        return any.map(maps -> maps.stream().map(constructor)).orElseGet(Stream::empty);
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(getClass().getName()).append("[");
        properties.forEach((key, value) -> builder.append("[").append(key).append(" : ").append(value).append("]"));
        builder.append("]");
        return builder.toString();
    }

}
```

```java
/**
 *
 * Enum To Describe Property type
 *
 */
public enum Property {
    PARTS, TYPE, PRICE, MODEL
}

/**
 * HasModel trait for static access to 'model' property
 */
public interface HasModel extends Document {
    default Optional<String> getModel() {
        return Optional.ofNullable((String) get(Property.MODEL.toString()));
    }
}

/**
 * HasPrice trait for static access to 'price' property
 */
public interface HasPrice extends Document {
    default Optional<Number> getPrice() {
        return Optional.ofNullable((Number) get(Property.PRICE.toString()));
    }
}

/**
 * HasType trait for static access to 'type' property
 */
public interface HasType extends Document {
    default Optional<String> getType() {
        return Optional.ofNullable((String) get(Property.TYPE.toString()));
    }
}

/**
 * HasParts trait for static access to 'parts' property
 */
public interface HasParts extends Document {
    default Stream<Part> getParts() {
        // 这里获得children
        return children(Property.PARTS.toString(), Part::new);
    }
}
```

```java
/**
 * Car entity
 */
public class Car extends AbstractDocument implements HasModel, HasPrice, HasParts {
    public Car(Map<String, Object> properties) {
        super(properties);
    }
}

/**
 * Part entity
 */
public class Part extends AbstractDocument implements HasType, HasModel, HasPrice {
    public Part(Map<String, Object> properties) {
        super(properties);
    }
}
```



## 复合模式（Compound Patter）

模式通常被遗弃使用，并被组合在同一个设计解决方案中  
复合模式在同一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题，如MVC模式  

> MVC是复合模式，结合了观察者模式（Model是被观察者）、策略模式（Controller是策略）和组合模式（View内的控件管理）？？？  
> 模型使用观察者模式，以便观察者更新，同时保持两者之间解耦  
> 控制器是视图的策略，视图可以使用不同的控制器实现  
> 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，如面板、框架和按钮  
> 这些模式携手合作，把MVC模式的三层解耦，这样保持设计的干净又有弹性  
> 适配器模式用来将新的模型适配成已有的视图和控制器  

## 常见设计缺陷及解决

* 显示指定一个类创建对象
	- 工厂模式、原型模式
* 对特殊操作的依赖
	- 责任链模式、命令模式
* 对硬件或软件平台的依赖
	- 抽象工厂模式、桥接模式
* 对对象表示或实现的依赖
	- 抽象工厂模式、桥接模式、记事本模式、代理模式
* 算法依赖
	- 创建者模式、迭代器模式、策略模式、模范方法模式、访问者模式
* 紧耦合
	- 抽象工厂模式、命令模式、外观模式、中介者模式、观察者模式、责任链模式
* 通过生成子类扩展功能
	- 桥接模式、责任链模式、组合模式、装饰模式、观察者模式、策略模式
* 不能方便的对类进行修改
	- 适配器模式、装饰模式、访问者模式

----------

*以上概念总结于传智播客Java基础课程*
