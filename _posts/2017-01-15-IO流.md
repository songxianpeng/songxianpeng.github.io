---
layout: post
title: Java IO/NIO、Netty
tags: IO File netty NIO 
categories: Java
published: true
---

## File

文件和目录(文件夹)路径名的抽象表示形式

> 仅仅是一个路径的表示，不代码具体的事物一定是存在的。

### list()方法

通过参数FilenameFilter限定符合要求的文件或目录

```java
// 封装e判断目录
File file = new File("d:\\");

// 获取该目录下所有文件或者文件夹的String数组
// public String[] list(FilenameFilter filter)
String[] strArray = file.list(new FilenameFilter() {
	@Override
	public boolean accept(File dir, String name) {
		return new File(dir, name).isFile() && name.endsWith(".jpg");
	}
});

// 遍历
for (String s : strArray) {
	System.out.println(s);
}
```

### 递归遍历文件夹

```java
private static void getAllJavaFilePaths(File srcFolder) {
	// 获取该目录下所有的文件或者文件夹的File数组
	File[] fileArray = srcFolder.listFiles();

	// 遍历该File数组，得到每一个File对象
	for (File file : fileArray) {
		// 判断该File对象是否是文件夹
		if (file.isDirectory()) {
			getAllJavaFilePaths(file);
		} else {
			// 继续判断是否以.java结尾
			if (file.getName().endsWith(".java")) {
				// 就输出该文件的绝对路径
				System.out.println(file.getAbsolutePath());
			}
		}
	}
}
```

## IO流

### 分类

* 按照数据流向
	- 输入流
	- 输出流
* 按照数据类型（默认）
	- 字节流
		+ 字节输入流
		+ 字节输出流
	- 字符流
		+ 字符输入流
		+ 字符输出流

### 基类

* 字节流的抽象基类及子类：
	- InputStream
		+ FileInputStream
		+ BufferedInputStream
	- OutputStream
		+ FileOutputStream
		+ BufferedOutputStream
* 字符流的抽象基类及子类：
	- Reader
		+ FileReader
		+ BufferedReader
	- Writer
		+ FileWriter
		+ BufferedWriter

![IO流小结图解](/static/img/IO流/IO流小结图解.jpg "IO流小结图解")

### 字节流

#### FileOutputStream和FileInputStream

```java
// 基本字节流一次读写一个字节数组
public static void method2(String srcString, String destString)
		throws IOException {
	FileInputStream fis = new FileInputStream(srcString);
	FileOutputStream fos = new FileOutputStream(destString);

	byte[] bys = new byte[1024];
	int len = 0;
	while ((len = fis.read(bys)) != -1) {
		fos.write(bys, 0, len);
	}

	fos.close();
	fis.close();
}

// 基本字节流一次读写一个字节
public static void method1(String srcString, String destString)
		throws IOException {
	FileInputStream fis = new FileInputStream(srcString);
	FileOutputStream fos = new FileOutputStream(destString);

	int by = 0;
	while ((by = fis.read()) != -1) {
		fos.write(by);
	}

	fos.close();
	fis.close();
}
```

#### 换行符

* windows:`\r\n`
* linux:`\n`
* Mac:`\r`

#### 追加文件

```java
// 创建一个向具有指定 name 的文件中写入数据的输出文件流。
// 如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。
FileOutputStream fos = new FileOutputStream("fos3.txt", true);
```

#### 创建字节输出流对象做了几件事情

1. 调用系统功能去创建文件
2. 创建fos对象
3. 把fos对象指向这个文件

### 字节缓冲区流

#### BufferedOutputStream和BufferedInputStream

```java
// 高效字节流一次读写一个字节数组：
public static void method4(String srcString, String destString)
		throws IOException {
	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(
			srcString));
	//为什么不传递一个具体的文件或者文件路径，而是传递一个OutputStream对象?
	//因为字节缓冲区流仅仅提供缓冲区，为高效而设计的。真正的读写操作还是基本的流对象实现。

	//构造方法可以指定缓冲区的大小，但是我们一般不用，默认缓冲区大小就够了
	BufferedOutputStream bos = new BufferedOutputStream(
			new FileOutputStream(destString));

	byte[] bys = new byte[1024];
	int len = 0;
	while ((len = bis.read(bys)) != -1) {
		bos.write(bys, 0, len);
	}

	bos.close();
	bis.close();
}

// 高效字节流一次读写一个字节：
public static void method3(String srcString, String destString)
		throws IOException {
	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(
			srcString));
	BufferedOutputStream bos = new BufferedOutputStream(
			new FileOutputStream(destString));

	int by = 0;
	while ((by = bis.read()) != -1) {
		bos.write(by);

	}

	bos.close();
	bis.close();
}
```

### 字符流

**计算机是如何识别什么时候该把两个字节转换为一个中文呢?**

> 在计算机中中文的存储分两个字节：  
>> 第一个字节肯定是负数。  
>> 第二个字节常见的是负数，可能有正数。但是没影响。  

```java
// String s = "abcde";
// // [97, 98, 99, 100, 101]

String s = "我爱你中国";
// [-50, -46, -80, -82, -60, -29, -42, -48, -71, -6]

byte[] bys = s.getBytes();
System.out.println(Arrays.toString(bys));
```

由于字节流操作中文不是特别方便，所以，java就提供了转换流。  
转换流其实是一个字符流
> 字符流=字节流+编码表。

#### 编码表

> 计算机只能识别二进制数据，早期由来是电信号。  
> 为了方便应用计算机，让它可以识别各个国家的文字。  
> 就将各个国家的文字用数字来表示，并一一对应，形成一张表。  
> 
> ASCII：美国标准信息交换码。用一个字节的7位可以表示。  
> ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。  
> GB2312：中国的中文编码表。  
> GBK：中国的中文编码表升级，融合了更多的中文文字符号。  
> GB18030：GBK的取代版本  
> BIG-5码 ：通行于台湾、香港地区的一个繁体字编码方案，俗称“大五码”。  
> Unicode：国际标准码，融合了多种文字。所有文字都用两个字节来表示,Java语言使用的就是unicode  
> UTF-8：最多用三个字节来表示一个字符。  
> 
> UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容：  
> 它将Unicode编码为00000000-0000007F的字符，用单个字节来表示  
> 它将Unicode编码为00000080-000007FF的字符用两个字节表示  
> 它将Unicode编码为00000800-0000FFFF的字符用3字节表示 

#### OutputStreamWriter和InputStreamReader

```java
InputStreamReader isr = new InputStreamReader(new FileInputStream(
		"a.txt"));
// 封装目的地
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(
		"b.txt"));

// 读写数据
// 方式1
// int ch = 0;
// while ((ch = isr.read()) != -1) {
// osw.write(ch);
// }

// 方式2
char[] chs = new char[1024];
int len = 0;
while ((len = isr.read(chs)) != -1) {
	osw.write(chs, 0, len);
	// osw.flush();
}

// 释放资源
osw.close();
isr.close();
```

#### FileWriter和FileReader

使用默认本地编码表的InputStreamReader和OutputStreamReader封装类

```java
// 基本字符流一次读写一个字符数组
private static void method2(String srcString, String destString)
		throws IOException {
	FileReader fr = new FileReader(srcString);
	FileWriter fw = new FileWriter(destString);

	char[] chs = new char[1024];
	int len = 0;
	while ((len = fr.read(chs)) != -1) {
		fw.write(chs, 0, len);
	}

	fw.close();
	fr.close();
}

// 基本字符流一次读写一个字符
private static void method1(String srcString, String destString)
		throws IOException {
	FileReader fr = new FileReader(srcString);
	FileWriter fw = new FileWriter(destString);

	int ch = 0;
	while ((ch = fr.read()) != -1) {
		fw.write(ch);
	}

	fw.close();
	fr.close();
}
```

#### BufferedReader和BufferedWriter

```java
// 字符缓冲流一次读写一个字符串
private static void method5(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	String line = null;
	while ((line = br.readLine()) != null) {
		bw.write(line);
		bw.newLine();
		bw.flush();
	}

	bw.close();
	br.close();
}

// 字符缓冲流一次读写一个字符数组
private static void method4(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	char[] chs = new char[1024];
	int len = 0;
	while ((len = br.read(chs)) != -1) {
		bw.write(chs, 0, len);
	}

	bw.close();
	br.close();
}
// 字符缓冲流一次读写一个字符
private static void method3(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	int ch = 0;
	while ((ch = br.read()) != -1) {
		bw.write(ch);
	}

	bw.close();
	br.close();
}
```

### 缓冲流与普通流区别

> 在FileInputStream里有一个说明是说此方法将阻塞，意思就是说在你读一个文件输入流的时候，当读到某个位置的时候，如果做一些其他处理（比如说接受一部分字节做一些处理等等）这个时候输入流在什么位置就是什么位置，不会继续往下读，而BufferedInputStream虽然也有一个read方法，但是从名字就可以看出，它带有一个缓冲区，它是一个非阻塞的方法，在你读到某个位置的时候，做一些处理的时候，输入流可能还会继续读入字节，这样就达到了缓冲的效果。

缓冲流默认的缓冲大小是8192，可以使用构造方法制定缓冲区大小，一般不用。  
缓冲区是缓冲流内部的数组，与传入的数组参数无关，最终使用arraycopy返回

### 数据操作流

可以操作基本类型的数据

* DataInputStream
* DataOutputStream

```java
private static void write() throws IOException {
	// DataOutputStream(OutputStream out)
	// 创建数据输出流对象
	DataOutputStream dos = new DataOutputStream(new FileOutputStream(
			"dos.txt"));

	// 写数据了
	dos.writeByte(10);
	dos.writeShort(100);
	dos.writeInt(1000);
	dos.writeLong(10000);
	dos.writeFloat(12.34F);
	dos.writeDouble(12.56);
	dos.writeChar('a');
	dos.writeBoolean(true);

	// 释放资源
	dos.close();

	// dos.txt
	// 0a00 6400 0003 e800 0000 0000 0027 1041
	// 4570 a440 291e b851 eb85 1f00 6101 
}

private static void read() throws IOException {
	// DataInputStream(InputStream in)
	// 创建数据输入流对象
	DataInputStream dis = new DataInputStream(
			new FileInputStream("dos.txt"));

	// 读数据
	byte b = dis.readByte();
	short s = dis.readShort();
	int i = dis.readInt();
	long l = dis.readLong();
	float f = dis.readFloat();
	double d = dis.readDouble();
	char c = dis.readChar();
	boolean bb = dis.readBoolean();

	// 释放资源
	dis.close();

	System.out.println(b);// 10
	System.out.println(s);// 100
	System.out.println(i);// 1000
	System.out.println(l);// 10000
	System.out.println(f);// 12.34
	System.out.println(d);// 12.56
	System.out.println(c);// a
	System.out.println(bb);// true
}
```

### 内存操作流

有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。

* ByteArrayInputStream,ByteArrayOutputStream
* CharArrayReader,CharArrayWriter
* StringReader,StringWriter

### 打印流概述

* 字节流打印流 PrintStream
* 字符打印流 PrintWriter

```java
// 复制文本文件
BufferedReader br = new BufferedReader(new FileReader("a.txt"));
PrintWriter pw = new PrintWriter(new FileWriter("b.txt"),true);// 启动自动刷新

String line = null;
while((line=br.readLine())!=null) {
	pw.println(line);
}

pw.close();
br.close();
```

#### 特点

* 只有写数据的，没有读取数据。只能操作目的地，不能操作数据源。
* 可以操作任意类型的数据
* 如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新
* 可以直接操作文件

### 标准输入输出流

System类中的字段：in，out

> 它们各代表了系统标准的输入和输出设备。  
> 默认输入设备是键盘，输出设备是显示器。

* System.in的类型是InputStream.
* System.out的类型是PrintStream,是OutputStream的子类FilterOutputStream 的子类.

#### 三种键盘录入方式

* main方法的args接收参数
* System.in通过BufferedReader进行包装
	- BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
* Scanner
	- Scanner sc = new Scanner(System.in);

#### 输出语句的原理

```java
System.out.println("helloworld");

PrintStream ps = System.out;
ps.println("helloworld");

// 把System.out用字符缓冲流包装一下使用
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
```

### 随机访问流

RandomAccessFile类不属于流，是Object类的子类。  
但它融合了InputStream和OutputStream的功能。  
支持对文件的随机访问读取和写入。  

```java
private static void write() throws IOException {
	// 创建随机访问流对象
	RandomAccessFile raf = new RandomAccessFile("raf.txt", "rw");

	// 怎么玩呢?
	raf.writeInt(100);
	raf.writeChar('a');
	raf.writeUTF("中国");

	raf.close();
}

private static void read() throws IOException {
	// 创建随机访问流对象
	RandomAccessFile raf = new RandomAccessFile("raf.txt", "rw");

	int i = raf.readInt();
	System.out.println(i);
	// 该文件指针可以通过 getFilePointer方法读取，并通过 seek 方法设置。
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	char ch = raf.readChar();
	System.out.println(ch);
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	String s = raf.readUTF();
	System.out.println(s);
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	// 我不想重头开始了，我就要读取a，怎么办呢?
	raf.seek(4);
	ch = raf.readChar();
	System.out.println(ch);
}
```

### 合并流

把多个输入流的数据写到一个输出流中

* SequenceInputStream(InputStream s1, InputStream s2) 
* SequenceInputStream(Enumeration<? extends InputStream> e) 

```java
// 两个
InputStream s1 = new FileInputStream("ByteArrayStreamDemo.java");
InputStream s2 = new FileInputStream("DataStreamDemo.java");
SequenceInputStream sis = new SequenceInputStream(s1, s2);

// 多个
// SequenceInputStream(Enumeration e)
// 通过简单的回顾我们知道了Enumeration是Vector中的一个方法的返回值类型。
// Enumeration<E> elements()
Vector<InputStream> v = new Vector<InputStream>();
InputStream s1 = new FileInputStream("ByteArrayStreamDemo.java");
InputStream s2 = new FileInputStream("CopyFileDemo.java");
InputStream s3 = new FileInputStream("DataStreamDemo.java");
v.add(s1);
v.add(s2);
v.add(s3);
Enumeration<InputStream> en = v.elements();
SequenceInputStream sis = new SequenceInputStream(en);
BufferedOutputStream bos = new BufferedOutputStream(
		new FileOutputStream("Copy.java"));

// 如何写读写呢，其实很简单，你就按照以前怎么读写，现在还是怎么读写
byte[] bys = new byte[1024];
int len = 0;
while ((len = sis.read(bys)) != -1) {
	bos.write(bys, 0, len);
}

bos.close();
sis.close();
```

### 序列化流

可以把对象写入文本文件或者在网络中传输

* 序列化流：把对象按照流一样的方式存入文本文件或者在网络中传输。对象 -- 流数据(ObjectOutputStream)
* 反序列化流:把文本文件中的流对象数据或者网络中的流对象数据还原成对象。流数据 -- 对象(ObjectInputStream)

```java
private static void read() throws IOException, ClassNotFoundException {
	// 创建反序列化对象
	ObjectInputStream ois = new ObjectInputStream(new FileInputStream(
			"oos.txt"));

	// 还原对象
	Object obj = ois.readObject();

	// 释放资源
	ois.close();

	// 输出对象
	System.out.println(obj);
}

private static void write() throws IOException {
	// 创建序列化流对象
	ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(
			"oos.txt"));

	// 创建对象
	Person p = new Person("林青霞", 27);

	// public final void writeObject(Object obj)
	oos.writeObject(p);

	// 释放资源
	oos.close();
}
```

#### 序列化和反序列化

对象序列化是将对象状态转换为可保持或传输的过程。一般的格式是与平台无关的二进制流，可以将这种二进制流持久保存在磁盘上，也可以通过网络将这种二进制流传输到另一个网络结点。  
对象反序列化，是指把这种二进制流数据还原成对象。

#### 如何实现序列化

* 让被序列化的对象所属类实现序列化接口。
* 该接口是一个标记接口。没有功能需要实现。
* 使用transient关键字声明不需要序列化的成员变量

**序列化数据后，再次修改类文件，读取数据会出问题，如何解决呢?**

在类文件中，给出一个固定的序列化id值。

### Properties集合

是一个集合类，Hashtable的子类

#### Properties和IO流的结合使用

* 把键值对形式的文本文件内容加载到集合中
	- public void load(Reader reader)
	- public void load(InputStream inStream)
* 把集合中的数据存储到文本文件中
	- public void store(Writer writer,String comments)
	- public void store(OutputStream out,String comments)

```java
private static void myStore() throws IOException {
	// 创建集合对象
	Properties prop = new Properties();

	prop.setProperty("林青霞", "27");
	prop.setProperty("武鑫", "30");
	prop.setProperty("刘晓曲", "18");
	
	//public void store(Writer writer,String comments):把集合中的数据存储到文件
	Writer w = new FileWriter("name.txt");
	prop.store(w, "helloworld");
	w.close();
}

private static void myLoad() throws IOException {
	Properties prop = new Properties();

	// public void load(Reader reader):把文件中的数据读取到集合中
	// 注意：这个文件的数据必须是键值对形式
	Reader r = this.getClass().getResourceAsStream("prop.txt");// 这里提供过getResourceAsStream()方法获取
	prop.load(r);
	r.close();

	System.out.println("prop:" + prop);
}
```

## NIO和Netty

> JDK4出现NIO。NIO使用了不同的方式来处理输入输出，采用内存映射文件的方式，将文件或者文件的一段区域映射到内存中，就可以像访问内存一样的来访问文件了，这种方式效率比旧IO要高很多。

* Path:路径
* Paths:有一个静态方法返回一个路径
	- public static Path get(URI uri)
* Files:提供了静态方法供我们使用
	- public static long copy(Path source,OutputStream out):复制文件
	- public static Path write(Path path,Iterable<? extends CharSequence> lines,Charset cs,OpenOption... options)

```java
Files.copy(Paths.get("ByteArrayStreamDemo.java"), new FileOutputStream("Copy.java"));

ArrayList<String> array = new ArrayList<String>();
array.add("hello");
array.add("world");
array.add("java");
Files.write(Paths.get("array.txt"), array, Charset.forName("GBK"));
```

### I/O基础入门

Java1.4之前的早期版本，Java对I/O的支持并不完善，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和困难。

* 没有数据缓冲区，I/O性能存在问题
* 没有C或者C++中的Channel概念，只有输入和输出流
* 同步阻塞式I/O通信（BIO），通常会导致通信线程被长时间阻塞
* 支持的字符集有限，硬件可移植性不好

#### Linux网络I/O模型

Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor（fd，文件描述符）。
而对一个socket的读写也会有相应的描述符，称为socketfd（socket描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。

根据UNIX网络编程对I/O模型的分类，UNIX提供了5种I/O模型：

_阻塞I/O模型：_

最常用的I/O模型就是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。以套接字接口为例来讲解此模型：

在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，
在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型。

![阻塞I/O模型](/static/img/2017-01-15-IO流/2018-07-16-12-56-00.png)

_非阻塞I/O模型：_

recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来。

![非阻塞I/O模型](/static/img/2017-01-15-IO流/2018-07-16-12-57-16.png)

_I/O复用模型：_

Linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。
select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。  
Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。

![I/O复用模型](/static/img/2017-01-15-IO流/2018-07-16-12-58-15.png)

_信号驱动I/O模型：_

首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。
当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。

![信号驱动I/O模型](/static/img/2017-01-15-IO流/2018-07-16-12-59-30.png)

_异步I/O：_

告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。

这种模型与信号驱动模型的主要区别是：

信号驱动I/O由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成。

![异步I/O](/static/img/2017-01-15-IO流/2018-07-16-13-00-12.png)

#### I/O多路复用技术

在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。

I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。
与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。

I/O多路复用的主要应用场景：

* 服务器需要同时处理多个处于监听状态或者多个连接状态的套接字；
* 服务器需要同时处理多种网络协议的套接字。

I/O多路复用的系统调用有select、pselect、poll、epoll，在Linux网络编程过程中，很长一段时间都使用select做轮询和网络事件通知，
然而select的一些固有缺陷导致了它的应用受到了很大的限制，最终Linux不得不在新的内核版本中寻找select的替代方案，最终选择了epoll。

epoll与select的原理比较类似，为了克服select的缺点，epoll作了很多重大改进：

1. 支持一个进程打开的socket描述符（FD）不受限制（仅受限于操作系统的最大文件句柄数）。
	* select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。对于那些需要支持上万个TCP连接的大型服务器来说显然太少了。
	* epoll并没有这个限制，它所支持的FD上限是操作系统的最大文件句柄数，这个数字远远大于1024。
2. I/O效率不会随着FD数目的增加而线性下降。
	* 传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，由于网络延时或者链路空闲，任一时刻只有少部分的socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。
	* epoll不存在这个问题，它只会对“活跃”的socket进行操作-这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的，那么，只有“活跃”的socket才会主动的去调用callback函数，其他idle状态socket则不会。在这点上，epoll实现了一个伪AIO。
	* 针对epoll和select性能对比的benchmark测试表明：如果所有的socket都处于活跃态-例如一个高速LAN环境，epoll并不比select/poll效率高太多；相反，如果过多使用epoll_ctl，效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境，epoll的效率就远在select/poll之上了。
3. 使用mmap加速内核与用户空间的消息传递。
	* 无论是select，poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存复制就显得非常重要，epoll是通过内核和用户空间mmap同一块内存实现。
4. epoll的API更加简单。
	* 包括创建一个epoll描述符、添加监听事件、阻塞等待所监听的事件发生，关闭epoll描述符等。

用来克服select/poll缺点的方法不只有epoll，epoll只是一种Linux的实现方案。在freeBSD下有kqueue，而dev/poll是最古老的Solaris的方案，使用难度依次递增。

### NIO入门

#### 传统的BIO编程

网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），
客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。

在基于传统同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功之后，双方通过输入和输出流进行同步阻塞式通信。

同步阻塞I/O服务端通信模型（一客户端一线程）：

![同步阻塞I/O服务端通信模型（一客户端一线程）](/static/img/2017-01-15-IO流/2018-07-16-13-32-05.png)

采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，
处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的一请求一应答通信模型。

该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1：1的正比关系，
由于线程是Java虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，
系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。

#### 伪异步I/O编程

采用线程池和任务队列可以实现一种叫做伪异步的I/O通信框架。

当有新的客户端接入的时候，将客户端的Socket封装成一个Task投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的任务进行处理。
由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。

伪异步I/O服务端通信模型（M：N）：

![伪异步I/O服务端通信模型（M：N）](/static/img/2017-01-15-IO流/2018-07-16-14-06-44.png)

伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。
但是由于它底层的通信依然采用同步阻塞模型，因此无法从根本上解决问题。

#### 伪异步I/O弊端分析

当对Socket的输入流进行读取操作的时候，它会一直阻塞下去，直到发生如下三种事件。

* 有数据可读；
* 可用数据已经读取完毕；
* 发生空指针或者I/O异常。

这意味着当对方发送请求或者应答消息比较缓慢、或者网络传输较慢时，读取输入流一方的通信线程将被长时间阻塞。

当调用OutputStream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。

读和写操作都是同步阻塞的，阻塞的时间取决于对方I/O线程的处理速度和网络I/O的传输速度。

### NIO编程

#### NIO类库简介

NIO弥补了原来同步阻塞I/O的不足，它在标准Java代码中提供了高速的、面向块的I/O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO不用使用本机代码就可以利用低级优化，这是原来的I/O包所无法做到的。

##### 缓冲区Buffer

Buffer是一个对象，它包含一些要写入或者要读出的数据。

在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中，可以将数据直接写入或者将数据直接读到Stream对象中。

在NIO库中，所有数据都是用缓冲区处理的。

* 在读取数据时，它是直接读到缓冲区中的；
* 在写入数据时，写入到缓冲区中。

任何时候访问NIO中的数据，都是通过缓冲区进行操作。

缓冲区实质上是一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。

* ByteBuffer：字节缓冲区
* CharBuffer：字符缓冲区
* ShortBuffer：短整型缓冲区
* IntBuffer：整形缓冲区
* LongBuffer：长整形缓冲区
* FloatBuffer：浮点型缓冲区
* DoubleBuffer：双精度浮点型缓冲区

![Buffer继承关系图](/static/img/2017-01-15-IO流/2018-07-16-16-11-07.png)

##### 通道Channel

Channel是一个通道，可以通过它读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。
通道与流的不同之处在于通道是双向的，流只是在一个方向上移动，而且通道可以用于读、写或者同时用于读写。

因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。特别是在UNIX网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。

![Channel继承关系类图](/static/img/2017-01-15-IO流/2018-07-16-16-22-02.png)

前三层主要是Channel接口，用于定义它的功能，后面是一些具体的功能类（抽象类），从类图可以看出，实际上Channel可以分为两大类：  
分别是用于网络读写的SelectableChannel和用于文件操作的FileChannel。

##### 多路复用器Selector

多路复用器提供选择已经就绪的任务的能力。

简单来讲，Selector会不断地轮询注册在其上的Channel，如果某个Channel上面有新的TCP连接接入、读和写事件，这个Channel就处于就绪状态，
会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。

一个多路复用器Selector可以同时轮询多个Channel，由于JDK使用了epoll()代替传统的select实现，所以它并没有最大连接句柄1024/2048的限制。
这也就意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端，这确实是个非常巨大的进步。

#### NIO服务端序列图

NIO服务端通信序列图：

![NIO服务端通信序列图](/static/img/2017-01-15-IO流/2018-07-16-16-28-10.png)

NIO客户端创建序列图：

![NIO客户端创建序列图](/static/img/2017-01-15-IO流/2018-07-16-19-31-34.png)

使用NIO编程的优点总结如下。

* 客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECT等待后续结果，不需要像之前的客户端那样被同步阻塞。
* SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样I/O通信线程就可以处理其他的链路，不需要同步等待这个链路可用。
* 线程模型的优化：由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制（只受限于操作系统的最大句柄数或者对单个进程的句柄限制），这意味着一个Selector线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降，因此，它非常适合做高性能、高负载的网络服务器。

NIO进行服务端开发的步骤：

1. 创建ServerSocketChannel，配置它为非阻塞模式；
2. 绑定监听，配置TCP参数，例如backlog大小；
3. 创建一个独立的I/O线程，用于轮询多路复用器Selector；
4. 创建Selector，将之前创建的ServerSocketChannel注册到Selector上，监听SelectionKey.ACCEPT；
5. 启动I/O线程，在循环体中执行Selector.select()方法，轮询就绪的Channel；
6. 当轮询到了处于就绪状态的Channel时，需要对其进行判断，如果是OP_ACCEPT状态，说明是新的客户端接入，则调用ServerSocketChannel.accept()方法接受新的客户端；
7. 设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数；
8. 将SocketChannel注册到Selector，监听OP_READ操作位；
9. 如果轮询的Channel为OP_READ，则说明SocketChannel中有新的就绪的数据包需要读取，则构造ByteBuffer对象，读取数据包；
10. 如果轮询的Channel为OP_WRITE，说明还有数据没有发送完成，需要继续发送。

没有考虑半包等问题的代码：

```java
public static void main(String[] args) throws IOException {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}
	}
	MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port);
	new Thread(timeServer, "NIO-MultiplexerTimeServer-001").start();
}
public class MultiplexerTimeServer implements Runnable {
    private Selector selector;
    private ServerSocketChannel serverSocketChannel;
    private volatile boolean stop;
    /**
     * 初始化多路复用器、绑定监听端口
     */
    public MultiplexerTimeServer(int port) {
        try {
            selector = Selector.open();
            serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            System.out.println("The time server is start in port : " + port);
        } catch (IOException e) {
            e.printStackTrace();
            System.exit(1);
        }
    }
    public void stop() {
        this.stop = true;
    }
    @Override
    public void run() {
        while (!stop) {
            try {
                selector.select(1000);
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> it = selectedKeys.iterator();
                SelectionKey key = null;
                while (it.hasNext()) {
                    key = it.next();
                    it.remove();
                    try {
                        handleInput(key);
                    } catch (Exception e) {
                        if (key != null) {
                            key.cancel();
                            if (key.channel() != null)
                                key.channel().close();
                        }
                    }
                }
            } catch (Throwable t) {
                t.printStackTrace();
            }
        }
        // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源
        if (selector != null) {
            try {
                selector.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    private void handleInput(SelectionKey key) throws IOException {
        if (key.isValid()) {
            // 处理新接入的请求消息
            if (key.isAcceptable()) {
                // Accept the new connection
                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                SocketChannel socketChannel = serverSocketChannel.accept();
                socketChannel.configureBlocking(false);
                // Add the new connection to the selector
                socketChannel.register(selector, SelectionKey.OP_READ);
            }
            if (key.isReadable()) {
                // Read the data
                SocketChannel socketChannel = (SocketChannel) key.channel();
                ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                int readBytes = socketChannel.read(readBuffer);
                if (readBytes > 0) {
                    readBuffer.flip();
                    byte[] bytes = new byte[readBuffer.remaining()];
                    readBuffer.get(bytes);
                    String body = new String(bytes, "UTF-8");
                    System.out.println("The time server receive order : " + body);
                    String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body) ?
                            new java.util.Date(System.currentTimeMillis()).toString() :
                            "BAD ORDER";
                    doWrite(socketChannel, currentTime);
                } else if (readBytes < 0) {
                    // 对端链路关闭
                    key.cancel();
                    socketChannel.close();
                }
                // 读到0字节，忽略
            }
        }
    }
    private void doWrite(SocketChannel channel, String response)
            throws IOException {
        if (response != null && response.trim().length() > 0) {
            byte[] bytes = response.getBytes();
            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);
            writeBuffer.put(bytes);
            writeBuffer.flip();
            channel.write(writeBuffer);
        }
    }
}
```

```java
public static void main(String[] args) {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}
	}
	new Thread(new TimeClientHandle("127.0.0.1", port), "TimeClient-001").start();
}

public class TimeClientHandle implements Runnable {
    private String host;
    private int port;
    private Selector selector;
    private SocketChannel socketChannel;
    private volatile boolean stop;
    public TimeClientHandle(String host, int port) {
        this.host = host == null ? "127.0.0.1" : host;
        this.port = port;
        try {
            selector = Selector.open();
            socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(false);
        } catch (IOException e) {
            e.printStackTrace();
            System.exit(1);
        }
    }
    @Override
    public void run() {
        try {
            doConnect();
        } catch (IOException e) {
            e.printStackTrace();
            System.exit(1);
        }
        while (!stop) {
            try {
                selector.select(1000);
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> it = selectedKeys.iterator();
                SelectionKey key = null;
                while (it.hasNext()) {
                    key = it.next();
                    it.remove();
                    try {
                        handleInput(key);
                    } catch (Exception e) {
                        if (key != null) {
                            key.cancel();
                            if (key.channel() != null)
                                key.channel().close();
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
                System.exit(1);
            }
        }
        // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源
        if (selector != null) {
            try {
                selector.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
    private void handleInput(SelectionKey key) throws IOException {
        if (key.isValid()) {
            // 判断是否连接成功
            SocketChannel socketChannel = (SocketChannel) key.channel();
            if (key.isConnectable()) {
                if (socketChannel.finishConnect()) {
                    socketChannel.register(selector, SelectionKey.OP_READ);
                    doWrite(socketChannel);
                } else {
                    System.exit(1);// 连接失败，进程退出
                }
            }
            if (key.isReadable()) {
                ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                int readBytes = socketChannel.read(readBuffer);
                if (readBytes > 0) {
                    readBuffer.flip();
                    byte[] bytes = new byte[readBuffer.remaining()];
                    readBuffer.get(bytes);
                    String body = new String(bytes, "UTF-8");
                    System.out.println("Now is : " + body);
                    this.stop = true;
                } else if (readBytes < 0) {
                    // 对端链路关闭
                    key.cancel();
                    socketChannel.close();
                }
                // 读到0字节，忽略
            }
        }
    }
    private void doConnect() throws IOException {
        // 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答
        if (socketChannel.connect(new InetSocketAddress(host, port))) {
            socketChannel.register(selector, SelectionKey.OP_READ);
            doWrite(socketChannel);
        } else {
            socketChannel.register(selector, SelectionKey.OP_CONNECT);
        }
    }
    private void doWrite(SocketChannel socketChannel) throws IOException {
        byte[] req = "QUERY TIME ORDER".getBytes();
        ByteBuffer writeBuffer = ByteBuffer.allocate(req.length);
        writeBuffer.put(req);
        writeBuffer.flip();
        socketChannel.write(writeBuffer);
        if (!writeBuffer.hasRemaining()) {
            System.out.println("Send order 2 server succeed.");
        }
    }

}
```

#### AIO编程

JDK1.7升级了NIO类库，升级后的NIO类库被称为NIO2.0，Java正式提供了异步文件I/O操作，同时提供了与UNIX网络编程事件驱动I/O对应的AIO。

NIO2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供两种方式获取获取操作结果。

* 通过java.util.concurrent.Future类来表示异步操作的结果；
* 在执行异步操作的时候传入一个java.nio.channels。

CompletionHandler接口的实现类作为操作完成的回调。

NIO2.0的异步套接字通道是真正的异步非阻塞I/O，它对应UNIX网络编程中的事件驱动I/O（AIO），
它不需要通过多路复用器（Selector）对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。

由JDK底层的ThreadPoolExecutor进行调度并驱动读写操作，不需要开线程，因此更加简单。

没有考虑半包等问题的代码：

```java
public static void main(String[] args) throws IOException {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}
	}
	AsyncTimeServerHandler timeServer = new AsyncTimeServerHandler(port);
	new Thread(timeServer, "AIO-AsyncTimeServerHandler-001").start();
}
public class AsyncTimeServerHandler implements Runnable {
    private int port;
    CountDownLatch latch;
    AsynchronousServerSocketChannel asynchronousServerSocketChannel;
    public AsyncTimeServerHandler(int port) {
        this.port = port;
        try {
            asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();
            asynchronousServerSocketChannel.bind(new InetSocketAddress(port));
            System.out.println("The time server is start in port : " + port);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void run() {
        latch = new CountDownLatch(1);
        doAccept();
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public void doAccept() {
        asynchronousServerSocketChannel.accept(this, new AcceptCompletionHandler());
    }
}
public class AcceptCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, AsyncTimeServerHandler> {
    @Override
    public void completed(AsynchronousSocketChannel result, AsyncTimeServerHandler asyncTimeServerHandler) {
        asyncTimeServerHandler.asynchronousServerSocketChannel.accept(asyncTimeServerHandler, this);
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        result.read(buffer, buffer, new ReadCompletionHandler(result));
    }
    @Override
    public void failed(Throwable exc, AsyncTimeServerHandler attachment) {
        exc.printStackTrace();
        attachment.latch.countDown();
    }
}

public class ReadCompletionHandler implements CompletionHandler<Integer, ByteBuffer> {
    private AsynchronousSocketChannel channel;
    public ReadCompletionHandler(AsynchronousSocketChannel channel) {
        if (this.channel == null) {
            this.channel = channel;
        }
    }
    @Override
    public void completed(Integer result, ByteBuffer attachment) {
        attachment.flip();
        byte[] body = new byte[attachment.remaining()];
        attachment.get(body);
        try {
            String req = new String(body, "UTF-8");
            System.out.println("The time server receive order : " + req);
            String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(req) ? new java.util.Date(
                    System.currentTimeMillis()).toString() : "BAD ORDER";
            doWrite(currentTime);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }
    private void doWrite(String currentTime) {
        if (currentTime != null && currentTime.trim().length() > 0) {
            byte[] bytes = (currentTime).getBytes();
            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);
            writeBuffer.put(bytes);
            writeBuffer.flip();
            channel.write(writeBuffer, writeBuffer,
                    new CompletionHandler<Integer, ByteBuffer>() {
                        @Override
                        public void completed(Integer result, ByteBuffer buffer) {
                            // 如果没有发送完成，继续发送
                            if (buffer.hasRemaining()) {
                                channel.write(buffer, buffer, this);
                            }
                        }
                        @Override
                        public void failed(Throwable exc, ByteBuffer attachment) {
                            try {
                                channel.close();
                            } catch (IOException e) {
                                // ingnore on close
                            }
                        }
                    });
        }
    }
    @Override
    public void failed(Throwable exc, ByteBuffer attachment) {
        try {
            this.channel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public static void main(String[] args) {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}

	}
	new Thread(new AsyncTimeClientHandler("127.0.0.1", port),"AIO-AsyncTimeClientHandler-001").start();

}

public class AsyncTimeClientHandler implements CompletionHandler<Void, AsyncTimeClientHandler>, Runnable {
    private AsynchronousSocketChannel client;
    private String host;
    private int port;
    private CountDownLatch latch;
    public AsyncTimeClientHandler(String host, int port) {
        this.host = host;
        this.port = port;
        try {
            client = AsynchronousSocketChannel.open();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void run() {
        latch = new CountDownLatch(1);
        client.connect(new InetSocketAddress(host, port), this, this);
        try {
            latch.await();
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
        try {
            client.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void completed(Void result, AsyncTimeClientHandler attachment) {
        byte[] req = "QUERY TIME ORDER".getBytes();
        ByteBuffer writeBuffer = ByteBuffer.allocate(req.length);
        writeBuffer.put(req);
        writeBuffer.flip();
        client.write(writeBuffer, writeBuffer,
                new CompletionHandler<Integer, ByteBuffer>() {
                    @Override
                    public void completed(Integer result, ByteBuffer buffer) {
                        if (buffer.hasRemaining()) {
                            client.write(buffer, buffer, this);
                        } else {
                            ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                            client.read(
                                    readBuffer,
                                    readBuffer,
                                    new CompletionHandler<Integer, ByteBuffer>() {
                                        @Override
                                        public void completed(Integer result, ByteBuffer buffer) {
                                            buffer.flip();
                                            byte[] bytes = new byte[buffer.remaining()];
                                            buffer.get(bytes);
                                            String body;
                                            try {
                                                body = new String(bytes, "UTF-8");
                                                System.out.println("Now is : " + body);
                                                latch.countDown();
                                            } catch (UnsupportedEncodingException e) {
                                                e.printStackTrace();
                                            }
                                        }
                                        @Override
                                        public void failed(Throwable exc, ByteBuffer attachment) {
                                            try {
                                                client.close();
                                                latch.countDown();
                                            } catch (IOException e) {
                                                // ingnore on close
                                            }
                                        }
                                    });
                        }
                    }
                    @Override
                    public void failed(Throwable exc, ByteBuffer attachment) {
                        try {
                            client.close();
                            latch.countDown();
                        } catch (IOException e) {
                            // ingnore on close
                        }
                    }
                });
    }
    @Override
    public void failed(Throwable exc, AsyncTimeClientHandler attachment) {
        exc.printStackTrace();
        try {
            client.close();
            latch.countDown();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 4种I/O对比

##### 概念

**异步非阻塞I/O**

在早期的JDK1.4和1.5 update10版本之前，JDK的Selector基于select/poll模型实现，它是基于I/O复用技术的非阻塞I/O，不是异步I/O。  
在JDK1.5 update10和Linux core2.6以上版本，Sun优化了Selctor的实现，它在底层使用epoll替换了select/poll，上层的API并没有变化，可以认为是JDK NIO的一次性能优化，但是它仍旧没有改变I/O的模型。  
由JDK1.7提供的NIO2.0，新增了异步的套接字通道，它是真正的异步I/O，在异步I/O操作的时候可以传递信号变量，当操作完成之后会回调相关的方法，异步I/O也被称为AIO。

**多路复用器Selector**

Java NIO的实现关键是多路复用I/O技术，多路复用的核心就是通过Selector来轮询注册在其上的Channel，当发现某个或者多个Channel处于就绪状态后，从阻塞状态返回就绪的Channel的选择键集合，进行I/O操作。

**伪异步I/O**

在通信线程和业务线程之间做个缓冲区，这个缓冲区用于隔离I/O线程和业务线程间的直接访问，这样业务线程就不会被I/O线程阻塞。

对于后端的业务侧来说，将消息或者Task放到线程池后就返回了，它不再直接访问I/O线程或者进行I/O读写，这样也就不会被同步阻塞。

类似的设计还包括前端启动一组线程，将接收的客户端封装成Task，放到后端的线程池执行，用于解决一连接一线程问题。

##### 对比

几种I/O模型的功能和特性对比：

![几种I/O模型的功能和特性对比](/static/img/2017-01-15-IO流/2018-07-17-14-23-24.png)

具体选择什么样的I/O模型或者NIO框架，完全基于业务的实际应用场景和性能诉求：

* 如果客户端并发连接数不多，周边对接的网元不多，服务器的负载也不重，那就完全没必要选择NIO做服务端；
* 如果是相反情况，那就要考虑选择合适的NIO框架进行开发。

#### 原生NIO与Netty对比

开发出高质量的NIO程序并不是一件简单的事情，除去NIO固有的复杂性和BUG不谈，作为一个NIO服务端，需要能够处理网络的闪断、客户端的重复接入、客户端的安全认证、消息的编解码、半包读写等情况，
如果你没有足够的NIO编程经验积累，一个NIO框架的稳定往往需要半年甚至更长的时间。更为糟糕的是，一旦在生产环境中发生问题，往往会导致跨节点的服务调用中断，严重的可能会导致整个集群环境都不可用，需要重启服务器，这种非正常停机会带来巨大的损失。

从可维护性角度看，由于NIO采用了异步非阻塞编程模型，而且是一个I/O线程处理多条链路，它的调试和跟踪非常麻烦，特别是生产环境中的问题，我们无法进行有效的调试和跟踪，往往只能靠一些日志来辅助分析，定位难度很大。

##### 不选择原生NIO编程的原因

1. NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。
2. 需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序。
3. 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。
4. JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该BUG发生概率降低了一些而已，它并没有被根本解决。

##### 为什么选择Netty

Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证。  
例如Hadoop的RPC框架avro使用Netty作为底层通信框架；很多其他业界主流的RPC框架，也使用Netty来构建高性能的异步通信能力。

* PI使用简单，开发门槛低；
* 功能强大，预置了多种编解码功能，支持多种主流协议；
* 定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；
* 性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；
* 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；
* 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；
* 经历了大规模的商业应用考验，质量得到验证。
	* 在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它已经完全能够满足不同行业的商业应用了。

正是因为这些优点，Netty逐渐成为Java NIO编程的首选框架。

### TCP粘包/拆包问题的解决

#### TCP粘包/拆包

TCP是个“流”协议，所谓流，就是没有界限的一串数据。

TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，
一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

TCP粘包/拆包问题：

![TCP粘包/拆包问题](/static/img/2017-01-15-IO流/2018-07-17-17-10-16.png)

1. 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；
2. 服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；
3. 服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；
4. 服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。
5. 如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。

#### TCP粘包/拆包问题原因

1. 应用程序write写入的字节大小大于套接口发送缓冲区大小；
2. 进行MSS大小的TCP分段；
3. 以太网帧的payload大于MTU进行IP分片。

![TCP粘包/拆包问题原因](/static/img/2017-01-15-IO流/2018-07-17-17-14-07.png)

#### 解决策略

由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，
这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。

1. 消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
2. 在包尾增加回车换行符进行分割，例如FTP协议；
3. 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；
4. 更复杂的应用层协议。

#### 利用LineBasedFrameDecoder解决TCP粘包问题

为了解决TCP粘包/拆包导致的半包读写问题，Netty默认提供了多种编解码器用于处理半包，只要能熟练掌握这些类库的使用，TCP粘包问题从此会变得非常容易，
你甚至不需要关心它们，这也是其他NIO框架和JDK原生的NIO API所无法匹敌的。

通过Netty的LineBasedFrameDecoder和StringDecoder来解决TCP粘包问题。

```java
public class TimeServer {
    public void bind(int port) throws Exception {
        // 配置服务端的NIO线程组
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 1024)
                    .childHandler(new ChildChannelHandler());
            // 绑定端口，同步等待成功
            ChannelFuture f = serverBootstrap.bind(port).sync();
            // 等待服务端监听端口关闭
            f.channel().closeFuture().sync();
        } finally {
            // 优雅退出，释放线程池资源
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
    private class ChildChannelHandler extends ChannelInitializer<SocketChannel> {
        @Override
        protected void initChannel(SocketChannel socketChannel) throws Exception {
			// 编解码器
            socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));
            socketChannel.pipeline().addLast(new StringDecoder());
            socketChannel.pipeline().addLast(new TimeServerHandler());
        }
    }
    public static void main(String[] args) throws Exception {
        int port = 8080;
        if (args != null && args.length > 0) {
            try {
                port = Integer.valueOf(args[0]);
            } catch (NumberFormatException e) {
                // 采用默认值
            }
        }
        new TimeServer().bind(port);
    }
}

public class TimeServerHandler extends ChannelHandlerAdapter {
    private int counter;
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        String body = (String) msg;
        System.out.println("The time server receive order : " + body + " ; the counter is : " + ++counter);
        String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body)
                ? new java.util.Date(System.currentTimeMillis()).toString()
                : "BAD ORDER";
        currentTime = currentTime + System.getProperty("line.separator");
        ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes());
        ctx.writeAndFlush(resp);
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        ctx.close();
    }
}
```

```java
public class TimeClient {
    public void connect(int port, String host) throws Exception {
        // 配置客户端NIO线程组
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap
                    .group(group)
                    .channel(NioSocketChannel.class)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        public void initChannel(SocketChannel ch)
                                throws Exception {
                            ch.pipeline().addLast(new LineBasedFrameDecoder(1024));
                            ch.pipeline().addLast(new StringDecoder());
                            ch.pipeline().addLast(new TimeClientHandler());
                        }
                    });
            // 发起异步连接操作
            ChannelFuture f = bootstrap.connect(host, port).sync();
            // 当代客户端链路关闭
            f.channel().closeFuture().sync();
        } finally {
            // 优雅退出，释放NIO线程组
            group.shutdownGracefully();
        }
    }
    public static void main(String[] args) throws Exception {
        int port = 8080;
        if (args != null && args.length > 0) {
            try {
                port = Integer.valueOf(args[0]);
            } catch (NumberFormatException e) {
                // 采用默认值
            }
        }
        new TimeClient().connect(port, "127.0.0.1");
    }
}

public class TimeClientHandler extends ChannelHandlerAdapter {
    private static final Logger LOGGER = Logger.getLogger(TimeClientHandler.class.getName());
    private int counter;
    private byte[] req;
    /**
     * Creates a client-side handler.
     */
    public TimeClientHandler() {
        req = ("QUERY TIME ORDER" + System.getProperty("line.separator")).getBytes();
    }
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        ByteBuf message = null;
        for (int i = 0; i < 100; i++) {
            message = Unpooled.buffer(req.length);
            message.writeBytes(req);
            ctx.writeAndFlush(message);
        }
    }
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        String body = (String) msg;
        System.out.println("Now is : " + body + " ; the counter is : " + ++counter);
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // 释放资源
        LOGGER.warning("Unexpected exception from downstream : " + cause.getMessage());
        ctx.close();
    }
}
```

LineBasedFrameDecoder的工作原理是它依次遍历ByteBuf中的可读字节，判断看是否有"\n"或者"\r\n"，
如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。
它是以换行符为结束标志的解码器，支持携带结束符或者不携带结束符两种解码方式，同时支待配置单行的最大长度。
如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读到的异常码流。

StringDecoder的功能非常简单，就是将接收到的对象转换成字符串，然后继续调用后面的Handler，LineBasedFrameDecoder+StringDecoder组合就是按行切换的文本解码器，它被设计用来⽀持TCP的粘包和拆包。

Netty提供了多种⽀持 TCP 粘包/拆包的解码器, 用来满⾜用户的不同诉求。

#### 分隔符和定长解码器

DelimiterBasedFrameDecoder和FixedLengthFrameDecoder，前者可以自动完成以分隔符做结束标志的消息的解码，后者可以自动完成对定长消息的解码，它们都能解决TCP粘包／拆包导致的读半包问题。

只要将DelimiterBasedFrameDecoder或FixedLengthFrameDecoder添加到对应ChannelPipeline的起始位即可。

```java
// 在传输数据时需要追加分隔符字符。
// server
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch)
					throws Exception {
				ByteBuf delimiter = Unpooled.copiedBuffer("$_".getBytes());
				ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
				ch.pipeline().addLast(new StringDecoder());
				ch.pipeline().addLast(new EchoServerHandler());
			}
		});
// client
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCP_NODELAY, true)
		.handler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ByteBuf delimiter = Unpooled.copiedBuffer("$_".getBytes());
				ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
				ch.pipeline().addLast(new StringDecoder());
				ch.pipeline().addLast(new EchoClientHandler());
			}
		});
```

使用DelimiterBasedFrameDecoder可以自动对采用分隔符做码流结束标识的消息进行解码。

```java
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ch.pipeline().addLast(new FixedLengthFrameDecoder(20));
				ch.pipeline().addLast(new StringDecoder());
				ch.pipeline().addLast(new EchoServerHandler());
			}
		});
```

利用FixedLengthFrameDecoder解码器，无论一次接收到多少数据报，它都会按照构造函数中设置的固定长度进行解码，
如果是半包消息，FixedLengthFrameDecoder会缓存半包消息并等待下个包到达后进行拼包，直到读取到一个完整的包。

### 编辑码技术

Java 序列化的目的主要有两个：

* 网络传输
* 对象持久化

当进行远程跨进程服务调用时，需要把被传输的Java对象编码为字节数组或者ByteBuffer对象。
而当远桯服务读取到ByteBuffer对象或者字节数组时，需要将其解码为发送时的Java对象。这被称为Java对象编解码技术。

评判一个编解码框架的优劣时，往往会考虑以下几个因素：

* 是否支持跨语言，支持的语言种类是否丰富；
* 一编码后的码流大小；
* 编解码的性能；
* 类库是否小巧，APl使用是否方便；
* 使用者需要手工开发的工作量和难度。

#### Java序列化的缺点

* 无法跨语言
	* 最致命的问题
* 序列化后码流太大
	* 1
* 序列化性能太低
* 序列化性能太低

```java
public byte[] codeC() {
	ByteBuffer buffer = ByteBuffer.allocate(1024);
	byte[] value = this.userName.getBytes();
	buffer.putInt(value.length);
	buffer.put(value);
	buffer.putInt(this.userID);
	buffer.flip();
	byte[] result = new byte[buffer.remaining()];
	buffer.get(result);
	return result;
}
```

序列化性能对比图：

![序列化性能对比图](/static/img/2017-01-15-IO流/2018-07-18-11-10-37.png)

#### 业界主流的编解码框架

##### Google的Protobuf

Protobuf全称Google Protocol Buffers,它由谷歌开源而来，在谷歌内部久经考验。
它将数据结构以proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。

* 结构化数据存储格式(XML,JSON等）；
* 高效的编解码性能；
* 语言无关、平台无关、扩展性好；
* 官方支持Java、C++和Python三种语言。

尽管XML的可读性和可扩展性非常好，也非常适合描述数据结构，但是XML解析的时间开销和XML为了可读性而牺牲的空间开销都非常大，因此不适合做高性能的通信协议。
Protobuf使用二进制编码，在空间和性能上具有更大的优势。

Protobuf另一个比较吸引人的地方就是它的数据描述文件和代码生成机制，利用数据描述文件对数据结构进行说明的优点如下：

* 文本化的数据结构描述语言，可以实现语言和平台无关，特别适合异构系统间的集成；
* 通过标识字段的顺序，可以实现协议的前向兼容；
* 自动代码生成，不需要手工编写同样数据结构的C++和Java版本；
* 方使后续的管理和维护。相比于代码，结构化的文档更容易管理和维护。

Protobuf编解码和其他几种序列化框架的响应时间对比：

![Protobuf编解码和其他几种序列化框架的响应时间对比](/static/img/2017-01-15-IO流/2018-07-18-11-24-32.png)

Protobuf和其他几种序列化框架的宇节数对比：

![Protobuf和其他几种序列化框架的宇节数对比](/static/img/2017-01-15-IO流/2018-07-18-11-26-28.png)

Protobuf的编解码性能远远高于其他几种序列化相架的序列化和反序列化，这也是很多RPC框架选用Protobuf做编解码框架的原因。

通过protoc.exe 命令行生成Java代码。

![SubscribeResp.proto文件定义](/static/img/2017-01-15-IO流/2018-07-18-16-28-18.png)

```java
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) {
				// netty的粘包半包支持
				ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());
				ch.pipeline().addLast(new ProtobufDecoder(SubscribeReqProto.SubscribeReq.getDefaultinstance()));
				ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());
				ch.pipeline().addLast(new ProtobufEncoder());
				ch.pipeline().addLast(new SubReqServerHandler());

			}
		});
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCPNODELAY, true)
		.handler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());
				ch.pipeline().addLast(new ProtobufDecoder(SubscribeRespProto.SubscribeResp.getDefaultinstance()));
				ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());
				ch.pipeline().addLast(new ProtobufEncoder());
				ch.pipeline().addLast(new SubReqClientHandler());
			}
		});
```

1. 使用Netty提供的Protobutvarint32FrameDecoder,它可以处理半包消息；
2. 继承Netty提供的通用半包解码器LengthFieldBasedFrameDecoder;
3. 继承ByteToMessageDecoder类，自己处理半包消息。

##### Facebook的Thrift介绍

创造Thrift是为了解决Facebook各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性，
因此Thrift可以支持多种程序语言，如C++、C#、Cocoa、Erlang、Haskell、Java、Ocami、Perl、PHP、Python、Ruby和Smalltalk。

在多种不同的语言之间通信，Thrift可以作为高性能的通信中间件使用，它支持数据（对象）序列化和多种类型的RPC服务。
Thrift适用于静态的数据交换，需要先确定好它的数据结构，当数据结构发生变化时，必须重新编辑IDL文件，生成代码和编译，这一点跟具他IDL工具相比可以视为是Thrift的弱项。
Thrift适用于搭建大型数据交换及存储的通用工具，对于大型系统中的内部数据传输，相对于JSON和XML在性能和传输大小上都有明显的优势。

Thrift主要由5部分组成。

1. 语言系统以及IDL编译器：负责由用户给定的IDL文件生成相应语言的接口代码；
2. TProtocol：RPC的协议层，可以选择多种不同的对象序列化方式，如JSON和Binary;
3. TTransport：RPC的传输层，同样可以选择不同的传输层实现，如socket、NIO、MemoryBuffer等
4. TProcessor：作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口：
5. TServer：聚合TProtocol、TTransport和TProcessor等对象。

由于Thrift的RPC服务调用和编解码框架绑定在一起，所以，通常我们使用Thrift的时候会采取RPC框架的方式。
但是，它的TProtocol编解码框架还是可以以类库的方式独立使用的。

与Protobuf比较类似的是，Thrift通过IDL描述接口和数据结构定义，它支持8种Java基本类型、Map、Set和List,支持可选和必选定义，功能非常强大。
因为可以定义数据结构中字段的顺序，所以它也可以支待协议的前向兼容。

Thrift支持三种比较典型的编解码方式。

* 通用的二进制编解码：
* 压缩二进制编解码；
* 优化的可选字段压缩编解码。

由于支持二进制压缩编解码，Thrift的编解码性能表现也相当优异，远远超过Java序列化和RMI。

![Thrift性能测试对比图](/static/img/2017-01-15-IO流/2018-07-18-11-37-54.png)

##### JBoss Marshalling介绍

JBoss Marshalling是一个Java对象的序列化API包，修正了JDK自带的序列化包的很多问题，但又保待跟java.io.Serializable接口的兼容；
同时增加了一些可调的参数和附加的特性，并且这些参数和特性可通过工厂类进行配置。

相比于传统的Java序列化机制，它的优点如下：

* 可插拔的类解析器，提供更加便捷的类加载定制策略，通过一个接口即可实现定制；
* 可插拔的对象替换技术，不需要通过继承的方式；
* 可插拔的预定义类缓存表，可以减小序列化的字节数组长度，提升常用类型的对象序列化性能；
* 无须实现java.io.Serializable 接口，即可实现Java 序列化；
* 通过缓存技术提升对象的序列化性能。

JBoss Marshalling更多是在JBoss内部使用，应用范围有限。

```java
public final class MarshallingCodeCFactory {
    /**
     * 创建Jboss Marshalling解码器MarshallingDecoder
     */
    public static MarshallingDecoder buildMarshallingDecoder() {
        final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
        final MarshallingConfiguration configuration = new MarshallingConfiguration();
        configuration.setVersion(5);
        UnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);
        MarshallingDecoder decoder = new MarshallingDecoder(provider, 1024);
        return decoder;
    }
    /**
     * 创建Jboss Marshalling编码器MarshallingEncoder
     */
    public static MarshallingEncoder buildMarshallingEncoder() {
        final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
        final MarshallingConfiguration configuration = new MarshallingConfiguration();
        configuration.setVersion(5);
        MarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);
        MarshallingEncoder encoder = new MarshallingEncoder(provider);
        return encoder;
    }
}
```

```java
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) {
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
				ch.pipeline().addLast(new SubReqServerHandler());
			}
		});
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCP_NODELAY, true)
		.handler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch)
					throws Exception {
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
				ch.pipeline().addLast(new SubReqClientHandler());
			}
		});
```

Marshalling编解码器支持半包和粘包的处理。

##### MessagePack编解码

MessagcPack是一个高效的二进制序列化框架，它像JSON一样支持不同语言间的数据交换，但是它的性能更快，序列化之后的码流也更小。

MessagePack的特点如下：

* 编解码高效，性能高；
* 序列化之后的码流小；
* 支持跨语言。
	* Java、Python、Ruby、Haskell、C#、OCaml、Lua、Go、C、C++等

```xml
<dependencies>
  <dependency>
    <groupId>org.msgpack</groupId>
    <artifactId>msgpack</artifactId>
    <version>${msgpack.version}</version>
  </dependency>
</dependencies>
```

```java
// Create serialize objects.
List<String> src = new ArrayList<String>();
src.add("msgpack");
src.add("kumofs");
src.add("viver");
MessagePack msgpack = new MessagePack();
// Serialize
byte[] raw = msgpack.write(src);
// Deserialize directly using a template
List<String> dst1 = msgpack.read(raw, Templates.tList(Templates.TString));
// Or, Deserialze to Value then convert type.
Value dynamic = msgpack.read(raw);
List<String> dst2 = new Converter(dynamic).read(Templates.tList(Templates.TString));
```

```java
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCP_NODELAY, true)
		.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)
		.handler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				// 粘包、半包支持及编解码支持
				ch.pipeline().addLast("frameDecoder", new LengthFieldBasedFrameDecoder(65535, 0, 2, 0, 2));
				ch.pipeline().addLast("msgpack decoder", new MsgpackDecoder());
				// 增加头
				ch.pipeline().addLast("frameEncoder", new LengthFieldPrepender(2));
				ch.pipeline().addLast("msgpack encoder", new MsgpackEncoder());
				ch.pipeline().addLast(new EchoClientHandler(sendNumber));
			}
		});

ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap
		.group(acceptorGroup, IOGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ch.pipeline().addLast("frameDecoder", new LengthFieldBasedFrameDecoder(65535, O, 2, 0, 2));
				ch.pipeline().addLast("msgpack decoder", new MsgpaclcDecoder());
				ch.pipeline().addLast("frameEncoder", new LengthFieldPrepender(2));
				ch.pipeline().addLast("msgpack encoder", new MsgpackEncoder());
				ch.pipeline().addLast(new EchoServerHandler());
			}

		});
```

在MessagePack编码器之前增加LengthFieldPrepender，它将在ByteBuf之前增加2个字节的消息长度字段。

![LengtbfieldPrepender原理示意图](/static/img/2017-01-15-IO流/2018-07-18-16-14-10.png)

在MessagePack解码器之前增加LengthFieldBasedFrameDecoder，用于处理半包消息，这样后面的MsgpackDecoder接收到的永远是整包消息。

![LengthFieldBasedFrameDecoder工作原理图](/static/img/2017-01-15-IO流/2018-07-18-16-15-19.png)

利用Netty的半包编码和解码器LengthFieldPrepender和LengthFieldBasedFrameDecoder，可以轻松地解决TCP粘包和半包问题。

### Netty多协议开发

#### Http协议介绍

HTTP是一个属千应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。

HTTP协议的主要特点：

* 支持Client/Server模式；
* 简单：客户向服务器请求服务时，只需指定服务URL,携带必要的请求参数或者消息体；
* 灵活：HTTP允许传输任意类型的数据对象，传输的内容类型由HTTP消息头中的Content-Type加以标记；
* 无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。
	* 缺少状态意味着如果后续处理衙要之前的信息，则它必须重传，这样可能导致每次连接传送的数据压增大。
	* 另一方面，在服务器不需要先前信息时它的应答就较快，负载较轻。

##### URL

```text
http://host[":"port)(abs_path]
```

##### 请求信息

* HTTP请求行；
* HTTP消息头；
* HTTP请求正文。

请求行以一个方法符开头，以空格分开，后面跟着请求的URI和协议的版本，格式为：Method Request-URI HTTP-Version CRLF。

其中Method表示请求方法，Request-URI是一个统一资源标识符，HTTP-Version表示请求的HTTP协议版本，CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。

请求方法有多种，各方法的作用：

* GET:请求获取Request-URI所标识的资源；
* POST:在Request-URI所标识的资源后附加新的提交数据；
* HEAD:请求获取由Request-URI所标识的资源的响应消息报头；
* PUT:请求服务器存储一个资源，并用Request-URI作为其标识；
* DELETE:诸求服务器删除Request-URI所标识的资源；
* TRACE:请求服务器回送收到的请求信息，主要用于刹试或诊断；
* CONNECT:保留将来使用；
* OPTIONS:请求查询服务器的性能，或者查询与资源相关的选项和需求。

GET方法：以在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源。

POST方法：要求被请求服务器接受附在请求后面的数据，常用于提交表单。

1. 根据HTTP规范，GET用于信息获取，而且应该是安全的和幕等的；POST则表示可能改变服务器上的资源的请求。
2. GET提交，请求的数据会附在URL之后，就是把数据放置在请求行(requestIine)中，以"?"分隔URL和传输数据，多个参数用"&"连接；而POST提交会把提交的数据放置在HTTP消息的包体中，数据不会在地址栏中显示出来。
3. 传输数据的大小不同。特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2KB+35B),因此GET携带的参数的长度会受到浏览器的限制；而POST由于不是通过URL传值，理论上数据长度不会受限。
4. 安全性。POST的安全性要比GET的安全性商。比如通过GET提交数据，用户名和密码将明文出现在URL上。
	* 登录页面有可能被浏览器缓存，其他人查看浏览器的历史记录，那么别人就可以拿到你的账号和密码了。
	* 除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。POST提交的内容由于在消息体中传输，因此不存在上述安全问题。

HTTP的部分请求消息头列表：

| 名称(KEY)       | 作用                                                                                                                               |
|:----------------|:-----------------------------------------------------------------------------------------------------------------------------------|
| Accept          | 用于指定客户端接受哪些类型的信息。                                                                                                 |
| Accept-Charset  | 用于指定客户茹接受的字符集。                                                                                                       |
| Accept-Encoding | 用于指定可接受的内容编码。                                                                                                         |
| Accept-Language | 用于指定一种自然语言。                                                                                                             |
| Authorization   | 主要用于证明客户端有权查看某个资源。服务器的响应代码为401，可以发送一个包含Authorization诸求报头域的诺求，要求服务器对其进行认证。 |
| Host            | 指定被谐求资源的Internet主机和端口号，它通常是从HTTP URL中提取出来的。                                                             |
| User-Agent      | 允许客户端将它的操作系统、浏览器和其他屈性告诉服务器。                                                                             |
| Content-Length  | 请求消息体的长度。                                                                                                                 |
| Content-Type    | 表示后面的文档属千什么MIME类型。                                                                                                   |
| Connection      | 连接类型                                                                                                                           |

##### 响应消息

三个部分组成，分别是：状态行、消息报头、响应正文。

状态行的格式为：HTTP-Version Status-Code Reason-Phrase CRLF, 其中HTTP-Version表示服务器HTTP协议的版本，Status-Code表示服务器返回的响应状态代码。

状态代码由三位数字组成，第一个数字定义了响应的类别，它有5种可能的取值。

1. lxx：指示信息。表示请求已接收，继续处理；
2. 2xx：成功。表示请求已被成功接收、理解、接受：
3. 3xx：重定向。要完成谓求必须进行更进一步的操作；
4. 4xx：客户端错误。请求有语法错误或请求无法实现；
5. 5xx：服务器端错误。服务器未能处理请求。

##### 响应状态代码和描述信息

| 状态码 | 状态描述                                                                     |
|:-------|:-----------------------------------------------------------------------------|
| 200    | OK：客户端诮求成功                                                           |
| 400    | Bad Request：客户端请求有语法错误，不能被服务器所理解                        |
| 401    | Unauthorized：诮求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 |
| 403    | Forbidden：服务器收到谐求，但是拒绝提供服务                                  |
| 404    | Not Found：请求资源不存在                                                    |
| 500    | Internal Server Error：服务器发生不可预期的错误                              |
| 503    | Server Uaavailable：服务器当前不能处理客户站的诸求，一段时间后可能恢复正常   |

响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。

常用的响应报头：

| 名称(KEY)        | 作用                                                                                                                                         |
|:-----------------|:---------------------------------------------------------------------------------------------------------------------------------------------|
| Location         | 用于重定向接收者到一个新的位置，Location响应报头域常用于更换域名的时候                                                                       |
| Server           | 包含了服务器用来处理i音求的软件信息，与User-Agent音求报头域是相对应的                                                                        |
| WWW-Authenticate | 必须被包含在401(未授权的）响应消息中．客户端收到401响应消息，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域 |

#### Netty HTTP服务器入门开发

由于Netty天生是异步事件驱动的架构，因此基千NIO TCP协议栈开发的HTTP协议栈也是异步非阻塞的。

Netty的HTTP协议栈无论在性能还是可靠性上，都表现优异，非常适合在非Web容器的场景下应用，
相比于传统的Tomcat、Jetty等Web容器，它更加轻址和小巧，灵活性和定制性也更好。

代码：

[HttpFileServer.java](https://github.com/songxianpeng/nettybook2/blob/master/src/com/phei/netty/protocol/http/fileServer/HttpFileServer.java)

[HttpFileServerHandler.java](https://github.com/songxianpeng/nettybook2/blob/master/src/com/phei/netty/protocol/http/fileServer/HttpFileServerHandler.java)

#### Netty HTTP+XML协议栈开发

由于HTTP协议的通用性，很多异构系统间的通信交互采用HTTP协议，通过HTTP协议承载业务数据进行消息交互，例如非常流行的HTTP+XML或者RESTful+JSON。

1. 需要一套通用、高性能的XML序列化框架，它能够灵活地实现POJO-XML的互相转换，最好能够通过工具自动生成绑定关系，或者通过XML的方式配置双方的映射关系；
2. 作为通用的HTTP+XML协议栈，XML-POJO对象的映射关系应该非常灵活，支待命名空间和自定义标签；
3. 提供HTTP+XML请求消息编码器，供HTTP客户端发送请求消息自动编码使用；
4. 提供HTTP+XML请求消息解码器，供HTTP服务端对请求消息自动解码使用；
5. 提供HTTP+XML响应消息编码器，供HTTP服务端发送响应消息自动编码使用；
6. 提供HTTP+XML响应消息解码器，供HTTP客户端对应答消息进行自动解码使用；
7. 协议栈使用者不需要关心HTTP+XML的编解码，对上层业务零侵入，业务只需要对上层的业务POJO对象进行编排。

##### 高效的XML绑定框架JiBx

[JiBx](http://jibx.sourceforge.net/)是一款非常优秀的XML(Extensible Markup Language)数据绑定框架。
它提供灵活的绑定映射文件，实现数据对象与XML文件之间的转换，并不需要修改既有的Java类。另外，它的转换效率是目前很多其他开源项目都无法比拟的。

* 转换效率高
* 配置绑定文件单
* 不需要操作xpath文件
* 不需要写属性的get/set方法
* 对象属性名与XML文件element名可以不同，等等。

在运行程序之前，盆要先配胃绑定文件并进行绑定，在绑定过程中它将会动态地修改程序中相应的class文件，
主要是生成对应对象实例的方法和添加被绑定标记的属性JiBX_bindingList等。
它使用的技术是BCEL(Byte Code Engineering Library)，BCEL是Apache Software Foundation的Jakarta项目的一部分，
也是目前Javaclassworking最广泛使用的一种框架，它可以让你深入JVM汇编语言进行类操作。

在JiBX运行时，它使用了目前比较流行的一个技术XPP(Xml Pull Parsing)，这也正是JiBX如此高效的原因。

JiBx有两个比较重要的概念：Unmarshal(数据分解）和Marshal(数据编排）。
从字面意思也很容易理解，Unmarshal是将XML文件转换成Java对象，而Marshal则是将Java对象编排成规范的XML文件。

JiBX在Unmarshal/Marshal上如此高效，这要归功于使用了XPP技术，而不是使用基千树型Ctree-based)方式，将整个文档写入内存，然后进行操作的DOM(Document Object Model)，
也不是使用基千事件流(event stream)的SAX(Simple API for Xml)。
XPP使用的是不断增加的数据流处理方式，同时允许在解析XML文件时中断。

通过JiBx提供的工具jar包，可以根据Schema自动生成POJO对象，也可以根据普通的POJO对象生成JiBx绑定文件和Schema定义XSD。

```xml
<!-- set classpath for compiling and running application with JiBX -->
<path id="classpath">
	<fileset dir="${jibx-home}/lib" includes="*.jar"/>
	<pathelement location="bin"/>
</path>
...
<!-- generate default binding and schema -->
<target name="bindgen">
	<echo message="Running BindGen tool"/>
	<java classpathref="classpath" fork="true" failonerror="true" classname="org.jibx.binding.generator.BindGen">
		<arg value="-s"/>
		<arg value="${baseDir}/src/main/com/songxp/pojo"/>
		<arg value="com.songxp.pojo.Order"/>
	</java>
</target>
```

```xml
<!-- 根据绑定文件和POJO对象的映射关系和规则动态修改POJO类 -->
<!-- Run JiBX binding compiler -->
<bind verbose="true" load="true" binding="binding.xml">
<classpath>
    <pathelement path="classes"/>
    <pathelement location="${jibx-lib}/jibx-run.jar"/>
</classpath>
</bind> 
```

```java
private IBindingFactory factory = null;
private StringWriter writer = null;
private StringReader reader = null;
private final static String CHARSET_NAME = "UTF-8";
private String encode2Xml(Order order) throws JiBXException, IOException {
    factory = BindingDirectory.getFactory(Order.class);
    writer = new StringWriter();
    IMarshallingContext marshallingContext = factory.createMarshallingContext();
    marshallingContext.setIndent(2);
    marshallingContext.marshalDocument(order, CHARSET_NAME, null, writer);
    String xmlStr = writer.toString();
    writer.close();
    System.out.println(xmlStr);
    return xmlStr;
}
private Order decode2Order(String xmlBody) throws JiBXException {
    reader = new StringReader(xmlBody);
    IUnmarshallingContext unmarshallingContext = factory.createUnmarshallingContext();
    Order order = (Order) unmarshallingContext.unmarshalDocument(reader);
    return order;
}
```

HTTP+XML协议代码：

[http](https://github.com/songxianpeng/nettybook2/tree/master/src/com/phei/netty/protocol/http/xml)

客户端：

在ChannelPipeline中新增了HttpResponseDecoder,它负责将二进制码流解码成为HTTP的应答消息；
随后新增了HttpObjectAggregator,它负责将1个HTTP请求消息的多个部分合并成一条完整的HTTP消息；
将开发的XML解码器HttpXmlResponseDecoder添加到ChannelPipelioe中，这样就实现了HTTP+XML应答消息的自动解码。

将HttpRequestEncoder编码器添加到ChannelPipeline中时，需要注意顺序，
编码的时候是按照从尾到头的顺序调度执行的，它后面放的是自定义开发的HTTP+XML请求消息编码器HttpXmIRequestEncoder。

最后是业务的逻辑编排类HttpXmlCiientHandle。

---

*以上概念总结于传智播客Java基础课程、《Netty权威指南》*