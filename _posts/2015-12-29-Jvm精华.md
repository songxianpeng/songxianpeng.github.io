---
layout: post
title: 深入理解Java虚拟机
tags: Java基础 JVM
categories: Java
published: true
---

[TOC]

## Java优点

* 它摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想
* 它提供了一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题
* 它实现了热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而获得更高的性能
* 它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能

## Java技术体系

### 成员

* Java程序设计语言
* 各种硬件平台上的Java虚拟机
* Class文件格式
* Java API类库
* 来自商业机构和开源社区的第三方Java类库

#### JDK,JRE,JVM的作用及关系

**作用**

* JVM：保证Java语言跨平台
* JRE：Java程序的运行环境
* JDK：Java程序的开发环境

**关系**

> Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK  
> 把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE  

* JRE：JVM+类库
* JDK：JRE+工具

#### JVM跨平台原理图

![title](/static/img/Java基础第一课精华总结/Java语言跨平台原理图解.bmp "title")

* JVM在虚拟机曾买呢隐藏了低层技术的复杂性以及机器与操作系统的差异
* 为了达到给所有硬件提供一致的虚拟机平台的目的，牺牲了一些与硬件相关的性能特性
* 如果开发人员不了解虚拟机的一些技术特性和运行原理，就无法写出最适合虚拟机运行和自优化的

##### 编译运行

* 高版本的Java能运行低版本的Javac编译的程序
* 低版本的Java不能运行高版本的Javac编译的程序

## 自动内存管理机制

### 运行时数据区

![运行时数据区](/static/img/jvm/Runtime-Data-area.png "运行时数据区")

* 线程隔离
	- 程序计数器
	- Java虚拟机栈
	- 本地方法栈
* 线程共享
	- Java堆
	- 方法区
		+ 运行时常量池
* 直接内存

#### 程序计数器

> 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。  
> 在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。


* 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；
* 如果正在执行的是Native方法，这个计数器值则为空（Undefined）。

**异常**

* 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

#### Java虚拟机栈

> Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。  
> 虚拟机栈描述的是Java方法执行的内存模型：  
>> 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。  
>> 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  

**局部变量表数据**

> 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

* 基本数据类型
	- boolean、byte、char、short、int、float、long、double
		+ 64位长度的long和double类型的数据会占用2个局部变量空间
* 对象引用（reference类型）
	- 它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置
* returnAddress类型
	- 指向了一条字节码指令的地址

**异常**

* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
* 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常

#### 本地方法栈

> 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法  
> 虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一

**异常**

* 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常

#### Java堆

> 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。  
> Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配  
> 但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

*Tips：Java堆是垃圾收集器管理的主要区域*  
*Tips：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可*  

**异常**

* 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

#### 方法区

> 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

**方法区实现**

> HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。  
> 永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题）

*Tips：JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出*  
*Tips：JDK 1.8的HotSpot中，已经使用Metaspace取代了PermGen*  

**异常**

* 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

#### 运行时常量池

> 运行时常量池（Runtime Constant Pool）是方法区的一部分  
> 常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

*Tips：Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。*

**异常**

* 运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常

#### 直接内存

> 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域  

>  在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。  
>  这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

**异常**

* 本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制
* 在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

### HotSpot虚拟机对象探秘

HotSpot虚拟机在Java堆中对象分配、布局和访问

#### 对象的创建

对象（普通Java对象，不包括数组和Class对象等）的创建过程

* 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
* 在类加载检查通过后，接下来虚拟机将为新生对象分配内存
	- 分配方式
		+ 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）
		+ 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）
	- 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
		+ 使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞
		+ 使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表
	- 线程安全问题
		+ 一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
		+ 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）
* 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行
	- 保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值
* 接下来，虚拟机要对对象进行必要的设置
	- 如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息
	- 这些信息存放在对象的对象头（Object Header）中
* 执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来

#### 对象的内存布局

HotSpot虚拟机对象在内存中存储的布局可以分为3块区域

* 对象头（Header）
* 实例数据（Instance Data）
* 对齐填充（Padding）

##### 对象头

* 第一部分用于存储对象自身的运行时数据
	- 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
	- 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit
	- 官方称它为“Mark Word”
* 另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
	- 并不是所有的虚拟机实现都必须在对象数据上保留类型指针（使用句柄）
	- 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小

##### 实例数据

* 对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来
	- 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响

##### 对齐填充

* 对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用
	- 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

#### 对象的访问定位

Java程序需要通过栈上的reference数据来操作堆上的具体对象

> reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置  
> 所以对象访问方式也是取决于虚拟机实现而定的。  
> 目前主流的访问方式有使用句柄和直接指针两种。  

##### 句柄

![句柄](/static/img/jvm/handle.png "句柄")

**好处**

* 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改

##### 指针

![指针](/static/img/jvm/pointer.png "指针")

**好处**

* 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销


### OutOfMemoryError异常

#### Java堆溢出

> Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

```java
// VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
public class HeapOOM {
    static class OOMObject {}
    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
// java.lang.OutOfMemoryError: Java heap space
// Dumping heap to java_pid5124.hprof ...
// Heap dump file created [28375534 bytes in 0.096 secs]
// Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```

> 一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）  
> 
> 如果是**内存泄露**，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。  
> 
> 如果**不存在泄露**，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

#### 虚拟机栈和本地方法栈溢出

> 由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定

```java
/***
 * VM Args: -Xss128k
 * 1.使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。(当前示例)
 * 2.定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。
 */
public class JavaVMStackSOF {
    private int stackLength = 1;
    private void stackLeak() {
        stackLength++;
        stackLeak();// 这里申请栈空间
    }
    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length：" + oom.stackLength);
            throw e;
        }
    }
}
// stack length：990
// Exception in thread "main" java.lang.StackOverflowError
```

#### 方法区和运行时常量池溢出

##### 运行时常量池

> 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量  
> JDK 1.7开始逐步“去永久代”的事情，while循环会一直进行下去

```java
// VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        //使用List保持着常量池引用，避免Full GC回收常量池行为
        List<String> list = new ArrayList<String>();
        // 10MB的PermSize在integer范围内足够产生OOM了
        int i = 0;
        while (true) {
        	// String.intern()是一个Native方法
        	// 如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象
        	// 否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用
            list.add(String.valueOf(i++).intern());
        }
    }
}
// Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
//    at java.lang.String.intern(Native Method)
//    at RuntimeConstantPoolOOM1.main(RuntimeConstantPoolOOM1.java:11)
```

> 这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。  
> 产生差异的原因是：
>> 在JDK 1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。  
>> 
>> 而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。  
>> 
>> 对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过（换成其他字符串会返回true），字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。

```java
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        String str1 = new StringBuilder("计算机").append("软件").toString();
        System.out.println(str1.intern() == str1);
        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2.intern() == str2);
    }
}
```

##### 方法区

> 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出  
> JDK 8 中PermGen部分内存空间将全部移除，JVM的参数：PermSize 和 MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）  
> 取而代之的是Metaspace，默认情况下，大部分类元数据都在本地内存中分配，类元数据只受可用的本地内存限制，新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。

```java
// before 1.8：VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
// after 1.8：VM Args: -XX:MaxMetaspaceSize=10M
public class JavaMethodAreaOOM {
    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                    return proxy.invokeSuper(obj, args);
                }
            });
            enhancer.create();
        }
    }
    static class OOMObject {
        public void test(){}
    }
}
// before 1.8： Caused by: java.lang.OutOfMemoryError: PermGen space
// after 1.8： Exception in thread "main" java.lang.OutOfMemoryError: Metaspace
```

#### 本机直接内存溢出

> 垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。  
> 否则它只能一直等到抛出内存溢出异常时，先catch掉，再在catch块里面“大喊”一声：“System.gc()！”。要是虚拟机还是不听（譬如打开了-XX：+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了

> DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样手动抛出异常  
> 真正申请分配内存的方法是unsafe.allocateMemory()。

```java
// VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
public class DirectMemoryOOM {
    private static final int _1MB = 1024 * 1024;
    public static void main(String[] args) throws Exception {
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }
}
// Exception in thread "main" java.lang.OutOfMemoryError
```

> 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

## 垃圾收集器与内存分配策略

> 当需要排查各种内存溢出、内存泄漏问题时  
> 当垃圾收集成为系统达到更高并发量的瓶颈时  
> 我们就需要对这些“自动化”的技术实施必要的监控和调节

* 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，方法结束或者线程结束时，内存自然就跟随着回收
* Java堆和方法区只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存

### 对象是否应该被回收

#### 引用

在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

* 强引用
	- 是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用
	- 是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
* 弱引用
	- 是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
* 虚引用
	- 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。

#### 引用计数法

> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的  
> 引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法  
> 但是主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题

#### 可达性分析法

> 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的

Java语言中，可作为GC Roots的对象包括下面几种

* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）引用的对象。

#### 回收前的两次标记

两次标记

1. 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
	* 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
2. finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。
	* 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。
	* finalize()方法只要重新与引用链上的任何一个对象建立关联，就可以避免被回收，但是只能避免一次，因为finalize()方法只会被系统自动调用一次

#### 回收方法区

> Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低  
> 在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

* 废弃常量
	- 没有任何String对象引用常量池中的常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个常量就会被系统清理出常量池
	- 常量池中的其他类（接口）、方法、字段的符号引用也与此类似
* 无用的类
	- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
	- 加载该类的ClassLoader已经被回收。
	- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
	- 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。
		+ 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。
		+ 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

### 垃圾收集算法

#### 标记-清除算法

> 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在《对象是否应该被回收》讲述对象标记判定时已经介绍过了

**缺点**

* 一个是效率问题，标记和清除两个过程的效率都不高
* 另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

![Mark-Clear](/static/img/jvm/Mark-Clear.png "Mark-Clear")

#### 复制算法

> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。  
> 这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效

**缺点**

* 代价是将内存缩小为了原来的一半，未免太高了一点
* 在对象存活率较高时就要进行较多的复制操作，效率将会变低

> 新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。  
> 
> 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。  
> 
> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，只有10%的内存会被“浪费”  
> 
> 当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion），这些对象将直接通过分配担保机制进入老年代

![copy](/static/img/jvm/copy.png "copy")

#### 标记-整理算法

> 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

![Mark-Finishing](/static/img/jvm/Mark-Finishing.png "Mark-Finishing")

#### 分代收集算法

> 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。  
>> 在**新生代**中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。  
>> 而**老年代**中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。  

### HotSpot的算法实现

#### 枚举根节点

> 从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。  
> 
> 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因  
> 
> HotSpot的实现中，是使用一组称为OopMap的数据结构来直接得知哪些地方存放着对象引用的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举


#### 安全点

> 可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。  
> 
> HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。  
> 
> 安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。  

---

> 另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：
> 
>> 抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）  
>
> 其中**抢先式中断**不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。  
> 
> 而**主动式中断**的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方

#### 安全区域

> 没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决  
> 
> **安全区域**是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。  
> 
> 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。

### 垃圾收集器

HotSpot虚拟机的垃圾收集器：

![7GC](/static/img/jvm/7GC.png "7GC")

* 如果两个收集器之间存在连线，就说明它们可以搭配使用。
* 虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。

#### Serial收集器

> 它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束  
> 采用单线程和复制算法

Serial/Serial Old收集器运行示意图：

![serial](/static/img/jvm/serial.png "serial")

Serial收集器是虚拟机运行在Client模式下的默认新生代收集器  
在用户的桌面应用场景中，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。  
它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。  

#### ParNew收集器

> ParNew收集器其实就是Serial收集器的多线程版本  
> 采用多线程和复制算法

ParNew/Serial Old收集器运行示意图：

![ParNew](/static/img/jvm/ParNew.png "ParNew")

是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作  

#### Parallel Scavenge收集器（“吞吐量优先”收集器）

> Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）  
> 采用多线程和复制算法  
> 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）  
> CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。
>> ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它

Parallel Scavenge/Parallel Old收集器运行示意图：

![Scavenge](/static/img/jvm/Scavenge.png "Scavenge")

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

* 控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数
* 设置吞吐量大小的-XX:GCTimeRatio参数

**GC自适应的调节策略（GC Ergonomics）**

> -XX:+UseAdaptiveSizePolicy是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量

#### Serial Old收集器

> 主要意义也是在于给Client模式下的虚拟机使用  
> 采用单线程和标记-整理算法  
> 如果在Server模式下，那么它主要还有两大用途：
>> 一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用  
>> 另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

Serial/Serial Old收集器运行示意图：

![serial](/static/img/jvm/serial.png "serial")

#### Parallel Old收集器

> Parallel Old是Parallel Scavenge收集器的老年代版本  
> 采用用多线程和标记-整理算法  
> 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器

Parallel Scavenge/Parallel Old收集器运行示意图：

![Scavenge](/static/img/jvm/Scavenge.png "Scavenge")

#### CMS收集器

> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器  
> 采用用多线程和标记-清除算法
> 第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作  

**步骤**

* 初始标记（CMS initial mark）
	- 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
* 并发标记（CMS concurrent mark）
	- 并发标记阶段就是进行GC RootsTracing的过程
* 重新标记（CMS remark）
	- 重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短
* 并发清除（CMS concurrent sweep）

> 初始标记、重新标记这两个步骤仍然需要“Stop The World”  
> 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的

Concurrent Mark Sweep收集器运行示意图：

![CMS](/static/img/jvm/CMS.png "CMS")

**缺点**

* CMS收集器对CPU资源非常敏感
	- 并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低
		+ CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大
* CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生
	- 由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”
	- 也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败
		+ 在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活
		+ 可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能
		+ 在JDK 1.6中，CMS收集器的启动阈值已经提升至92%
		+ 出现失败时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了
* 基于“标记—清除”算法实现意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC
	- CMS收集器提供了-XX:+UseCMSCompactAtFullCollection参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长
	- 另一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）

#### G1收集器

> G1是一款面向服务端应用的垃圾收集器  
> 降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒  
> HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器

**特点**

* 并行与并发
	- 使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行
* 分代收集
	- G1可以不需要其他收集器配合就能独立管理整个GC堆
	- 分代概念在G1中依然得以保留。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果
* 空间整合
	- G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC
* 可预测的停顿
	- 降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了

G1收集器运行示意图 ：

![G1](/static/img/jvm/G1.png "G1")

**可预测的停顿时间保证：**

> 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。
> 使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。  
> 
> G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
> G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。  
> 
> 这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

**跨Region和跨代引用问题：**

> 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。  
> 
> G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），
> 如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

**步骤**

* 初始标记（Initial Marking）
	- 初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象
	- 这阶段需要停顿线程，但耗时很短
* 并发标记（Concurrent Marking）
	- 并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象
	- 这阶段耗时较长，但可与用户程序并发执行。
* 最终标记（Final Marking）
	- 而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中
	- 这阶段需要停顿线程，但是可并行执行。
* 筛选回收（Live Data Counting and Evacuation）
	- 筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划
	- 从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率

**总结**

> 如果你现在采用的收集器没有出现问题，那就没有任何理由现在去选择G1  
> 如果你的应用追求低停顿，那G1现在已经可以作为一个可尝试的选择  
> 如果你的应用追求吞吐量，那G1并不会为你带来什么特别的好处

#### 垃圾收集器参数

|              参数              |                                                                        描述                                                                       |
|--------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收                                                     |
| UseParNewGC                    | 打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收                                                                                       |
| UseConcMarkSweepGC             | 打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS Mark Sweep）的收集器组合进行内存回收                         |
| UseParallelOldGC               | 打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收                                                                          |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1                                                                          |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配                                                                  |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄。每个对象在坚持过一次MinorGC之后，年龄就加1，当超过这个参数值时就进入老年代                                                |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄                                                                                                |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况                                          |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                                                                                                                  |
| GCTimeRatio                    | GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效                                                         |
| MaxGCPauseMillis               | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效                                                                                       |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效                                                           |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效                                                                  |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效                                                                |

### 内存分配与回收策略

自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存

> 对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置

#### 对象优先在Eden分配

> 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

**Minor GC和Full GC**

* 新生代GC（Minor GC）
	- 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
* 老年代GC（Major GC/Full GC）
	- 指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

```java
private static final int _1MB = 1024 * 1024;
// VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC
public static void main(String args[]) {
    byte[] allocation1, allocation2, allocation3, allocation4;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[2 * _1MB];
    allocation4 = new byte[4 * _1MB];//出现一次Minor GC
}
```

```
[GC [DefNew: 7301K->232K(9216K), 0.0039581 secs] 7301K->6376K(19456K), 0.0039897 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4821K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  56% used [0x00000000f9a00000, 0x00000000f9e7b670, 0x00000000fa200000)
  from space 1024K,  22% used [0x00000000fa300000, 0x00000000fa33a000, 0x00000000fa400000)
  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)
 tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3576K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  16% used [0x00000000fae00000, 0x00000000fb17f788, 0x00000000fb17f800, 0x00000000fc2c0000)
No shared spaces configured.
```

> 尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xms20M、-Xmx20M、-Xmn10M这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。  
> -XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果也可以清晰地看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量）
> 
> 分配allocation4对象的语句时会发生一次Minor GC，这次GC的结果是新生代6651KB变为148KB，而总内存占用量则几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。  
> 这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。  
> GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。

*注意事项：JDK1.8中指定虚拟机为Serial时，采用与1.6相同的垃圾回收器，并且1.8中的结果会与上面的结果不同，因为在allocation3分配时，Eden空间就无法满足分配后触发GC，1和2进入老年代，4直接在Eden空间分配*

```
[GC (Allocation Failure) [DefNew: 6399K->797K(9216K), 0.0043058 secs] 6399K->4893K(19456K), 0.0043560 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 7180K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  77% used [0x00000000fec00000, 0x00000000ff23bf18, 0x00000000ff400000)
  from space 1024K,  77% used [0x00000000ff500000, 0x00000000ff5c7418, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000)
 Metaspace       used 3452K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K
No shared spaces configured.
```

#### 大对象直接进入老年代

> 所谓的**大对象**是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）

*注意事项：经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。*

> 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制

*注意事项：PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合*

```java
private static final int _1MB = 1024 * 1024;

// VM参数:-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728 -XX:+UseSerialGC
public static void main(String args[]) {
    byte[] allocation;
    allocation = new byte[4 * _1MB];//直接分配在老年代中
}
```

```
Heap
 def new generation   total 9216K, used 1321K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  16% used [0x00000000f9a00000, 0x00000000f9b4a4b8, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3458K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  16% used [0x00000000fae00000, 0x00000000fb160970, 0x00000000fb160a00, 0x00000000fc2c0000)
No shared spaces configured.
```

> Eden空间几乎没有被使用，而老年代的10MB空间被使用了40%，也就是4MB的allocation对象直接就分配在老年代中，这是因为PretenureSizeThreshold被设置为3MB（就是3145728，这个参数不能像-Xmx之类的参数一样直接写3MB），因此超过3MB的对象都会直接在老年代进行分配

#### 长期存活的对象将进入老年代

> 虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1  
> 对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置

```java
private static final int _1MB = 1024 * 1024;
// VM参数:-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution -XX:+UseSerialGC
public static void main(String args[]) {
    byte[] allocation1, allocation2, allocation3;
    allocation1 = new byte[_1MB / 4];//什么时候进入老年代取决于XX:MaxTenuringThreshold设置
    allocation2 = new byte[4 * _1MB];
    allocation3 = new byte[4 * _1MB];// 第一次GC
    allocation3 = null;
    allocation3 = new byte[4 * _1MB];// 第二次GC
}
```

```
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:     499792 bytes,     499792 total
: 5397K->488K(9216K), 0.0035176 secs] 5397K->4584K(19456K), 0.0035437 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:        136 bytes,        136 total
: 4996K->0K(9216K), 0.0006436 secs] 9092K->4583K(19456K), 0.0006594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4234K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  51% used [0x00000000f9a00000, 0x00000000f9e22858, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200088, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4583K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  44% used [0x00000000fa400000, 0x00000000fa879f50, 0x00000000fa87a000, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3715K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  17% used [0x00000000fae00000, 0x00000000fb1a0f28, 0x00000000fb1a1000, 0x00000000fc2c0000)
No shared spaces configured.
```

> allocation1对象需要256KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1对象在第二次GC发生时进入老年代，新生代Survivor(from、to)已使用的内存GC后非常干净地变成0KB

MaxTenuringThreshold=15情况：

```
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:     496952 bytes,     496952 total
: 5397K->485K(9216K), 0.0044452 secs] 5397K->4581K(19456K), 0.0044792 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:        816 bytes,        816 total
- age   2:     496680 bytes,     497496 total
: 4993K->485K(9216K), 0.0009782 secs] 9089K->4581K(19456K), 0.0010121 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4719K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  51% used [0x00000000f9a00000, 0x00000000f9e22800, 0x00000000fa200000)
  from space 1024K,  47% used [0x00000000fa200000, 0x00000000fa279758, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3501K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  16% used [0x00000000fae00000, 0x00000000fb16c3d8, 0x00000000fb16c400, 0x00000000fc2c0000)
No shared spaces configured.
```

> allocation1对象则还留在新生代Survivor空间，这时新生代仍然有485KB被占用

*注意事项：JDK 8中MaxTenuringThreshold第一次GC后的新值为1，因为第一次GC后《动态对象年龄判定》Survivor空间对象超过50%已经可以进入老年代*

```
// 仅第一次GC
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:    1048080 bytes,    1048080 total
: 6844K->1023K(9216K), 0.0034564 secs] 6844K->5119K(19456K), 0.0035184 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 5365K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  53% used [0x00000000fec00000, 0x00000000ff03d8a0, 0x00000000ff400000)
  from space 1024K,  99% used [0x00000000ff500000, 0x00000000ff5ffe10, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)
 Metaspace       used 3210K, capacity 4568K, committed 4864K, reserved 1056768K
  class space    used 348K, capacity 392K, committed 512K, reserved 1048576K
```

```
// 包含第二次GC
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:    1048080 bytes,    1048080 total
: 6844K->1023K(9216K), 0.0044796 secs] 6844K->5119K(19456K), 0.0045626 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
: 5283K->0K(9216K), 0.0012891 secs] 9379K->5048K(19456K), 0.0013116 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4260K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0290e0, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 5048K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  49% used [0x00000000ff600000, 0x00000000ffaee170, 0x00000000ffaee200, 0x0000000100000000)
 Metaspace       used 3210K, capacity 4568K, committed 4864K, reserved 1056768K
  class space    used 348K, capacity 392K, committed 512K, reserved 1048576K
```

#### 动态对象年龄判定

> 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

```java
private static final int _1MB = 1024 * 1024;
// VM参数: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:+PrintTenuringDistribution -XX:+UseSerialGC
public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3, allocation4;
    allocation1 = new byte[_1MB / 4];
    //allocation1+allocation2大于survivor空间一半
    allocation2 = new byte[_1MB / 4];
    allocation3 = new byte[4 * _1MB];
    allocation4 = new byte[4 * _1MB];
    allocation4 = null;
    allocation4 = new byte[4 * _1MB];
}
```

```
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:     762304 bytes,     762304 total
: 5765K->744K(9216K), 0.0046013 secs] 5765K->4840K(19456K), 0.0046325 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:        904 bytes,        904 total
: 5252K->0K(9216K), 0.0009896 secs] 9348K->4841K(19456K), 0.0010106 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4234K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  51% used [0x00000000f9a00000, 0x00000000f9e22798, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200388, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4840K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  47% used [0x00000000fa400000, 0x00000000fa8ba0c0, 0x00000000fa8ba200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3717K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  17% used [0x00000000fae00000, 0x00000000fb1a14e0, 0x00000000fb1a1600, 0x00000000fc2c0000)
No shared spaces configured.
```

> 运行结果中Survivor的空间占用仍然为0%，而老年代比预期增加了7%，也就是说，allocation1、allocation2对象都直接进入了老年代，而没有等到15岁的临界年龄。  
> 因为这两个对象加起来已经到达了512KB，并且它们是同年的，满足同年对象达到Survivor空间的一半规则。  
> 我们只要注释掉其中一个对象new操作，就会发现另外一个就不会晋升到老年代中去了

#### 空间分配担保

> 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的  
> 如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败  
>> 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小  
>>> 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的  
>>> 如果小于，那这时也要改为进行一次Full GC  
>>
>> 如果不允许冒险，那这时也要改为进行一次Full GC  
>
>JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC

```java
private static final int _1MB = 1024 * 1024;
// VM参数:-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure -XX:+UseSerialGC
public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[2 * _1MB];
    allocation1 = null;
    allocation4 = new byte[2 * _1MB];
    allocation5 = new byte[2 * _1MB];
    allocation6 = new byte[2 * _1MB];
    allocation4 = null;
    allocation5 = null;
    allocation6 = null;
    allocation7 = new byte[2 * _1MB];
}
```

以HandlePromotionFailure=false参数来运行的结果：

```
[GC[DefNew：6651K-＞148K（9216K），0.0078936 secs]6651K-＞4244K（19456K），0.0079192 secs][Times：user=0.00 sys=0.02，real=0.02 secs]
[GC[DefNew：6378K-＞6378K（9216K），0.0000206secs][Tenured：4096K-＞4244K（10240K），0.0042901 secs]10474K-＞4244K（19456K），[Perm：2104K-＞2104K（12288K）]，0.0043613 secs][Times：user=0.00 sys=0.00，real=0.00 secs]
```

以HandlePromotionFailure=true参数来运行的结果（或者6u24以后的JDK）：

```
[GC [DefNew: 7301K->232K(9216K), 0.0040194 secs] 7301K->4328K(19456K), 0.0040549 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[GC [DefNew: 6880K->231K(9216K), 0.0005393 secs] 10976K->4328K(19456K), 0.0005566 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 2417K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  26% used [0x00000000f9a00000, 0x00000000f9c22500, 0x00000000fa200000)
  from space 1024K,  22% used [0x00000000fa200000, 0x00000000fa239ff8, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800020, 0x00000000fa800200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3692K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  17% used [0x00000000fae00000, 0x00000000fb19b1b8, 0x00000000fb19b200, 0x00000000fc2c0000)
No shared spaces configured.
```

## 虚拟机性能监控与故障处理工具

### JDK的命令行工具

|  名称  |                                                  主要作用                                                  |
|--------|------------------------------------------------------------------------------------------------------------|
| jps    | JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程                                              |
| jstat  | JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据                                       |
| jinfo  | Configuration Info for Java，显示虚拟机配置信息                                                            |
| jmap   | Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）                                              |
| jhat   | JVM Heap Dump Brower,用于分析heap dump文件，它会建立一个HTTP？HTML服务器，让用户可以在浏览器上查看分析结果 |
| jstack | Stack Trace for Java。显示虚拟机的线程快照                                                                 |

#### jps：虚拟机进程状况工具

> 可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）

jps命令格式：

```shell
jps [options] [hostid]
```

| 属性 |                        作用                        |
|------|----------------------------------------------------|
| -p   | 只输出LVMID，省略主类的名称                        |
| -m   | 输出虚拟机进程启动时传递给主类main()函数的参数     |
| -l   | 输出主类的全名，如果进程执行的是jar包，输出jar路径 |
| -v   | 输出虚拟机进程启动时jvm参数                        |

```shell
jps -q
jps -lvm
```

#### jstat：虚拟机统计信息监视工具

> 用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程[1]虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据

jstat命令格式：

```shell
jstat [ option vmid [interval[s|ms] [count]] ]

如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是

[protocol:][//]lvmid[@hostname[:port]/servername]

需要远程主机提供RMI支持，Sun提供的jstatd工具可以很方便地建立远程RMI服务器。
```

|                  选项                  |                                             作用                                             |
|----------------------------------------|----------------------------------------------------------------------------------------------|
| -class                                 | 监视装载类、卸载类、总空间以及类装载所耗费的时间                                             |
| -gc                                    | 监视java堆状况，包括eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计信息 |
| -gccapacity                            | 监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到最大、最小空间                      |
| -gcutil                                | 监视内容与-gc基本相同，但输出主要关注已使用控件占总空间的百分比                              |
| -gccause                               | 与-gcutil功能一样，但是会额外输出导致上一次gc产生的原因                                      |
| -gcnew                                 | 监视新生代GC情况                                                                             |
| -gcnewcapacity                         | 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间                                 |
| -gcold                                 | 监视老年代GC情况                                                                             |
| -gcoldcapacity                         | 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间                                 |
| -gcpermcapacity/-gcmetacapacity(JDK 8) | 输出永久代使用到的最大、最小空间                                                             |
| -compiler                              | 输出JIT编译过的方法、耗时等信息                                                              |
| -printcompilation                      | 输出已经被JIT编译过的方法                                                                    |

```shell
# 参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次
jstat -gc 2764 250 20
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
0.0   87040.0  0.0   87040.0 521216.0 382976.0 1061888.0   338933.3  40448.0 39473.2 4608.0 4396.0    514   15.213   0      0.000   15.213
```

* S0C:第一个幸存区的大小
* S1C:第二个幸存区的大小
* S0U:第一个幸存区的使用大小
* S1U:第二个幸存区的使用大小
* EC:伊甸园区的大小
* EU:伊甸园区的使用大小
* OC:老年代大小
* OU:老年代使用大小
* MC:方法区大小
* MU:方法区使用大小
* CCSC:压缩类空间大小
* CCSU:压缩类空间使用大小
* YGC:年轻代垃圾回收次数
* YGCT:年轻代垃圾回收消耗时间
* FGC:老年代垃圾回收次数
* FGCT:老年代垃圾回收消耗时间
* GCT:垃圾回收消耗总时间

* NGCMN:年轻代(young)中初始化(最小)的大小 (字节)
* NGCMX:年轻代(young)的最大容量 (字节)
* NGC:年轻代(young)中当前的容量 (字节)
* OGCMN:old代中初始化(最小)的大小 (字节)
* OGCMX:old代的最大容量 (字节)
* OGC:old代当前新生成的容量 (字节)
* PGCMN:perm代中初始化(最小)的大小 (字节)
* PGCMX:perm代的最大容量 (字节)
* PGC:perm代当前新生成的容量 (字节)
* MCMN:最小元数据容量
* MCMX:最大元数据容量
* MC:当前元数据空间大小
* CCSMN:最小压缩类空间大小
* CCSMX:最大压缩类空间大小
* CCSC:当前压缩类空间大小
* LGGC:最近一次GC的原因

```shell
## 显示百分比
jstat -gcutil 2764
```

#### jinfo：Java配置信息工具

> 实时地查看和调整虚拟机各项参数

jinfo命令格式：

```shell
jinfo [option] pid
可以使用-flag[+|-]name或者-flag name=value修改一部分运行期可写的虚拟机参数值
```

```shell
jinfo 11456
jinfo -sysprops 11456
jinfo -flag ConcGCThreads 11456
```

#### jmap：Java内存映像工具

> jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）  
> -XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件  
> -XX:+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件  
> Linux系统下通过kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件  
> jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等

jmap命令格式：

```shell
jmap [option] vmid
```

|        选项        |                                                     作用                                                    |
|--------------------|-------------------------------------------------------------------------------------------------------------|
| -dump              | 生成java堆转储快照。格式为： -dump:[live,]format=b,file=<filename>,其中live子参数说明是否只dump出存活的对象 |
| -finalizerinfo     | 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效                         |
| -heap              | 显示java堆详细信息，如使用哪种收集器、参数配置、分代情况等，在Linux/Solaris平台下有效                       |
| -jisto             | 显示堆中对象统计信息，包含类、实例对象、合集容量                                                            |
| -permstat/-clstats | 以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效                                      |
| -F                 | 当虚拟机进程对-dump选项没有相应时。可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效              |

```shell
jmap -dump:format=b,file=eclipse.bin 21207
```

#### jhat：虚拟机堆转储快照分析工具

> jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照  
> jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具都能实现比jhat更强大更专业的分析功能

```shell
jhat eclipse.bin
```

#### jstack：Java堆栈跟踪工具

> jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。  
> 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因  

jstack命令格式：

```
jstack [option] vmid
```

| 选项 |                     作用                     |
|------|----------------------------------------------|
| -F   | 当正常输出的请求不被响应时，强制输出线程堆栈 |
| -l   | 除堆栈外，显示关于锁的附加信息               |
| -m   | 如果调用到本地方法的话，可以显示c/c++的堆栈  |

> JDK 1.5中，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象

```jsp
<%@ page import="java.util.Map" %>
<html>
<head>
    <title>服务器线程信息</title>
</head>
<body>
<pre>
		<%
            for (Map.Entry<Thread, StackTraceElement[]> stackTrace : Thread.getAllStackTraces().entrySet()) {
                Thread thread = (Thread) stackTrace.getKey();
                StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue();
                if (thread.equals(Thread.currentThread())) {
                    continue;
                }
                out.print("\n线程:" + thread.getName() + "\n");
                for (StackTraceElement element : stack) {
                    out.print("\t" + element + "\n");
                }
            }
        %>
</pre>
</body>
</html>
```

### JDK可视化工具

#### JConsole：Java监视与管理控制台

JConsole（Java Monitoring and Management Console）是一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMX MBean进行管理，由于MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问

#### VisualVM：多合一故障处理工具

VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。官方在VisualVM的软件说明中写上了“All-in-One”的描述字样，预示着它除了运行监视、故障处理外，还提供了很多其他方面的功能。如性能分析（Profiling），VisualVM的性能分析功能甚至比起JProfiler、YourKit等专业且收费的Profiling工具都不会逊色多少

VisualVM的还有一个很大的优点：

不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。

**功能**

* 显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）
* 监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）
* dump以及分析堆转储快照（jmap、jhat）。方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法
* 离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈
* 其他plugins的无限的可能性…

BTrace插件使用

```java
package com.xpress.javase.jvm;
public class BTraceTest {
    public int add(int a, int b) {
        return a + b;
    }
    public static void main(String[] args) throws IOException {
        BTraceTest test = new BTraceTest();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        for (int i = 0; i < 10; i++) {
            reader.readLine();
            int a = (int) Math.round(Math.random() * 1000);
            int b = (int) Math.round(Math.random() * 1000);
            System.out.println(test.add(a, b));
        }
    }
}

```

```java
/*BTrace Script Template*/
import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;
@BTrace
public class TracingScript {
    @OnMethod(
            clazz = "com.xpress.javase.jvm.BTraceTest",
            method = "add",
            location = @Location(Kind.RETURN)
    )
    public static void func(@Self com.xpress.javase.jvm.BTraceTest instance, int a, int b,@Return int result) {
        println("调用堆栈：");
        jstack();
        println(strcat("方法参数A：",str(a)));
        println(strcat("方法参数B：",str(b)));
        println(strcat("方法结果：",str(result)));
    }
}
```

#### 其他工具

* IBM的Support Assistant、Heap Analyzer、Javacore Analyzer、Garbage Collector Analyzer适用于IBM J9 VM
* HP的HPjmeter、HPjtune适用于HP-UX、SAP、HotSpot VM
* Eclipse的Memory Analyzer Tool（MAT）适用于HP-UX、SAP、HotSpot VM，安装IBM DTFJ插件后可支持IBM J9 VM
* BEA的JRockit Mission Control适用于JRockit VM

## 调优

### 高性能硬件上的程序部署策略

在高性能硬件上部署程序，目前主要有两种方式：

* 通过64位JDK来使用大内存。
* 使用若干个32位虚拟机建立逻辑集群来利用硬件资源。

使用64位JDK来管理大内存，可能面临的问题：

* 内存回收导致的长时间停顿。
* 现阶段，64位JDK的性能测试结果普遍低于32位JDK。
* 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生十几GB乃至更大的Dump文件），哪怕产生了快照也几乎无法进行分析。
* 相同程序在64位JDK消耗的内存一般比32位JDK大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。

使用逻辑集群的方式来部署程序，可能遇到的问题：

* 尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致IO异常。
* 很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI，但这个有一定复杂性并且可能带来额外的性能开销。
* 各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些Linux或UNIX系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（232）内存的限制。
* 大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。

### 堆外内存溢出

> 除了Java堆和永久代之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和受到操作系统进程最大内存的限制。

* Direct Memory：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError：Direct buffer memory。
* 线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或者OutOfMemoryError：unable to create new native thread（横向无法分配，即无法建立新的线程）。
* Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException：Too many open files异常。
* JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。
* 虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存。

## 类文件结构

### 无关性

> 虚拟机和字节码存储格式是平台无关性和语言无关性基础

### Class类文件的结构

> Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。  
> 当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

Class文件格式采用伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号数**和**表**

* 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。

Class文件格式：

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。

|      类型      |         名称        |           数量          |
|----------------|---------------------|-------------------------|
| u4             | magic               | 1                       |
| u2             | minor_version       | 1                       |
| u2             | major_version       | 1                       |
| u2             | constant_pool_count | 1                       |
| cp_info        | constant_pool       | constant_pool_count - 1 |
| u2             | access_flags        | 1                       |
| u2             | this_class          | 1                       |
| u2             | super_class         | 1                       |
| u2             | interfaces_count    | 1                       |
| u2             | interfaces          | interfaces_count        |
| u2             | fields_count        | 1                       |
| field_info     | fields              | fields_count            |
| u2             | methods_count       | 1                       |
| method_info    | methods             | methods_count           |
| u2             | attribute_count     | 1                       |
| attribute_info | attributes          | attributes_count        |

*Tips：使用javap -verbose Test.class或者Hex工具查看文件字节码内容*

```shell
javap -verbose TestClass.class
Classfile /tmp/TestClass.class
  Last modified 2018年2月4日; size 295 bytes
  MD5 checksum 87f28d8f3ef94bd6cd9cae3fadcc0a1e
  Compiled from "TestClass.java"
public class org.fenixsoft.clazz.TestClass
  minor version: 0
  major version: 53
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #3                          // org/fenixsoft/clazz/TestClass
  super_class: #4                         // java/lang/Object
  interfaces: 0, fields: 1, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #4.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#16         // org/fenixsoft/clazz/TestClass.m:I
   #3 = Class              #17            // org/fenixsoft/clazz/TestClass
   #4 = Class              #18            // java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               inc
  #12 = Utf8               ()I
  #13 = Utf8               SourceFile
  #14 = Utf8               TestClass.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = NameAndType        #5:#6          // m:I
  #17 = Utf8               org/fenixsoft/clazz/TestClass
  #18 = Utf8               java/lang/Object
{
  public org.fenixsoft.clazz.TestClass();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 2: 0

  public int inc();
    descriptor: ()I
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field m:I
         4: iconst_1
         5: iadd
         6: ireturn
      LineNumberTable:
        line 5: 0
}
SourceFile: "TestClass.java"
```

![hex](/static/img/jvm/hex.png "hex")

#### 魔数与Class文件的版本

> 每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件  
>>值为：0xCAFEBABE
>
> 紧接着魔数的4个字节存储的是Class文件的版本号  
>> 第5和第6个字节是次版本号（Minor Version）  
>> 第7和第8个字节是主版本号（Major Version）  

Class文件版本号：

![version](/static/img/jvm/version.png "version")

#### 常量池

> 紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。  
> 
> 由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值，这个容量计数是从1而不是0开始的
>>设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示  
>> Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的

常量池中主要存放两大类常量：**字面量（Literal）**和**符号引用（Symbolic References）**。

* 字面量比较接近于Java语言层面的常量概念
    - 如文本字符串、声明为final的常量值等
* 符号引用则属于编译原理方面的概念，包括了下面三类常量：
    - 类和接口的全限定名（Fully Qualified Name）
    - 字段的名称和描述符（Descriptor）
    - 方法的名称和描述符

常量池中每一项常量都是一个表，这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位，代表当前这个常量属于哪种常量类型

14种常量池的项目类型：

![14Type](/static/img/jvm/14Type.jpg "14Type")

14种常量项的结构

![14structure](/static/img/jvm/14structure.jpg "14structure")

#### 访问标志

> 在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息

|    标志名称    | 标志值 |                                                                                 含义                                                                                 |
|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ACC_PUBLIC     | 0x0001 | 是否为public类型                                                                                                                                                     |
| ACC_FINAL      | 0x0010 | 是否被声明为final，只有类可设置                                                                                                                                      |
| ACC_SUPER      | 0x0020 | 是否允许使用invokespecial字节码指令的新语言，invokespecial指令的语意在JDK1.0.2发生过改变，为了区别这条指令使用哪种语意，JDK1.0.2之后编译出来的类的这个标志都必须为真 |
| ACC_INTERFACE  | 0x0200 | 标识这是一个接口                                                                                                                                                     |
| ACC_ABSTRACT   | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类值为假                                                                                               |
| ACC_SYNTHETIC  | 0x1000 | 标识这个类并非由用户代码产生的                                                                                                                                       |
| ACC_ANNOTATION | 0x2000 | 标识这是一个注解                                                                                                                                                     |
| ACC_ENUM       | 0x4000 | 标识这是一个枚举                                                                                                                                                     |

#### 类索引、父类索引与接口索引集合

> 类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系

* 类索引用于确定这个类的全限定名
* 父类索引用于确定这个类的父类的全限定名
    - 由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0
* 接口索引集合就用来描述这个类实现了哪些接口
    - 被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中

> 类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串
> 
> 对于接口索引集合，入口的第一项——u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节

#### 字段表集合

> 字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量

可以包括的信息有：

* 字段的作用域（public、private、protected修饰符）
* 是实例变量还是类变量（static修饰符）
* 可变性（final）
* 并发可见性（volatile修饰符，是否强制从主内存读写）
* 可否被序列化（transient修饰符）
* 字段数据类型（基本类型、对象、数组）
* 字段名称

**字段表结构**

|      类型      |       名称       |       数量       |                        说明                       |
|----------------|------------------|------------------|---------------------------------------------------|
| u2             | access_flags     | 1                | 修饰符标记位                                      |
| u2             | name_index       | 1                | 代表字段的简单名称，占2字节，是一个对常量池的引用 |
| u2             | descriptor_index | 1                | 代表字段的类型，占2个字节，是一个对常量池的引用   |
| u2             | attributes_count | 1                | 属性计数器                                        |
| attribute_info | attributes       | attributes_count | 属性表集合                                        |

字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型

|    标志名称   | 标志值 |            含义            |
|---------------|--------|----------------------------|
| ACC_PUBLIC    | 0x0001 | 字段是否为public           |
| ACC_PRIVATE   | 0x0002 | 字段是否为private          |
| ACC_PROTECTED | 0x0004 | 字段是否为protected        |
| ACC_STATIC    | 0x0008 | 字段是否为static           |
| ACC_FINAL     | 0x0010 | 字段是否为final            |
| ACC_VOLATILE  | 0x0040 | 字段是否为volatile         |
| ACC_TRANSTENT | 0x0080 | 字段是否为transient        |
| ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生 |
| ACC_ENUM      | 0x4000 | 字段是否为enum             |

跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符  
描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值

| 标志符 |         含义        |
|--------|---------------------|
| B      | 基本数据类型byte    |
| C      | 基本数据类型char    |
| D      | 基本数据类型double  |
| F      | 基本数据类型float   |
| I      | 基本数据类型int     |
| J      | 基本数据类型long    |
| S      | 基本数据类型short   |
| Z      | 基本数据类型boolean |
| V      | 基本数据类型void    |
| L      | 对象类型            |

不过在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息，attribute_info信息参看后文《属性表》部分

*注意事项：字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。*  
*注意事项：在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。*

#### 方法表集合

> Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项  
> 这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。

方法表结构：

|      类型      |       名称       |       数量       |                        说明                       |
|----------------|------------------|------------------|---------------------------------------------------|
| u2             | access_flags     | 1                | 修饰符标记位                                      |
| u2             | name_index       | 1                | 代表字段的简单名称，占2字节，是一个对常量池的引用 |
| u2             | descriptor_index | 1                | 代表字段的类型，占2个字节，是一个对常量池的引用   |
| u2             | attributes_count | 1                | 属性计数器                                        |
| attribute_info | attributes       | attributes_count | 属性表集合                                        |

![method_access_flag](/static/img/jvm/method_access_flag.png "method_access_flag")

*注意事项：与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”方法。*  
*注意事项：在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。*

#### 属性表集合

> 在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。  
> 只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性

虚拟机规范预定义的属性：

|               属性名称               |      使用位置      |                                                       含义                                                      |
|--------------------------------------|--------------------|-----------------------------------------------------------------------------------------------------------------|
| Code                                 | 方法表             | Java代码编译成的字节码指令                                                                                      |
| ConstantValue                        | 字段表             | final关键字定义的常量值                                                                                         |
| Deprecated                           | 类，方法表，字段表 | 被声明为deprecated的方法和字段                                                                                  |
| Exceptions                           | 方法表             | 方法抛出的异常                                                                                                  |
| EnclosingMethod                      | 类文件             | 仅当一个类为局部类或匿名类时才能拥有这个属性，这个属性用于标示这个类所在的外围方法                              |
| InnerClasses                         | 类文件             | 内部类列表                                                                                                      |
| LineNumberTable                      | Code属性           | Java源码的行号与字节码指令的对应关系                                                                            |
| LocalVariableTable                   | Code属性           | 方法的局部变量描述                                                                                              |
| StackMapTable                        | Code属性           | jdk1.6新增的属性，供新的类型检查验证器（Type Chcker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 |
| Signature                            | 类，方法表，字段表 | jdk1.5新增                                                                                                      |
| SourceFile                           | 类文件             | 记录源文件名称                                                                                                  |
| SourceDebugExtension                 | 类文件             | jdk1.6新增                                                                                                      |
| Synthetic                            | 类，方法表，字段表 | 标示方法或字段为编译器自动生成的                                                                                |
| LocalVariableTypeTable               | 类                 | jdk1.5新增，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型                                |
| RuntimeVisibleAnnotations            | 类，方法表，字段表 | jdk1.5新增                                                                                                      |
| RuntimeInvisibleAnnotations          | 类，方法表，字段表 | jdk1.5新增                                                                                                      |
| RuntimeVisibleParameterAnnocations   | 方法表             | jdk1.5新增                                                                                                      |
| RuntimeInvisibleParameterAnnotations | 方法表             | jdk1.5新增                                                                                                      |
| AnnotationDefault                    | 方法表             | jdk1.5新增                                                                                                      |
| BootstrapMethods                     | 类文件             | jdk1.7新增，保存invokedynamic指令引用的引导方法限定符                                                           |

对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可

属性表结构：

| 类型 |         名称         |       数量       |
|------|----------------------|------------------|
| u2   | attribute_name_index | 1                |
| u4   | attribute_length     | 1                |
| u1   | info                 | attribute_length |

##### Code属性

> Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内  
> Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据

Code属性表结构：

|      类型      |          名称          |          数量          |
|----------------|------------------------|------------------------|
| u2             | attribute_name_index   | 1                      |
| u4             | attribute_length       | 1                      |
| u2             | max_stack              | 1                      |
| u2             | max_locals             | 1                      |
| u4             | code_length            | 1                      |
| u1             | code                   | code_length            |
| u2             | exception_table_length | 1                      |
| exception_info | exception_table        | exception_table_length |
| u2             | attributes_count       | 1                      |
| attribute_info | attributes             | attributes_count       |

* attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，它代表了该属性的属性名称
* attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。
* max_stack代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。
    - 虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。
* max_locals代表了局部变量表所需的存储空间
    - max_locals的单位是Slot,Slot是虚拟机为局部变量分配内存所使用的最小单位
    - 对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放
    - 方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放
    - 并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小
* code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流
    - 每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解

代码解析参考《Class类文件的结构的javap及Hex图解》部分

*方法很明显都是没有参数的，为什么Args_size会为1？*  
*而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？*

> 在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。
> 这个访问机制对Java程序的编写很重要，而它的实现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。
> 因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。
> 这个处理只对实例方法有效，如果代码方法声明为static，那Args_size就不会等于1而是等于0了。

在字节码指令之后的是这个方法的显式异常处理表集合，异常表对于Code属性来说并不是必须存在的

| 类型 |    名称    | 数量 |
|------|------------|------|
| u2   | start_pc   |    1 |
| u2   | end_pc     |    1 |
| u2   | handler_pc |    1 |
| u2   | catch_type |    1 |

> 如果当字节码在第start_pc行（“行”是一种形象的描述，指的是字节码相对于方法体开始的偏移量，而不是Java源码的行号）到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。

*注意事项：指令执行时将此时结果x的值复制一份副本到最后一个本地变量表的Slot中（这个Slot里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为方法返回值使用，所以finally中的x值改变不会影响return值，而catch的结果会*

##### Exceptions属性

> Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常

| 类型 |          名称         |         数量         |
|------|-----------------------|----------------------|
| u2   | attribute_name_index  | 1                    |
| u4   | attribute_length      | 1                    |
| u2   | number_of_exceptions  | 1                    |
| u2   | exception_index_table | number_of_exceptions |

* number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常
* 每一种受查异常使用一个exception_index_table项表示，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型

##### LineNumberTable属性

> LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系  
> 如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点

|       类型       |           名称           |           数量           |
|------------------|--------------------------|--------------------------|
| u2               | attribute_name_index     | 1                        |
| u4               | attribute_length         | 1                        |
| u2               | line_number_table_length | 1                        |
| line_number_info | line_number_table        | line_number_table_length |

* line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合
* line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。

##### LocalVariableTable属性

> LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中  
> 如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值

LocalVariableTable属性结构：

|         类型        |             名称            |             数量            |
|---------------------|-----------------------------|-----------------------------|
| u2                  | attribute_name_index        | 1                           |
| u4                  | attribute_length            | 1                           |
| u2                  | local_variable_table_length | 1                           |
| local_variable_info | local_variable_table        | local_variable_table_length |

local_variable_info项目结构：

| 类型 |       名称       | 数量 |
|------|------------------|------|
| u2   | start_pc         |    1 |
| u2   | length           |    1 |
| u2   | name_index       |    1 |
| u2   | descriptor_index |    1 |
| u2   | index            |    1 |

* start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围
* name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符
* index是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个

> 在JDK 1.5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”：LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature），对于非泛型类型来说，描述符和特征签名能描述的信息是基本一致的

##### SourceFile属性

> SourceFile属性用于记录生成这个Class文件的源码文件名称  
> 对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名

SourceFile属性结构:

| 类型 |         名称         | 数量 |
|------|----------------------|------|
| u2   | attribute_name_index |    1 |
| u4   | attribute_length     |    1 |
| u2   | sourcefile_index     |    1 |

* sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。

##### ConstantValue属性

> ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性

对于非static类型的变量（也就是实例变量）的赋值是在实例构造器＜init＞方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器＜clinit＞方法中或者使用ConstantValue属性。  
目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是**基本类型**或者**java.lang.String**的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在＜clinit＞方法中进行初始化。

ConstantValue属性结构：

| 类型 |         名称         | 数量 |
|------|----------------------|------|
| u2   | attribute_name_index |    1 |
| u4   | attribute_length     |    1 |
| u2   | constantvalue_index  |    1 |

* ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2
* constantvalue_index数据项代表了常量池中一个字面量常量的引用
    - 根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info常量中的一种

##### InnerClasses属性

> InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性

InnerClasses属性结构：

|        类型        |         名称         |        数量       |
|--------------------|----------------------|-------------------|
| u2                 | attribute_name_index | 1                 |
| u4                 | attribute_length     | 1                 |
| u2                 | number_of_classes    | 1                 |
| inner_classes_info | inner_classes        | number_of_classes |

* 数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述

inner_classes_info表结构：

| 类型 |           名称           | 数量 |
|------|--------------------------|------|
| u2   | inner_class_info_index   |    1 |
| u2   | outer_class_info_index   |    1 |
| u2   | inner_name_index         |    1 |
| u2   | inner_class_access_flags |    1 |

* inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用
* inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，那么这项值为0
* inner_class_access_flags是内部类的访问标志，类似于类的access_flags

inner_class_access_flags标志：

|     标志名称     | 标志值 |             含义             |
|------------------|--------|------------------------------|
| ACC_PUBLIC       | 0x0001 | 内部类是否为public           |
| ACC_PRIVATE      | 0x0002 | 内部类是否为private          |
| ACC_PROTECTED    | 0x0004 | 内部类是否为protected        |
| ACC_STATIC       | 0x0008 | 内部类是否为static           |
| ACC_FINAL        | 0x0010 | 内部类是否为final            |
| ACC_SYNCHRONIZED | 0x0020 | 内部类是否为synchronized     |
| ACC_ABSTRACT     | 0x0400 | 内部类是否为abstract         |
| ACC_SYNTHETIC    | 0x1000 | 内部类是否并非用户代码产生的 |
| ACC_ANNOTATION   | 0x2000 | 内部类是否一个注解           |
| ACC_ENUM         | 0x4000 | 内部类是否是一个枚举         |

##### Deprecated及Synthetic属性

> Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。

*注意事项：Synthetic唯一的例外是实例构造器“＜init＞”方法和类构造器“＜clinit＞”方法。*

Deprecated和Synthetic属性结构：

| 类型 |         名称         | 数量 |
|------|----------------------|------|
| u2   | attribute_name_index |    1 |
| u4   | attribute_length     |    1 |

* attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置

##### StackMapTable属性

> StackMapTable属性在JDK 1.6发布后增加到了Class文件规范中，它是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。  
> 在版本号大于或等于50.0的Class文件中，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性。这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。

StackMapTable属性中包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束

|       类型      |           名称          |        数量       |
|-----------------|-------------------------|-------------------|
| u2              | attribute_name_index    | 1                 |
| u4              | attribute_length        | 1                 |
| u2              | number_of_entries       | 1                 |
| stack_map_frame | stack_map_frame_entries | number_of_entries |

##### Signature属性

> Signature属性在JDK 1.5发布后增加到了Class文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中  
> 现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性

Signature属性的结构：

| 类型 |         名称         | 数量 |
|------|----------------------|------|
| u2   | attribute_name_index |    1 |
| u4   | attribute_length     |    1 |
| u2   | signature_index      |    1 |

* signature_index项的值必须是一个对常量池的有效索引。
    - 常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名、方法类型签名或字段类型签名。
        + 如果当前的Signature属性是类文件的属性，则这个结构表示类签名
        + 如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名
        + 如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名

##### BootstrapMethods属性

> BootstrapMethods属性在JDK 1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符

BootstrapMethods属性的结构：

|       类型       |          名称         |          数量         |
|------------------|-----------------------|-----------------------|
| u2               | attribute_name_index  | 1                     |
| u4               | attribute_length      | 1                     |
| u2               | num_bootstrap_methods | 1                     |
| bootstrap_method | bootstrap_methods     | num_bootstrap_methods |

* num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量。
    - bootstrap_methods[]数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法，还包含了这个引导方法静态参数的序列（可能为空）

bootstrap_methods属性的结构：

| 类型 |           名称          |           数量          |
|------|-------------------------|-------------------------|
| u2   | bootstrap_method_ref    | 1                       |
| u2   | num_bootstrap_arguments | 1                       |
| u2   | bootstrap_arguments     | num_bootstrap_arguments |

* bootstrap_method_ref：bootstrap_method_ref项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。
* num_bootstrap_arguments：num_bootstrap_arguments项的值给出了bootstrap_arguments[]数组成员的数量。
* bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效索引。
    - 常量池在该索引处必须是下列结构之一
        + CONSTANT_String_info
        + CONSTANT_Class_info
        + CONSTANT_Integer_info
        + CONSTANT_Long_info
        + CONSTANT_Float_info
        + CONSTANT_Double_info
        + CONSTANT_MethodHandle_info
        + CONSTANT_MethodType_info

----------

*深入理解Java虚拟机，JVM高级特性与最佳实践*