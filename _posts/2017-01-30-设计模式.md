---  
layout: post  
title: 设计模式  
tags: 设计模式  
categories: Java  
published: true  
---  

## 面向对象思想设计原则

* 单一职责原则(高内聚，低耦合)
	- 每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个
* 开闭原则
	- 一个对象对扩展开放，对修改关闭，对类的改动是通过增加代码进行的，而不是修改现有代码
		+ 借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。
* 里氏替换原则
	- 在任何父类出现的地方都可以用它的子类来替代。
* 依赖注入原则
	- 要依赖于抽象，不要依赖于具体实现。
		+ 编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。
* 接口分离原则
	- 不应该强迫程序依赖它们不需要使用的方法。
		+ 一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。
* 迪米特原则
	- 一个对象应当对其他对象尽可能少的了解
		+ 降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用

### 设计原则（Head first设计模式）

* 找出程序中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起
* 针对接口编程，而不是针实现编程
* 多用组合，少用继承
* 为了交互对象之前的松耦合设计而努力
	- 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低
* 类应该对扩展开放，对修改关闭
* 要依赖冲向，不要依赖具体类（依赖倒置原则）
	- 变量不可以持有具体类的引用
	- 不要让类派生自具体类
	- 不要覆盖基类中已实现的方法

## 设计模式

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

### 设计模式分类

* 创建型模式(对象的创建)(6个)
	- 简单工厂模式（静态工厂方法模式）
	- 工厂方法模式
	- 抽象工厂模式
	- 建造者模式
	- 原型模式
	- 单例模式
* 行为型模式(对象的功能)(7个)
	- 外观模式
	- 适配器模式
	- 代理模式
	- 装饰模式
	- 桥接模式
	- 组合模式
	- 享元模式
* 结构型模式(对象的组成)(10个)
	- 模版方法模式
	- 观察者模式
	- 状态模式
	- 职责链模式
	- 命令模式
	- 访问者模式
	- 策略模式
	- 备忘录模式
	- 迭代器模式
	- 解释器模式

### 简单工厂模式（静态工厂方法模式）

所有工厂模式都用来封装对象的创建

又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责

* 缺点
	- 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护

```java
public class AnimalFactory {

	private AnimalFactory() {
	}

	// public static Dog createDog() {
	// return new Dog();
	// }
	//
	// public static Cat createCat() {
	// return new Cat();
	// }

	public static Animal createAnimal(String type) {
		if ("dog".equals(type)) {
			return new Dog();
		} else if ("cat".equals(type)) {
			return new Cat();
		} else {
			return null;
		}
	}
}

```

### 工厂方法模式

工厂方法模式定义了创建对象的接口，但由子类决定要实例化的是哪一个，工厂方法让类把实例化推迟到子类

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性

* 缺点
	- 需要额外的编写代码，增加了工作量

```java
public abstract class MethodFactory {
    private void prepare() {
        System.out.println("prepare");
    }
    private void finish() {
        System.out.println("finish");
    }
    protected abstract void operate();
    public void getReady() {
        prepare();
        operate();
        finish();
    }
}

public class MyMethodFactory extends MethodFactory {
    protected void operate() {
        System.out.println("my operate");
    }
}

@Test
public void operate() throws Exception {
    MethodFactory methodFactory = new MyMethodFactory();
    methodFactory.getReady();
    MethodFactory methodFactory = new MyMethodFactory1();
    methodFactory.getReady();
}
```

### 抽象工厂模式

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

```java
public interface AbstractFactory {
	public abstract Animal createAnimal();
}
```

```java
public class DogFactory implements AbstractFactory {
	@Override
	public Animal createAnimal() {
		return new Dog();
	}
}
```

```java
public class CatFactory implements AbstractFactory {
	@Override
	public Animal createAnimal() {
		return new Cat();
	}
}
```

```java
AbstractFactory f = new DogFactory();
Animal a = f.createAnimal();
a.eat();

f = new CatFactory();
a = f.createAnimal();
a.eat();
```

### 工厂方法模式和抽象工厂模式

* 工厂方法模式通过子类创建对象，抽象工厂通过实现类（对象组合）创建对象
* 抽象工厂的方法常以工厂方法模式实现
* 抽象工厂和工厂方法用于实例化具体类的解耦
* 抽象工厂用于创建产品家族和想让制造的相关产品集合起来

### 单例设计模式

确保一个类只有一个实例，并提供一个全局访问点

单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。

* 优点
	- 在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
	- 可以延迟实例化
* 缺点
	- 没有抽象层，因此扩展很难。
	- 职责过重，在一定程序上违背了单一职责

#### 设计思想

保证类在内存中只有一个对象

**如何实现类在内存中只有一个对象呢?**

* 构造私有
* 本身提供一个对象
* 通过公共的方法让外界访问

#### 饿汉式(开发)

```java
public class Singleton {
	// 构造私有
	private Singleton() {
	}

	// 自己造一个
	// 静态方法只能访问静态成员变量，加静态
	// 为了不让外界直接访问修改这个值，加private
	private static Singleton s = new Singleton();

	// 提供公共的访问方式
	// 为了保证外界能够直接使用该方法，加静态
	public static Singleton getSingleton() {
		return s;
	}
}
```

#### 懒汉式

线程安全问题

懒加载思想(延迟加载)

```java
public class Singleton {
	private Singleton() {
	}
	// 使用volatile禁止指令重排
	private volatile static  Singleton t = null;
	// 锁范围较大
	public synchronized static Singleton getSingleton() {
		if (t == null) {//这里有线程安全问题 所以要枷加锁
			t = new Singleton();
		}
		return t;
	}
	// 缩小锁范围，但是要做双重检查 jdk 1.5以后有效
	public static Singleton getSingleton() {
		if (t == null) {
			synchronized(Singleton.class){
				if (t == null) {// 双重检查
					t = new Singleton();
				}
			}
		}
		return t;
	}
}
```

#### 内部类方式（static holder）

既支持了延迟加载，也是线程安全的，较完美的解决方案

> **多线程缺省同步锁的知识：**
> 解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制，但是在某些情况下，JVM已经隐含的为您执行了同步，不用自己再来进行同步控制。  
> 
> 1. 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时  
> 2. 访问final字段时  
> 3. 在创建线程之前创建对象时  
> 4. 线程可以看见它将要处理的对象时  

> 要想很简单的实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是会浪费一定的时间空间？因为这种实现方式，会在类装载的时候就初始化对象。

> 一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同步实现延迟加载和线程安全。

```java
public class Singleton {
    private static class StaticHolder {
        private static Singleton instance;
        static {
            instance = new Singleton();
        }
    }
    private Singleton(){
    }
    public static Singleton getInstance() {
        return StaticHolder.instance;
    }
}
```

#### 枚举式（推荐）

好处

1. 线程安全（枚举底层是线程安全的）
2. 不会因为序列化而产生新的实例（因为它自己实现了readResolve方法）
3. 防止反射攻击。（因为enum实际上是abstract的）

```java
public enum Singleton {
    INSTANCE;
    Singleton() {
    }
    public void operate() {
    }
}
```

#### 类加载器和jdk1.2垃圾回收问题

*多个类加载器会在各自的命名空间下加载同一个类，造成存在一个类的多一个实例*

解决：指定同一个类加载器加载

*JDK1.2之前会将单例模式认为是没有引用而回收，再次getInstance()又创建一个对象*

解决：建立单例注册表...使用全局引用指向单例？

### 模版设计模式

模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现

* 优点
	- 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，既兼顾了原则性，有不失灵活性
* 缺点
	- 如果算法骨架有修改的话，则需要修改抽象类

```java
public abstract class GetTime {
	// 需求：请给我计算出一段代码的运行时间
	public long getTime() {
		long start = System.currentTimeMillis();

		code();

		long end = System.currentTimeMillis();

		return end - start;
	}

	public abstract void code();
}
```

```java
public class ForDemo extends GetTime {

	@Override
	public void code() {
		for (int x = 0; x < 100000; x++) {
			System.out.println(x);
		}
	}

}
```

### 装饰者模式

动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的方案

装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案

* 优点
	- 使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能
* 缺点
	- 正因为可以随意组合，所以就可能出现一些不合理的逻辑

```java
public interface Phone {
	public abstract void call();
}
```

```java
public class IPhone implements Phone {

	@Override
	public void call() {
		System.out.println("手机可以打电话了");
	}

}
```

```java
// 装饰抽象类
public abstract class PhoneDecorate implements Phone {

	private Phone p;

	public PhoneDecorate(Phone p) {
		this.p = p;
	}

	@Override
	public void call() {
		this.p.call();
	}
}
```

```java
public class MusicPhoneDecorate extends PhoneDecorate {

	public MusicPhoneDecorate(Phone p) {
		super(p);
	}

	@Override
	public void call() {
		super.call();
		System.out.println("手机可以听音乐");
	}
}
```

```java
public class RingPhoneDecorate extends PhoneDecorate {

	public RingPhoneDecorate(Phone p) {
		super(p);
	}

	@Override
	public void call() {
		System.out.println("手机可以听彩铃");
		super.call();
	}
}
```

```java
Phone p = new IPhone();
p.call();
System.out.println("------------");

// 需求：我想在接电话前，听彩铃
PhoneDecorate pd = new RingPhoneDecorate(p);
pd.call();// 听彩铃打电话

// 需求：我想在接电话后，听音乐
pd = new MusicPhoneDecorate(p);
pd.call();// 打电话听音乐

// 需求：我要想手机在接前听彩铃，接后听音乐
// 自己提供装饰类，在打电话前听彩铃，打电话后听音乐或者嵌套使用装饰类
pd = new RingPhoneDecorate(new MusicPhoneDecorate(p));
pd.call();// 同时听彩铃打电话听音乐
```

```java
// Jdk中的装饰模式
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Scanner sc = new Scanner(System.in);
```

### 适配器设计模式

将一个类的接口转换成另外一个客户希望的接口。从而使原来不能直接调用的接口变的可以调用。

* 优点
	- 让本来不适合使用的接口变得适合使用
* 缺点
	- 一次只能适配一个类，使用有一定的局限性

```java
/*
 * 针对用户操作的四种功能接口
 */
public interface UserDao {
	public abstract void add();

	public abstract void delete();

	public abstract void update();

	public abstract void find();
}
```

```java
//适配器类
public abstract class UserAdapter implements UserDao {

	@Override
	public void add() {
	}

	@Override
	public void delete() {
	}

	@Override
	public void update() {
	}

	@Override
	public void find() {
	}

}
```

```java
// 适配器模式实现类
public class UserDaoImpl2 extends UserAdapter {
	@Override
	public void add() {
		System.out.println("添加功能");
	}
}
```

### 桥接模式

使用聚合代替继承，解决两个维度排列组合问题

### 享元模式

享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。  
例如IntegerCache和String字符串常量池

### 观察者模式
 
观察者模式定义了对象之间的一(Subject)对多(Observer)依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

jdk自带了观察者模式实现，Observable类和Observer接口，但是Observable是一个类并没有实现任何接口所以很局限

```java
// 主题
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

public class MySubject implements Subject {
    private String message;
    List<Observer> observers = new ArrayList<Observer>();
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this, this);
        }
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
}
// 观察者
public interface Observer {
    void update(Subject subject, Object args);
}

public class MyObserver implements Observer {
    public MyObserver(Subject subject) {
        subject.registerObserver(this);
    }
    public void update(Subject subject, Object args) {
        if (subject instanceof MySubject) {
            MySubject mySubject = (MySubject) args;
            System.out.println(mySubject.getMessage());
        }
    }
}
//测试
@Test
public void update() throws Exception {
    MySubject subject = new MySubject();
    MyObserver myObserver = new MyObserver(subject);
    MyObserver myObserver1 = new MyObserver(subject);
    MyObserver myObserver2 = new MyObserver(subject);
    MyObserver myObserver3 = new MyObserver(subject);
    MyObserver myObserver4 = new MyObserver(subject);
    subject.setMessage("hello");
    subject.notifyObservers();
}
```

### 责任链模式

```java
public interface Filter {
    void doFilter(Request request, Response response, FilterChain filterChain);
}

public class MyFirstFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "first";
        filterChain.doFilter(request, response, filterChain);
        response.output += "first";
    }
}

public class MySecondFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "second";
        filterChain.doFilter(request, response, filterChain);
        response.output += "second";
    }
}
//过滤器链
public class FilterChain {
    private List<Filter> filters = new ArrayList<Filter>();
    Iterator<Filter> iterator;
    public FilterChain addFilter(Filter filter) {
        filters.add(filter);
        return this;
    }
    public FilterChain addFilter(FilterChain filterChain) {
        filters.addAll(filterChain.filters);
        return this;
    }
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        if (iterator == null) {
            iterator = filters.iterator();
        }
        if (iterator.hasNext()) {
            iterator.next().doFilter(request, response, filterChain);
        }
    }
}
```

### 策略模式

定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户

具体比较方法交给不同的装配策略实现，AOP中的advice也是策略模式

Comparable和Comparator

```java
public class MyNumber implements Comparable<MyNumber> {
    int value;
    private Comparator<MyNumber> myNumberComparator;
    public MyNumber(Comparator<MyNumber> myNumberComparator) {
        this.myNumberComparator = myNumberComparator;
    }
    @Override
    public int compareTo(MyNumber o) {
        return myNumberComparator.compare(this, o);
    }
    public int getValue() {
        return value;
    }
    public void setValue(int value) {
        this.value = value;
    }
}
```

```java
public class MyComparator implements Comparator<MyNumber> {
    @Override
    public int compare(MyNumber o1, MyNumber o2) {
        return o1.value - o2.value;
    }
}
```

----------

*以上概念总结于传智播客Java基础课程*