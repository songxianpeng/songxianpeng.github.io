---  
lajout: post  
title: IO流  
tags: IO File  
categories: Java  
published: true  
---  

## File

文件和目录(文件夹)路径名的抽象表示形式

> 仅仅是一个路径的表示，不代码具体的事物一定是存在的。

### list()方法

通过参数FilenameFilter限定符合要求的文件或目录

```java
// 封装e判断目录
File file = new File("d:\\");

// 获取该目录下所有文件或者文件夹的String数组
// public String[] list(FilenameFilter filter)
String[] strArray = file.list(new FilenameFilter() {
	@Override
	public boolean accept(File dir, String name) {
		return new File(dir, name).isFile() && name.endsWith(".jpg");
	}
});

// 遍历
for (String s : strArray) {
	System.out.println(s);
}
```

### 递归遍历文件夹

```java
private static void getAllJavaFilePaths(File srcFolder) {
	// 获取该目录下所有的文件或者文件夹的File数组
	File[] fileArray = srcFolder.listFiles();

	// 遍历该File数组，得到每一个File对象
	for (File file : fileArray) {
		// 判断该File对象是否是文件夹
		if (file.isDirectory()) {
			getAllJavaFilePaths(file);
		} else {
			// 继续判断是否以.java结尾
			if (file.getName().endsWith(".java")) {
				// 就输出该文件的绝对路径
				System.out.println(file.getAbsolutePath());
			}
		}
	}
}
```

## IO流

### 分类

* 按照数据流向
	- 输入流
	- 输出流
* 按照数据类型（默认）
	- 字节流
		+ 字节输入流
		+ 字节输出流
	- 字符流
		+ 字符输入流
		+ 字符输出流

### 基类

* 字节流的抽象基类及子类：
	- InputStream
		+ FileInputStream
		+ BufferedInputStream
	- OutputStream
		+ FileOutputStream
		+ BufferedOutputStream
* 字符流的抽象基类及子类：
	- Reader
		+ FileReader
		+ BufferedReader
	- Writer
		+ FileWriter
		+ BufferedWriter

![IO流小结图解](/static/img/IO流/IO流小结图解.jpg "IO流小结图解")

### 字节流

#### FileOutputStream和FileInputStream

```java
// 基本字节流一次读写一个字节数组
public static void method2(String srcString, String destString)
		throws IOException {
	FileInputStream fis = new FileInputStream(srcString);
	FileOutputStream fos = new FileOutputStream(destString);

	byte[] bys = new byte[1024];
	int len = 0;
	while ((len = fis.read(bys)) != -1) {
		fos.write(bys, 0, len);
	}

	fos.close();
	fis.close();
}

// 基本字节流一次读写一个字节
public static void method1(String srcString, String destString)
		throws IOException {
	FileInputStream fis = new FileInputStream(srcString);
	FileOutputStream fos = new FileOutputStream(destString);

	int by = 0;
	while ((by = fis.read()) != -1) {
		fos.write(by);
	}

	fos.close();
	fis.close();
}
```

#### 换行符

* windows:`\r\n`
* linux:`\n`
* Mac:`\r`

#### 追加文件

```java
// 创建一个向具有指定 name 的文件中写入数据的输出文件流。
// 如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。
FileOutputStream fos = new FileOutputStream("fos3.txt", true);
```

#### 创建字节输出流对象做了几件事情?

1. 调用系统功能去创建文件
2. 创建fos对象
3. 把fos对象指向这个文件

### 字节缓冲区流

#### BufferedOutputStream和BufferedInputStream

```java
// 高效字节流一次读写一个字节数组：
public static void method4(String srcString, String destString)
		throws IOException {
	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(
			srcString));
	//为什么不传递一个具体的文件或者文件路径，而是传递一个OutputStream对象?
	//因为字节缓冲区流仅仅提供缓冲区，为高效而设计的。真正的读写操作还是基本的流对象实现。

	//构造方法可以指定缓冲区的大小，但是我们一般不用，默认缓冲区大小就够了
	BufferedOutputStream bos = new BufferedOutputStream(
			new FileOutputStream(destString));

	byte[] bys = new byte[1024];
	int len = 0;
	while ((len = bis.read(bys)) != -1) {
		bos.write(bys, 0, len);
	}

	bos.close();
	bis.close();
}

// 高效字节流一次读写一个字节：
public static void method3(String srcString, String destString)
		throws IOException {
	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(
			srcString));
	BufferedOutputStream bos = new BufferedOutputStream(
			new FileOutputStream(destString));

	int by = 0;
	while ((by = bis.read()) != -1) {
		bos.write(by);

	}

	bos.close();
	bis.close();
}
```

### 字符流

**计算机是如何识别什么时候该把两个字节转换为一个中文呢?**

> 在计算机中中文的存储分两个字节：  
>> 第一个字节肯定是负数。  
>> 第二个字节常见的是负数，可能有正数。但是没影响。  

```java
// String s = "abcde";
// // [97, 98, 99, 100, 101]

String s = "我爱你中国";
// [-50, -46, -80, -82, -60, -29, -42, -48, -71, -6]

byte[] bys = s.getBytes();
System.out.println(Arrays.toString(bys));
```

由于字节流操作中文不是特别方便，所以，java就提供了转换流。  
转换流其实是一个字符流
> 字符流=字节流+编码表。

#### 编码表

> 计算机只能识别二进制数据，早期由来是电信号。  
> 为了方便应用计算机，让它可以识别各个国家的文字。  
> 就将各个国家的文字用数字来表示，并一一对应，形成一张表。  
> 
> ASCII：美国标准信息交换码。用一个字节的7位可以表示。  
> ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。  
> GB2312：中国的中文编码表。  
> GBK：中国的中文编码表升级，融合了更多的中文文字符号。  
> GB18030：GBK的取代版本  
> BIG-5码 ：通行于台湾、香港地区的一个繁体字编码方案，俗称“大五码”。  
> Unicode：国际标准码，融合了多种文字。所有文字都用两个字节来表示,Java语言使用的就是unicode  
> UTF-8：最多用三个字节来表示一个字符。  
> 
> UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容：  
> 它将Unicode编码为00000000-0000007F的字符，用单个字节来表示  
> 它将Unicode编码为00000080-000007FF的字符用两个字节表示  
> 它将Unicode编码为00000800-0000FFFF的字符用3字节表示 

#### OutputStreamWriter和InputStreamReader

```java
InputStreamReader isr = new InputStreamReader(new FileInputStream(
		"a.txt"));
// 封装目的地
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(
		"b.txt"));

// 读写数据
// 方式1
// int ch = 0;
// while ((ch = isr.read()) != -1) {
// osw.write(ch);
// }

// 方式2
char[] chs = new char[1024];
int len = 0;
while ((len = isr.read(chs)) != -1) {
	osw.write(chs, 0, len);
	// osw.flush();
}

// 释放资源
osw.close();
isr.close();
```

#### FileWriter和FileReader

使用默认本地编码表的InputStreamReader和OutputStreamReader封装类

```java
// 基本字符流一次读写一个字符数组
private static void method2(String srcString, String destString)
		throws IOException {
	FileReader fr = new FileReader(srcString);
	FileWriter fw = new FileWriter(destString);

	char[] chs = new char[1024];
	int len = 0;
	while ((len = fr.read(chs)) != -1) {
		fw.write(chs, 0, len);
	}

	fw.close();
	fr.close();
}

// 基本字符流一次读写一个字符
private static void method1(String srcString, String destString)
		throws IOException {
	FileReader fr = new FileReader(srcString);
	FileWriter fw = new FileWriter(destString);

	int ch = 0;
	while ((ch = fr.read()) != -1) {
		fw.write(ch);
	}

	fw.close();
	fr.close();
}
```

#### BufferedReader和BufferedWriter

```java
// 字符缓冲流一次读写一个字符串
private static void method5(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	String line = null;
	while ((line = br.readLine()) != null) {
		bw.write(line);
		bw.newLine();
		bw.flush();
	}

	bw.close();
	br.close();
}

// 字符缓冲流一次读写一个字符数组
private static void method4(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	char[] chs = new char[1024];
	int len = 0;
	while ((len = br.read(chs)) != -1) {
		bw.write(chs, 0, len);
	}

	bw.close();
	br.close();
}
// 字符缓冲流一次读写一个字符
private static void method3(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	int ch = 0;
	while ((ch = br.read()) != -1) {
		bw.write(ch);
	}

	bw.close();
	br.close();
}
```

### 数据操作流

可以操作基本类型的数据

* DataInputStream
* DataOutputStream

```java
private static void write() throws IOException {
	// DataOutputStream(OutputStream out)
	// 创建数据输出流对象
	DataOutputStream dos = new DataOutputStream(new FileOutputStream(
			"dos.txt"));

	// 写数据了
	dos.writeByte(10);
	dos.writeShort(100);
	dos.writeInt(1000);
	dos.writeLong(10000);
	dos.writeFloat(12.34F);
	dos.writeDouble(12.56);
	dos.writeChar('a');
	dos.writeBoolean(true);

	// 释放资源
	dos.close();

	// dos.txt
	// 0a00 6400 0003 e800 0000 0000 0027 1041
	// 4570 a440 291e b851 eb85 1f00 6101 
}

private static void read() throws IOException {
	// DataInputStream(InputStream in)
	// 创建数据输入流对象
	DataInputStream dis = new DataInputStream(
			new FileInputStream("dos.txt"));

	// 读数据
	byte b = dis.readByte();
	short s = dis.readShort();
	int i = dis.readInt();
	long l = dis.readLong();
	float f = dis.readFloat();
	double d = dis.readDouble();
	char c = dis.readChar();
	boolean bb = dis.readBoolean();

	// 释放资源
	dis.close();

	System.out.println(b);// 10
	System.out.println(s);// 100
	System.out.println(i);// 1000
	System.out.println(l);// 10000
	System.out.println(f);// 12.34
	System.out.println(d);// 12.56
	System.out.println(c);// a
	System.out.println(bb);// true
}
```


### 内存操作流

有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。

* ByteArrayInputStream,ByteArrayOutputStream
* CharArrayReader,CharArrayWriter
* StringReader,StringWriter

### 打印流概述

* 字节流打印流 PrintStream
* 字符打印流 PrintWriter

```java
// 复制文本文件
BufferedReader br = new BufferedReader(new FileReader("a.txt"));
PrintWriter pw = new PrintWriter(new FileWriter("b.txt"),true);// 启动自动刷新

String line = null;
while((line=br.readLine())!=null) {
	pw.println(line);
}

pw.close();
br.close();
```

#### 特点

* 只有写数据的，没有读取数据。只能操作目的地，不能操作数据源。
* 可以操作任意类型的数据
* 如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新
* 可以直接操作文件

### 标准输入输出流

System类中的字段：in，out

> 它们各代表了系统标准的输入和输出设备。  
> 默认输入设备是键盘，输出设备是显示器。

* System.in的类型是InputStream.
* System.out的类型是PrintStream,是OutputStream的子类FilterOutputStream 的子类.

#### 三种键盘录入方式

* main方法的args接收参数
* System.in通过BufferedReader进行包装
	- BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
* Scanner
	- Scanner sc = new Scanner(System.in);

#### 输出语句的原理

```java
System.out.println("helloworld");

PrintStream ps = System.out;
ps.println("helloworld");

// 把System.out用字符缓冲流包装一下使用
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
```

### 随机访问流

RandomAccessFile类不属于流，是Object类的子类。  
但它融合了InputStream和OutputStream的功能。  
支持对文件的随机访问读取和写入。  

```java
private static void write() throws IOException {
	// 创建随机访问流对象
	RandomAccessFile raf = new RandomAccessFile("raf.txt", "rw");

	// 怎么玩呢?
	raf.writeInt(100);
	raf.writeChar('a');
	raf.writeUTF("中国");

	raf.close();
}

private static void read() throws IOException {
	// 创建随机访问流对象
	RandomAccessFile raf = new RandomAccessFile("raf.txt", "rw");

	int i = raf.readInt();
	System.out.println(i);
	// 该文件指针可以通过 getFilePointer方法读取，并通过 seek 方法设置。
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	char ch = raf.readChar();
	System.out.println(ch);
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	String s = raf.readUTF();
	System.out.println(s);
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	// 我不想重头开始了，我就要读取a，怎么办呢?
	raf.seek(4);
	ch = raf.readChar();
	System.out.println(ch);
}
```

### 合并流

把多个输入流的数据写到一个输出流中

* SequenceInputStream(InputStream s1, InputStream s2) 
* SequenceInputStream(Enumeration<? extends InputStream> e) 

```java
// 两个
InputStream s1 = new FileInputStream("ByteArrayStreamDemo.java");
InputStream s2 = new FileInputStream("DataStreamDemo.java");
SequenceInputStream sis = new SequenceInputStream(s1, s2);

// 多个
// SequenceInputStream(Enumeration e)
// 通过简单的回顾我们知道了Enumeration是Vector中的一个方法的返回值类型。
// Enumeration<E> elements()
Vector<InputStream> v = new Vector<InputStream>();
InputStream s1 = new FileInputStream("ByteArrayStreamDemo.java");
InputStream s2 = new FileInputStream("CopyFileDemo.java");
InputStream s3 = new FileInputStream("DataStreamDemo.java");
v.add(s1);
v.add(s2);
v.add(s3);
Enumeration<InputStream> en = v.elements();
SequenceInputStream sis = new SequenceInputStream(en);
BufferedOutputStream bos = new BufferedOutputStream(
		new FileOutputStream("Copy.java"));

// 如何写读写呢，其实很简单，你就按照以前怎么读写，现在还是怎么读写
byte[] bys = new byte[1024];
int len = 0;
while ((len = sis.read(bys)) != -1) {
	bos.write(bys, 0, len);
}

bos.close();
sis.close();
```

### 序列化流

可以把对象写入文本文件或者在网络中传输

* 序列化流：把对象按照流一样的方式存入文本文件或者在网络中传输。对象 -- 流数据(ObjectOutputStream)
* 反序列化流:把文本文件中的流对象数据或者网络中的流对象数据还原成对象。流数据 -- 对象(ObjectInputStream)

```java
private static void read() throws IOException, ClassNotFoundException {
	// 创建反序列化对象
	ObjectInputStream ois = new ObjectInputStream(new FileInputStream(
			"oos.txt"));

	// 还原对象
	Object obj = ois.readObject();

	// 释放资源
	ois.close();

	// 输出对象
	System.out.println(obj);
}

private static void write() throws IOException {
	// 创建序列化流对象
	ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(
			"oos.txt"));

	// 创建对象
	Person p = new Person("林青霞", 27);

	// public final void writeObject(Object obj)
	oos.writeObject(p);

	// 释放资源
	oos.close();
}
```

#### 序列化和反序列化

对象序列化是将对象状态转换为可保持或传输的过程。一般的格式是与平台无关的二进制流，可以将这种二进制流持久保存在磁盘上，也可以通过网络将这种二进制流传输到另一个网络结点。  
对象反序列化，是指把这种二进制流数据还原成对象。

#### 如何实现序列化

* 让被序列化的对象所属类实现序列化接口。
* 该接口是一个标记接口。没有功能需要实现。
* 使用transient关键字声明不需要序列化的成员变量

**序列化数据后，再次修改类文件，读取数据会出问题，如何解决呢?**

在类文件中，给出一个固定的序列化id值。

### Properties集合

是一个集合类，Hashtable的子类

#### Properties和IO流的结合使用

* 把键值对形式的文本文件内容加载到集合中
	- public void load(Reader reader)
	- public void load(InputStream inStream)
* 把集合中的数据存储到文本文件中
	- public void store(Writer writer,String comments)
	- public void store(OutputStream out,String comments)

```java
private static void myStore() throws IOException {
	// 创建集合对象
	Properties prop = new Properties();

	prop.setProperty("林青霞", "27");
	prop.setProperty("武鑫", "30");
	prop.setProperty("刘晓曲", "18");
	
	//public void store(Writer writer,String comments):把集合中的数据存储到文件
	Writer w = new FileWriter("name.txt");
	prop.store(w, "helloworld");
	w.close();
}

private static void myLoad() throws IOException {
	Properties prop = new Properties();

	// public void load(Reader reader):把文件中的数据读取到集合中
	// 注意：这个文件的数据必须是键值对形式
	Reader r = this.getClass().getResourceAsStream("prop.txt");// 这里提供过getResourceAsStream()方法获取
	prop.load(r);
	r.close();

	System.out.println("prop:" + prop);
}
```

## NIO

> JDK4出现NIO。新IO和传统的IO有相同的目的，都是用于进行输入输出的，但新IO使用了不同的方式来处理输入输出，采用内存映射文件的方式，将文件或者文件的一段区域映射到内存中，就可以像访问内存一样的来访问文件了，这种方式效率比旧IO要高很多，但是目前好多地方我们看到的还是旧IO的引用，所以我们仍以旧IO为主，知道NIO即可。

* Path:路径
* Paths:有一个静态方法返回一个路径
	- public static Path get(URI uri)
* Files:提供了静态方法供我们使用
	- public static long copy(Path source,OutputStream out):复制文件
	- public static Path write(Path path,Iterable<? extends CharSequence> lines,Charset cs,OpenOption... options)

```java
Files.copy(Paths.get("ByteArrayStreamDemo.java"), new FileOutputStream("Copy.java"));

ArrayList<String> array = new ArrayList<String>();
array.add("hello");
array.add("world");
array.add("java");
Files.write(Paths.get("array.txt"), array, Charset.forName("GBK"));
```
----------

*以上概念总结于传智播客Java基础课程*