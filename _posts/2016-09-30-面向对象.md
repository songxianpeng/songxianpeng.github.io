---  
layout: post  
title: 面向对象  
tags: Java基础 method 面向对象  
categories: Java  Object-Oriented  
published: true  
---  

## 类和对象

* 类：是一组相关的属性和行为的集合。是一个抽象的概念。
* 对象：是该类事物的具体存在，是一个具体的实例。

## 变量

* 成员变量
* 局部变量

### 成员变量和局部变量的区别

* 在类中的位置不同
	- 成员变量 类中方法外
	- 局部变量 方法内或者方法声明上
* 在内存中的位置不同
	- 成员变量 堆内存
	- 局部变量 栈内存
* 生命周期不同
	- 成员变量 随着对象的存在而存在，随着对象的消失而消失
	- 局部变量 随着方法的调用而存在，随着方法的调用完毕而消失
* 初始化值不同
	- 成员变量 有默认的初始化值
	- 局部变量 没有默认的初始化值，必须先定义，赋值，才能使用。

**注意事项：***局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。*

## 构造方法

**注意事项:**

* 如果我们没有给出构造方法，系统将自动提供一个无参构造方法。
* 如果我们给出了构造方法，系统将不再提供默认的无参构造方法。
	- 这个时候，如果我们还想使用无参构造方法，就必须自己给出。*建议永远自己给出无参构造方法*


## 代码块

在Java中，使用`{}`括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。

* 局部代码块 
	- 在方法中出现；限定变量生命周期，及早释放，提高内存利用率
* 构造代码块 
	- 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行
* 静态代码块 在类中方法外出现，加了static修饰
	- 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载类的时候就执行，并且值执行一次。

```java
class OOP {
    static {
        System.out.println("OOP static1");
    }

    //构造代码块
    {
        System.out.println("OOP 构造代码块1");
    }

    //构造方法
    public OOP() {
        System.out.println("OOP 构造方法1");
    }

    //构造方法
    public OOP(int a) {
        System.out.println("OOP 构造方法2");
    }

    //构造代码块
    {
        System.out.println("OOP 构造代码块2");
    }

    //静态代码块
    static {
        System.out.println("OOP static2");
    }
}

class OOP1 {
    static {
        System.out.println("OOP1 static");
    }
}

class OOP2 {
    static {
        System.out.println("OOP2 static");
    }

    public static void staticMethod() {
        System.out.println("staticMethod");
    }
}

class OOPDemo {
    static {
        System.out.println("static");
    }

    public static void method() {
        System.out.println("method");
        OOP1 oop1 = new OOP1();
    }

    public static void main(String[] args) {
        System.out.println("main");
        method();//类用到的时候static才加载
        System.out.println("---------------");
        //局部代码块
        {
            int x = 10;
            System.out.println(x);
        }
        //找不到符号
        //System.out.println(x);
        {
            int y = 20;
            System.out.println(y);
        }
        System.out.println("---------------");
        OOP c = new OOP();
        System.out.println("---------------");
        OOP c2 = new OOP();
        System.out.println("---------------");
        OOP c3 = new OOP(1);
        System.out.println("---------------");
        OOP2.staticMethod();//调用静态方法的时候不走构造方法和构造代码块，但是走静态代码块
    }
}

// static
// main
// method
// OOP1 static
// ---------------
// 10
// 20
// ---------------
// OOP static1
// OOP static2
// OOP 构造代码块1
// OOP 构造代码块2
// OOP 构造方法1
// ---------------
// OOP 构造代码块1
// OOP 构造代码块2
// OOP 构造方法1
// ---------------
// OOP 构造代码块1
// OOP 构造代码块2
// OOP 构造方法2
// ---------------
// OOP2 static
// staticMethod
```

## 匿名对象

就是没有名字的对象。
	
### 匿名对象好出

匿名对象可以作为实际参数传递，调用完毕就是垃圾。可以被垃圾回收器回收。

## 继承

* 好处：
	- 提高了代码的复用性
	- 提高了代码的维护性
	- 让类与类之间产生了关系，是多态的前提
* 弊端：
	- 类的耦合性增强了
	- 打破了封装性

**注意事项**

* 子类只能继承父类所有非私有的成员(成员方法和成员变量)
* 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法
* 不要为了部分功能而去继承

### 方法重写

* 父类中私有方法不能被重写
	- 因为父类私有方法子类根本就无法继承
* 子类重写父类方法时，访问权限不能更低
	- 最好就一致
* 父类静态方法，子类也必须通过静态方法进行重写
	- 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中讲解
	
*子类重写父类方法的时候，最好声明一模一样。*

### 继承中构造方法的关系

子类中所有的构造方法默认都会访问父类中空参数的构造方法,因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。

* 子类每一个构造方法的第一条语句默认都是：super();
* 可以通过super(...);或者this(...);语句直接或简介调用父类构造方法完成父类初始化
* this(...)或者super(...)必须出现在第一条语句上。
	- 如果不是放在第一条语句上，就可能对父类的数据进行了多次初始化，所以必须放在第一条语句上。

```java
class Father {
    static {
        System.out.println("静态代码块Fu");
    }

    {
        System.out.println("构造代码块Fu");
    }

    public Father() {
        System.out.println("Fu的无参构造方法");
    }

    public Father(String name) {
        System.out.println("Fu的带参构造方法");
    }
}

class Son extends Father {
    static {
        System.out.println("静态代码块Zi");
    }

    {
        System.out.println("构造代码块Zi");
    }

    public Son() {
        //super();
        System.out.println("Zi的无参构造方法");
    }

    public Son(String name) {
        //super();
        System.out.println("Zi的带参构造方法");
    }
}

class ExtendsDemo {
    public static void main(String[] args) {
        //创建对象
        Son s = new Son();
        System.out.println("------------");
        Son s2 = new Son("林青霞");
    }
}

// 静态代码块Fu
// 静态代码块Zi
// 构造代码块Fu
// Fu的无参构造方法
// 构造代码块Zi
// Zi的无参构造方法
// ------------
// 构造代码块Fu
// Fu的无参构造方法
// 构造代码块Zi
// Zi的带参构造方法
```

### 继承中的初始化过程

* 静态代码块 > 构造代码块 > 构造方法
* 一个类的初始化过程
	- 成员变量的初始化
		+ 默认初始化
		+ 显示初始化
		+ 构造方法初始化
* 子父类的初始化(分层初始化)
	- 先进行父类初始化，然后进行子类初始化。

```java
class X {
    Y b = new Y();

    X() {
        System.out.print("X");
    }
}

class Y {
    Y() {
        System.out.print("Y");
    }
}

class Z extends X {
    Y y = new Y();

    Z() {
        //super
        System.out.print("Z");
    }

    public static void main(String[] args) {
        new Z();
    }
}
//YXYZ
```

----------

*以上概念总结于传智播客Java基础课程*