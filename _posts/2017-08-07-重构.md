---  
layout: post  
title: 重构  
tags: 重构 Refactoring  
categories: JavaEE  
published: true  
---  

重构是不改变软件可观察行为的前提下改善其内部结构(在代码写好之后改进它的设计)

### 导致程序难以修改的原因

* 难以阅读
* 逻辑重复
* 添加新行为时需要修改已有代码
* 带复杂条件逻辑

### 为什么重构

* 重构改进软件设计
* 重构使软件更容易理解
* 重构帮助找到bug
* 重构提高编程速度

**间接层的价值**

间接层是一把双刃剑

* 缺点：
	- 每次把一个东西分成两份，你就需要多管理一个东西
	- 如果某个对象委托另一对象，层级较多后程序会愈加难以阅读
* 优点：（解释能力、共享能力、选择能力）
	- 实现逻辑共享
	- 分开解释意图和实现
		+ 类名、函数名和功能分解帮助我们理解程序和意图
	- 隔离变化
	- 封装条件逻辑（如状态模式代替switch）

### 重构难题

* 数据库
	- 在对象模型和数据库模型之间插入一个分割层，隔离两个模型各自的变化
* 接口
	- 让就接口调用新接口
	- 接口异常使用自定义的基类异常，这样避免日后子类异常类型带来的接口修改负担
* 重写
	- 现在代码根本不能正常运作（大部分情况下）作为一个清楚讯号
		+ 拆分组件后考虑各模块重构还是重写
* 性能
	- 重构有助于找到影响性能的一小段代码进行优化

### 重构时机

* 三次法则
	- 第一次做某事时只管去做
	- 第二次做类似的事情会反感，但无论如何还是可以去做
	- 第三次再做类似的事，你就应该重构
* 添加功能时
	- 如果你发现自己需要程序添加一个特性，而代码结构使你无法很方便的达成目的，那就先重构那个程序，是特性的添加比较容易进行，然后再添加特性
* 修补错误时
	- 如果收到一份错误报告，这就是需要重构的信号，因为程序没有清晰到让你一眼看出bug
* 代码复审时
	- 重构可以帮助代码复审工作得到更具体的结果，不仅获得建议，而其中许多建议能立刻实现

### 什么样的代码需要重构

* 重复代码（Duplicated Code）
	- 重复代码应该封装成一个方法并放置到一个该处的类中
* 过长函数（Long Method）
	- 每当感觉需要用注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数，并以用途命名
* 过大的类（Large Class）
	- 相同或相近的变量和方法放到共同的类中，对大类进行拆分
* 过长参数列表（Long Parameter List）
	- 直接传递对象或封装参数对象
* 发散式变化（Divergent Change）（一个类受多种变化影响）
	- 将引起变化的不同原因封装至不同的类中
* 散弹式修改（Shotgun Surgery）（一个变化引发多个类修改）
	- 讲一个原因引起的变化封装到同一个类中
* 依恋情结（Feature Envy）（函数对某类的兴趣高于所处类的兴趣）
	- 将数据和数据操作封装到一起，而不是由其他类大量调用get方法（除非使用访问者模式和策略模式）
	- 将总一起变化的东西放到一块，使变化再一地发生
* 数据泥团（Data Clumps）（两个类中的相同字段、参数列表相同的参数出现）
	- 删掉众多数据想中的一项，如果其他数据项因此失去意义，你应该把这些数据项封装到一个对象中
	- 可以有效帮助缓解依恋情结（Feature Envy）
* 基本类型偏执（Primitive Obsession）（新手通常不愿意在现任务上运用小对象，如数据类型和数据区间等）
	- 结构类型允许你将数据组织成有意义的形式；基本数据类型则是组成结构类型的积木块
* switch语句（Switch Statements）
	- 考虑使用子类、Strategy模式、Strate模式替换switch语句
* 平行继承体系（Parallel Inheritance Hierarchies）（为某个类增加子类，也必须为另外一个类增加子类）
	- 使用一个类实例引用另外一个，或直接合并两个类
	- 是散弹式修改（Shotgun Surgery）的特例
* 冗赘类（Lazy Class）
	- 如果某个类或者子类预先设计的变化没有发生，删除它
* 夸夸其谈未来性（过度设计的类和方法 Speculative Generality）（当前用不到的设计过度预留）
	- 如果函数或类的用户只有测试用例，而又没有辅助检测正常功能，删除它们
* 临时变量（Temporary Field）（某个变量仅为特定情况而设）
	- 将不一定用到的变量和算法提取并放到合适的类中
* 过度耦合的消息链（Message Chains）（过长的委托链）
	- 将消息链底层的对象调用封装成方法并放置在链中合适的位置
* 中间人（Middle Man）（过度委托造成中间类作用有限）
	- 删除中间类或使其变成子类以保留功能
* 狎昵关系（过度亲密的类 Inappropriate Intimacy）（过分探究private成分的两个类）
	- 重新规划方法和变量所处位置
	- 提取公共部分
	- 转变为单向调用而不是双向调用
	- 将继承变为委托
* 异曲同工的类（Alternative Classes with Diffent Interface）
	- 重命名并合并两个类及其接口
* 不完美的类库（Incomplete Library Class）（类库不能满足需求）
	- 自定义方法补足或或者使用继承体系等合并两个类库
* 纯稚的数据类（Data Class）（public字段的数据类）
	- 为数据类的字段增加访问控制和必要的集合操作
* 拒绝馈赠（Refused Bequest）（继承了不必要的方法或属性）
	- 父类拆分方法至子类（传统做法，不推荐）
	- 使用委托处理本不开出现在继承体系的成员
* 过多注释（Comments）（使用注释解释代码，而掩盖代码的不足）
	- 重构代码，删除多余的解释
	- 当你尝试写代码时，尝试重构，试着让注释变得多余
	- 注释应该用作打草稿，或者记录没有十足把我的区域

### 构筑测试体系

重构之前，首先检查自己是否有一套可靠的测试机制，这些测试必须有自我检验能力  

> 编写良好的测试程序可以极大提高编程速度，编写代码通常占开发的小部分时间，一些时间用来决定下一步干什么，另一些时间花在设计上，最多的时间是用来调试  
> 确保所有测试都完全自动化,让它们检查自己的测试结果  
> 频繁的运行测试,每次编译请把测试也考虑进去,每天至少运行每个测试一次  
> 每当你收到一个测试报告,清写要给单元测试来暴漏bug  
> 观察类所做的事，然后针对任何一种可能失败的情况，进行测试（测试应该是一种风险驱动行为，测试的目的是希望找出现在或未来可能出现的错误）  
> 测试你最担心出错的部分  
> 考虑可能出错的边界  
> 当事情被认为应该会出错时，别忘了检查是否抛出了预期的异常  

### 重构手法

#### 重新组织函数

* Extrat Method（提炼函数）
	- 处理过长函数
* Inline Method（内联函数）
	- 去除无用的未得到复用的函数
* Inline Temp（内联临时变量）
	- 去除无用的未得到复用的变量Query
* Replace Temp with Query（以查询取代临时变量）
	- 使用查询方法去除临时变量
* Introduce Explaining Variable（引入解释性变量）
	- 降低表达式的复杂程度
* Split Temporary Variable（分解临时变量）
	- 分解临时变量而不是每次使用一个变量赋值
* Remove Assignment to Parameters（移除对参数的赋值）
	- 对临时变量赋值替代对输入参数赋值
* Replace Method with Method Object（以函数对象取代函数）
	- 分解混乱的函数，代价是引入一个新的类
* Substitute Algorithm（替换算法）
	- 引入更清晰的算法替代现有算法

##### Extrat Method（提炼函数）

**表现：**你有一段代码可以被组织在一起并独立出来  
**手法：**将这段代码放进一个独立函数中，并让函数名称（清晰到可以解释函数用途）解释函数的用途

**函数短小且良好命名的好处**

* 每个函数的粒度都很小，那么函数被复用的机会都更大
* 这会使高层函数读起来就像一系列注释
* 如果函数都是细粒度，那么函数的覆写也会更容易些

**局部变量问题（在被提炼函数中被赋值）**

* 只在被提炼代码段中使用
	- 将生命也提炼到新方法中
* 被提炼代码之外的代码也使用了这个变量
	- 在被提炼代码之后未使用
		+ 直接在被提炼代码中修改
	- 在被提炼代码之后未使用
		+ 让目标函数返回该变量修改后的值
		+ 如果返回值较多可以分开提炼代码块保持一个返回值是一个好实践

*注意事项：如果入参被直接赋值，请使用 Remove Assignment to Parameters*

##### Inline Method（内联函数）

**表现：**一个函数的本体与名称同样很容易弄懂  
**手法：**在函数调用点插入函数主体，然后删除函数

##### Inline Temp（内联临时变量）

**表现：**一个临时变量，只被一个简单表达式赋值一次，而他妨碍了其他重构手法  
**手法：**将所有对该变量的引用动作，替换为对它赋值的那个表达式自身

*TIPS：将变量声明为final检查是否只被赋值一次*  
*注意事项：Inline Temp会造成性能问题（被计算多次）*

##### Replace Temp with Query（以查询取代临时变量）

**表现：**程序以一个临时变量保存某一表达式的运算结果  
**手法：**将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用替换为对新函数的调用

*TIPS：如果变量被多次赋值，考虑使用Split Temporary Variable*  
*TIPS：操作后对变量执行Inline Temp*

##### Introduce Explaining Variable（引入解释性变量）

**表现：**一个复杂的表达式  
**手法：**将复杂表达式的部分结果放进一个临时变量

*TIPS：这个方法并不常用，取而代之的是Extrat Method，只有Extrat Method工作量很大是使用它替代*

##### Split Temporary Variable（分解临时变量）

**表现：**程序有某个临时变量被赋值超过一次（承担了多个责任），它既不是循环变量，也不被用于收集计算结果  
**手法：**针对每次赋值，创造一个独立、对应的临时变量

##### Remove Assignment to Parameters（移除对参数的赋值）

**表现：**代码对一个参数进行赋值  
**手法：**以一个临时变量取代参数的位置

*注意事项：对参数的赋值在引用传递的参数上指改变其指向，是无意义的，而对参数对象的操作是没问题的*  
*TIPS：如果代码语义是引用传递，要检查调用后是否还使用了这个参数*  
*TIPS：尽量以return方式返回一个值*  

##### Replace Method with Method Object（以函数对象取代函数）

**表现：**有个大型函数，其中对局部变量的使用使你无法采用Extrat Method  
**手法：**将这个函数放进一个单独的对象中，如此局部变量变成了成员变量，然后你可以使用Extrat Method分解它为多个小函数

**做法：**

1. 在新类中建立一个final字段的当前类引用（源对象）
2. 在新类中生命函数用到的临时变量为成员变量
3. 建立构造函数入参为上面建立的所有变量
4. 建立一个compute()函数，讲原函数的内容拷贝进去，并将原函数替换为对象函数调用
5. 将原来函数中引用了其他函数的部分委托给源对象
6. 重构这个大方法而不必考虑参数传递的问题

##### Substitute Algorithm（替换算法）

**表现：**把某个算法替换为另一个更清晰的算法  
**手法：**将函数体替换为另一个算法

TIPS：对于新旧算法分别用所有测试用例执行，找出问题*

#### 在对象之间搬移特性

* Move Method（搬移函数）
	- 移动行为
* Move Field（搬移字段）
	- 移动属性
* Extrat Class（提炼类）
	- 分离职责
* Hide Delegate
* Remove Middle Man
* Introduce Foreign Method
	- 加入不可修改的类的一两个方法
* Introduce Local Extension
	- 加入不可修改的类的多个方法

##### Move Method（搬移函数）

**表现：**有函数与起所驻类之外的另一个类进行许多交流，调用后者，或被后者调用  
**手法：**在该函数最常引用的类中建立一个有着类似行为的新函数，将酒函数变成一个单纯的委托函数，或是完全移除

**做法：**

1. 检查源类中被源函数所使用的一切特性，考虑它是否也该被搬移
2. 检查源类和超类，是否有函数的其他声明
3. 再目标类生命这个函数，可以选择一个新的名字
4. 复制函数内容至新函数，检查对源类调用依赖如何引用（如传递对象引用）和异常处理
	* 将依赖特性移动至目标类
	* 建立或使用一个从目标类到源类的引用关系
	* 将源对象作为参数传递给目标类
	* 将引用变量作为参数传递给目标类
5. 决定源类如何调用新的引用
6. 修改源函数为委托函数
7. 决定是否删除源函数

*TIPS：如果某个特性只有打算搬移的函数用到，那也应该一并搬移*  
*TIPS：如果目标函数设计过多源函数引用，需要考虑拆分函数再搬移*  

##### Move Field（搬移字段）

**表现：**某个字段被其所驻类之外的类更多的用到  
**手法：**再目标类建立一个新字段，修改源字段的所有用户，令他们改用新的字段

*TIPS：使用Self-Encapsulation（自我封装）的字段，可以通过修改访问函数后迁移字段，引用点无需修改*  

##### Extrat Class（提炼类）

**表现：**某个类做了应该由两个类做的事  
**手法：**建立一个新类，将相关字段和函数从旧类中搬移过去

1. 决定如何分解一个类所负的责任
2. 建立一个新类用以表现旧类分离出来的责任
	* 如果剩余的类名称不符，就改名
3. 建立新类和旧类的链接关系
	* 你可能需要双向链接，但是在真正需要它之前，不要建立
4. 搬移字段
5. 搬移方法，优先搬移被依赖的或者被依赖多的
6. 检查并精简类的接口
	* 如果有双向链接，检查是否可以替换为单向链接
7. 决定是否公开新类
	* 允许任何对象修改新类的任何部分，这时应该

*TIPS：一个类应该是一个清楚的抽象，处理一些明确的责任*  
*TIPS：如果一个类需要通过多个子类化的方式分解特性，你需要分解这个类*


------

*重构，改善既有代码的设计*