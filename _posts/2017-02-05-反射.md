---  
lajout: post  
title: 反射和动态代理  
tags: 反射 动态代理  
categories: Java  
published: true  
---  

## 反射

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。  
要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.


### 三种获取Class对象的方式

1. 通过实例获取
2. 任意数据类型都具备一个class静态属性,看上去要比第一种方式简单.
3. 将类名作为字符串传递给Class类中的静态方法forName即可

```java
// 方式1
Person p = new Person();
Class c = p.getClass();

Person p2 = new Person();
Class c2 = p2.getClass();

System.out.println(p == p2);// false
System.out.println(c == c2);// true 所有字节码文件是一份

// 方式2
Class c3 = Person.class;
// int.class;
// String.class;
System.out.println(c == c3);// true

// 方式3
// ClassNotFoundException
Class c4 = Class.forName("cn.xpress.Person");
System.out.println(c == c4);// true
```

**第三种和前两种的区别**

前两种你必须明确Person类型。  
后面是你我这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了

### 反射的使用

#### 通过反射获取构造方法并使用

* public Constructor[] getConstructors():所有公共构造方法
* public Constructor[] getDeclaredConstructors():所有构造方法

```java
// 获取单个构造方法
// public Constructor<T> getConstructor(Class<?>... parameterTypes)
// 参数表示的是：你要获取的构造方法的构造参数个数及数据类型的class字节码文件对象
Constructor con = c.getConstructor();// 返回的是构造方法对象

// Person p = new Person();
// System.out.println(p);
// public T newInstance(Object... initargs)
// 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。
Object obj = con.newInstance();

// 获取带参构造方法对象
// public Constructor<T> getConstructor(Class<?>... parameterTypes)
Constructor con = c.getConstructor(String.class, int.class,
		String.class);

con.setAccessible(true);// 值为true则指示反射的对象在使用时应该取消Java语言访问检查。

// 通过带参构造方法对象创建对象
// public T newInstance(Object... initargs)
Object obj = con.newInstance("林青霞", 27, "北京");
```

#### 通过反射获取成员变量并使用

* Field[] fields = c.getFields();
* Field[] fields = c.getDeclaredFields();

```java
Class c = Class.forName("cn.itcast_01.Person");

// 通过无参构造方法创建对象
Constructor con = c.getConstructor();
Object obj = con.newInstance();
System.out.println(obj);

// 获取单个的成员变量
// 获取address并对其赋值
Field addressField = c.getField("address");
// public void set(Object obj,Object value)
// 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。
addressField.set(obj, "北京"); // 给obj对象的addressField字段设置值为"北京"

// 获取name并对其赋值
// NoSuchFieldException
Field nameField = c.getDeclaredField("name");
// IllegalAccessException
nameField.setAccessible(true);
nameField.set(obj, "林青霞");

// 获取age并对其赋值
Field ageField = c.getDeclaredField("age");
ageField.setAccessible(true);
ageField.set(obj, 27);
```

#### 通过反射获取成员方法并使用

* Method[] methods = c.getMethods(); // 获取自己的包括父亲的公共方法
* Method[] methods = c.getDeclaredMethods(); // 获取自己的所有的方法

```java
// 获取字节码文件对象
Class c = Class.forName("cn.itcast_01.Person");

Constructor con = c.getConstructor();
Object obj = con.newInstance();

// 获取单个方法并使用
// public void show()
// public Method getMethod(String name,Class<?>... parameterTypes)
// 第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型
Method m1 = c.getMethod("show");
// obj.m1(); // 错误
// public Object invoke(Object obj,Object... args)
// 返回值是Object接收,第一个参数表示对象是谁，第二参数表示调用该方法的实际参数
m1.invoke(obj); // 调用obj对象的m1方法

// public void method(String s)
Method m2 = c.getMethod("method", String.class);
m2.invoke(obj, "hello");

// public String getString(String s, int i)
Method m3 = c.getMethod("getString", String.class, int.class);
Object objString = m3.invoke(obj, "hello", 100);
// String s = (String)m3.invoke(obj, "hello",100);
// System.out.println(s);

// private void function()
Method m4 = c.getDeclaredMethod("function");
m4.setAccessible(true);
m4.invoke(obj);
```

## 动态代理

* 代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。
* 动态代理：在程序运行过程中产生的这个对象
	- 而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理
* JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyInvocationHandler implements InvocationHandler {
	private Object target; // 目标对象

	public MyInvocationHandler(Object target) {
		this.target = target;
	}

	@Override
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		System.out.println("权限校验");
		Object result = method.invoke(target, args);
		System.out.println("日志记录");
		return result; // 返回的是代理对象
	}
}
```

```java
UserDao ud = new UserDaoImpl();
ud.add();
ud.delete();
ud.update();
ud.find();
System.out.println("-----------");
// 我们要创建一个动态代理对象
// Proxy类中有一个方法可以创建动态代理对象
// public static Object newProxyInstance(ClassLoader loader,Class<?>[]
// interfaces,InvocationHandler h)
// 我准备对ud对象做一个代理对象
MyInvocationHandler handler = new MyInvocationHandler(ud);
UserDao proxy = (UserDao) Proxy.newProxyInstance(ud.getClass()
		.getClassLoader(), ud.getClass().getInterfaces(), handler);
proxy.add();
proxy.delete();
proxy.update();
proxy.find();
System.out.println("-----------");

StudentDao sd = new StudentDaoImpl();
MyInvocationHandler handler2 = new MyInvocationHandler(sd);
StudentDao proxy2 = (StudentDao) Proxy.newProxyInstance(sd.getClass()
		.getClassLoader(), sd.getClass().getInterfaces(), handler2);
proxy2.login();
proxy2.regist();
```

----------

*以上概念总结于传智播客Java基础课程*