---
layout: post
title: Redis设计与实现
tags: 缓存 Redis
categories: 缓存
published: true
---

## 关系型数据库和非关系型数据库

### 优缺点

* 关系型数据库：数据和数据之间，表和字段之间、表和表之间是存在关系的
	- 优点
		+ 进行增删改查是非常方便的
		+ 有事务操作，保证数据完整性
	- 缺点
		+ 关系由大量算法保证，拉低运行速度，消耗系统资源
		+ 海量数据增删改查会显得无能为力
		+ 海量数据对数据表维护和扩展也变得无能为力
* 非关系型数据库(NoSQL)：
	- 优点
		+ 海量数据增删改查轻松应对
		+ 海量数据维护非常轻松
	- 缺点
		+ 数据不能一目了然（没有表和字段关系）
		+ 没有强大的事务保证数据的完整和安全

### NoSQl分类

* 键值对存储数据库：
	- 相关产品：Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB
	- 典型应用：内容缓存，主要用于处理大量数据的高访问负载
	- 数据模型：一系列键值对
	- 优势：优秀的快速查询，稳定性强
	- 劣势：存储的数据缺少结构化
* 列存储数据库：
	- 相关产品：Apache Cassandra、Apache HBase、Riak
	- 典型应用：分布式的文件系统
	- 数据模型：以列簇式村塾，将同一列数据存在一起
	- 优势：查找速度快，可扩展性强，更容易进行分布式扩展
	- 劣势：功能相对局限，使用极大的内存才可调配，且系统处理算法时将有数秒甚至更长的时间不可以哦那个，导致大量处理超时
* 文档型数据库（淘汰）
	- 相关产品：CouchDB、MongoDB
	- 典型应用：Web应用（与key-value类似），value是结构化的
	- 数据模型：一系列键值对
	- 优势：数据结构要求不严格
	- 劣势：查询性能不高，切缺乏统一的查询语法
* 图形数据库
	- 相关产品：Neo4J、InfoGrid、Infinite Graph
	- 典型应用：社交网络
	- 数据模型：图结构
	- 优势：利用图结构相关算法
	- 劣势：需要对整个图结算才能得出结果，不容易做分布式集群方案，局限性强

---

## Redis

`Redis`是一个开源，先进的key-value存储，并用于构建高性能，可扩展的Web应用程序的完美解决方案。

**Redis从它的许多竞争继承来的三个主要特点：**

* Redis数据库完全在内存中，使用磁盘仅用于持久性。
* 相比许多键值数据存储，Redis拥有一套较为丰富的数据类型。
* Redis可以将数据复制到任意数量的从服务器。

**Redis 优势**

* *异常快速*：Redis的速度非常快，每秒能执行约11万集合，每秒约81000+条记录。
* *支持丰富的数据类型*：Redis支持最大多数开发人员已经知道像列表，集合，有序集合，散列数据类型。这使得它非常容易解决各种各样的问题，因为我们知道哪些问题是可以处理通过它的数据类型更好。
* *操作都是原子性*：所有Redis操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值。
* *多功能实用工具*：Redis是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis原生支持发布/订阅)，任何短暂的数据，应用程序，如Web应用程序会话，网页命中计数等。

## 常用命令

### 启动

```shell
$redis-server
```

#### 自启动

存为redis,放到/etc/init.d/下面  
上面的注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。

```conf
# chkconfig:   2345 90 10
# description:  Redis is a persistent key-value database

PATH=/usr/local/bin:/sbin:/usr/bin:/bin  

REDISPORT=6379  
EXEC=/usr/local/bin/redis-server  
REDIS_CLI=/usr/local/bin/redis-cli  

PIDFILE=/var/run/redis_6379.pid  
CONF="/etc/redis/redis.conf"  

case "$1" in  
    start)  
        if [ -f $PIDFILE ]  
        then  
                echo "$PIDFILE exists, process is already running or crashed"  
        else  
                echo "Starting Redis server..."  
                $EXEC $CONF  
        fi  
        if [ "$?"="0" ]   
        then  
              echo "Redis is running..."  
        fi  
        ;;  
    stop)  
        if [ ! -f $PIDFILE ]  
        then  
                echo "$PIDFILE does not exist, process is not running"  
        else  
                PID=$(cat $PIDFILE)  
                echo "Stopping ..."  
                $REDIS_CLI -p $REDISPORT SHUTDOWN  
                while [ -x ${PIDFILE} ]  
               do  
                    echo "Waiting for Redis to shutdown ..."  
                    sleep 1  
                done  
                echo "Redis stopped"  
        fi  
        ;;  
   restart|force-reload)  
        ${0} stop  
        ${0} start  
        ;;  
  *)  
    echo "Usage: /etc/init.d/redis {start|stop|restart|force-reload}" >&2  
        exit 1  
esac
```

```shell
chmod +x /etc/init.d/redis

service redis start   #或者 /etc/init.d/redis start  
service redis stop   #或者 /etc/init.d/redis stop  
# 自动启动
chkconfig --add redis
chkconfig redis on
```

### 检查Redis是否在工作

```bash
$redis-cli
redis 127.0.0.1:6379>
```

现在输入PING命令检查连接

```shell
redis 127.0.0.1:6379> ping
PONG
```

**在远程服务器上执行命令**

```shell
$redis-cli -h 127.0.0.1 -p 6379 -a "mypass"
redis 127.0.0.1:6379>
redis 127.0.0.1:6379> PING

PONG
```

### 键操作

| 命令                                 | 作用                                             | 示例                                                                                                                                                                                                              |
| :----------------------------------- | :----------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| DEL key                              | 此命令删除键，如果存在。返回受影响行数           |                                                                                                                                                                                                                   |
| DUMP key                             | 该命令返回存储在指定键的值的序列化版本。         |                                                                                                                                                                                                                   |
| EXISTS key                           | 此命令检查该键是否存在。                         |                                                                                                                                                                                                                   |
| EXPIRE key seconds                   | 指定键的过期时间                                 |                                                                                                                                                                                                                   |
| EXPIREAT key timestamp               | 指定的键过期时间。在这里，时间是在Unix时间戳格式 |                                                                                                                                                                                                                   |
| PEXPIRE key milliseconds             | 设置键以毫秒为单位到期                           |                                                                                                                                                                                                                   |
| PEXPIREAT key milliseconds-timestamp | 设置键在Unix时间戳指定为毫秒到期                 |                                                                                                                                                                                                                   |
| KEYS pattern                         | 查找与指定模式匹配的所有键                       | redis 127.0.0.1:6379> KEYS tutorial* <br/> 1) "tutorial3" <br/> 2) "tutorial1" <br/> 3) "tutorial2"                                                                                                               |
| MOVE key db                          | 移动键到另一个数据库                             |                                                                                                                                                                                                                   |
| PERSIST key                          | 移除过期的键                                     |                                                                                                                                                                                                                   |
| PTTL key                             | 以毫秒为单位获取剩余时间的到期键。               |                                                                                                                                                                                                                   |
| TTL key                              | 获取键到期的剩余时间。                           |                                                                                                                                                                                                                   |
| RANDOMKEY                            | 从Redis返回随机键                                | redis 127.0.0.1:6379> SET tutorial1 redis<br/>OK<br/>redis 127.0.0.1:6379> SET tutorial2 mysql<br/>OK<br/>redis 127.0.0.1:6379> SET tutorial3 mongodb<br/>OK<br/>redis 127.0.0.1:6379> RANDOMKEY<br/>1) tutorial3 |
| RENAME key newkey                    | 更改键的名称                                     |                                                                                                                                                                                                                   |
| RENAMENX key newkey                  | 重命名键，如果新的键不存在                       |                                                                                                                                                                                                                   |
| TYPE key                             | 返回存储在键的数据类型的值。                     |                                                                                                                                                                                                                   |

```shell
## 查询key总数
eval "return #redis.call('keys', 'prefix-*')" 0
## 批量删除key
eval "redis.call('del', unpack(redis.call('keys','null*')))" 0
SCAN 0 match "*1*" count 10000000
```

---

## 数据类型

Redis支持5种类型的数据类型

所有的key都是字符串，key不要太长，影响使用效率

### 简单动态字符串

* 常数复杂度获取字符串长度。
* 杜绝缓冲区溢出。
* 减少修改字符串长度时所需的内存重分配次数。
* 二进制安全。
* 兼容部分C字符串函数。

Redis字符串是字节序列。Redis字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512兆为上限。

Redis使用自己构建的一种名为简单动态字符串的抽象类型(simple dynamic string，SDS），作为字符串的默认类型。

```shell
redis> SET msg "hello world"
OK
```

* 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS。
* 键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS。

```shell
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```

* 键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串“fruits”的SDS。
* 键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串“apple”，第二个SDS保存着字符串“banana”，第三个SDS保存着字符串“cherry”。

SDS除了用来保存数据库中的字符串之外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区以及客户端状态中的输入缓冲区。

#### SDS的定义

```c++
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
};
```

SDS示例：

![SDS示例](/static/img/redis/SDS.png)

带有未使用空间的SDS：

![带有未使用空间的SDS](/static/img/redis/SDS-free.png)

#### SDS与C字符串的区别

* 常数复杂度获取字符串长度
	* C字符串不记录自身长度，通过复杂度为O(N)的遍历来获取长度，而SDS只需要访问len属性，将复杂度降低到O(1)，保证了获取字符串长度不会成为Redis的性能瓶颈
* 杜绝缓冲区溢出
	* SDS的api在拼接字符串时会首先检查空间是否满足需求，如果不满足会先分配空间，杜绝了如strcat在空间分配不足时产生缓冲区溢出。
* 减少修改字符串时带来的内存重分配次数
	* C字符串底层是一个N+1字符长度的数组，额外一个字符空间用于存储空字符，所以每次增长或缩短一个C字符串程序总是要对数据进行重新分配。
		* 如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。
		* 如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。
	* SDS通过未使用空间（free），实现了空间预分配和惰性空间释放两种优化策略
		* 空间预分配，通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。
			* 空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。
			* 额外分配的未使用空间数量由以下公式决定：
				* 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。
				* 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。
			* 在扩展SDS空间之前，SDS API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无须执行内存重分配。
			* 通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。
		* 惰性空间释放，通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。
			* 惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。
			* 与此同时，SDS也提供了相应的API，让我们可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。
* 二进制安全
	* C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。
		* 在关系型数据库中，频繁的编码解码浪费大量是系统性能，同时可能出现乱码
		* redis的编码和解码只会出现在客户端，执行效率很高，并不会出现乱码
			- key中字符串使用unicode编码：你--"\xe4\xbd\xa0"
	* SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。
		* 这也是将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。
	* 通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。
* 兼容部分C字符串函数
	* SDS API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分`<string.h>`库定义的函数。

| C字符串                                          | SDS                                              |
| ------------------------------------------------ | ------------------------------------------------ |
| 获取字符串长度的复杂度为 O(N) 。                 | 获取字符串长度的复杂度为 O(1) 。                 |
| API 是不安全的，可能会造成缓冲区溢出。           | API 是安全的，不会造成缓冲区溢出。               |
| 修改字符串长度 N 次必然需要执行 N 次内存重分配。 | 修改字符串长度 N 次最多需要执行 N 次内存重分配。 |
| 只能保存文本数据。                               | 可以保存文本或者二进制数据。                     |
| 可以使用所有 `<string.h>` 库中的函数。           | 可以使用一部分 `<string.h>` 库中的函数。         |

### 字典

* 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。
* Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。
* 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。
* 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。
* 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。

字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。

除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。

Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

#### 哈希表

Redis字典所使用的哈希表由dict.h/dictht结构定义：

```c++
typedef struct dictht {{
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值
    // 总是等于size-1
    unsigned long sizemask;
    // 该哈希表已有节点的数量
    unsigned long used;
} dictht;
```

table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。

大小为4的空哈希表（没有包含任何键值对）：

![An-empty-hash-table](/static/img/redis/An-empty-hash-table.png)

#### 哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：

```c++
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;
    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。  
next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。

通过next指针，将两个索引值相同的键k1和k0连接在一起：

![连接在一起的键K1和键K0](/static/img/redis/Keys-K1-and-keys-that-are-connected-together-K0.png)

#### 字典

Redis中的字典由dict.h/dict结构表示：

```c++
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash索引
    // 当rehash不在进行时，值为-1
    in trehashidx; /* rehashing not in progress if rehashidx == -1 */
} dict;
```

type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：

* type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。
* 而privdata属性则保存了需要传给那些类型特定函数的可选参数。

```c++
typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);
    // 复制键的函数
    void *(*keyDup)(void *privdata, const void *key);
    // 复制值的函数
    void *(*valDup)(void *privdata, const void *obj);
    // 对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // 销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);
    // 销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```

ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。  
除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。

普通状态下（没有进行rehash）的字典：

![Dictionary-in-normal-state](/static/img/redis/Dictionary-in-normal-state.png)

#### 哈希算法

当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

Redis计算哈希值和索引值的方法如下：

```c++
// 使用字典设置的哈希函数，计算键key的哈希值
hash = dict->type->hashFunction(key);
// 使用哈希表的sizemask属性和哈希值，计算出索引值
// 根据情况不同，ht[x]可以是ht[0]或者ht[1]
index = hash & dict->ht[x].sizemask;
```

假设计算得出的哈希值为8，那么程序会继续使用语句：

```c
index = hash&dict->ht[0].sizemask = 8 & 3 = 0;
```

空字典：

![空字典](/static/img/redis/Empty-dictionary.png)

添加键值对K0和v0之后的字典：

![添加键值对K0和v0之后的字典](/static/img/redis/Add-a-key-value-to-the-dictionary-after-K0-and-V0.png)

当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。  
MurmurHash算法最初由Austin Appleby于2008年发明，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。

#### 解决键冲突

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。

Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。

因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O(1)），排在其他已有节点的前面。

一个包含两个键值对的哈希表：

![A hash table that contains two key-value pairs](/static/img/redis/A-hash-table-that-contains-two-key-value-pairs.png)

使用链表解决k2和k1的冲突：

![Using linked lists to resolve conflicts between K2 and K1](/static/img/redis/Using-linked-lists-to-resolve-conflicts-between-K2-and-K1.png)

#### rehash

随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：

1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）
	* 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n（2的n次方幂）；
	* 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。
2. 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
3. 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。

对图字典的ht[0]进行扩展操作，那么程序将执行以下步骤：

![执行rehash之前的字典](/static/img/redis/The-dictionary-before-executing-rehash.png)

1）ht[0].used当前的值为4，4*2=8，而8（2^3）恰好是第一个大于等于4的2的n次方，所以程序会将ht[1]哈希表的大小设置为8。ht[1]在分配空间之后，字典的样子:

![为字典的ht[1]哈希表分配空间](/static/img/redis/For-the-ht1-of-the-Dictionary-Hash-Table-allocation-Space.png)

2）将ht[0]包含的四个键值对都rehash到ht[1]

![ht[0]的所有键值对都已经被迁移到ht[1]](/static/img/redis/All-key-value-pairs-for-ht0-have-been-migrated-to-ht1.png)

3）释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表，至此，对哈希表的扩展操作执行完毕，程序成功将哈希表的大小从原来的4改为了现在的8。

![完成rehash之后的字典](/static/img/redis/Complete-the-dictionary-after-rehash.png)

##### 哈希表的扩展与收缩

当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：

* 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。
* 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

其中哈希表的负载因子可以通过公式：

```c
// 负载因子 = 哈希表已保存节点数量 / 哈希表大小
load_factor = ht[0].used / ht[0].size
```

因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，
所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。

#### 渐进式rehash

扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。

要一次性将这些键值对全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。
因此，为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。

以下是哈希表渐进式rehash的详细步骤：

* 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
* 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
* 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
* 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。

渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

准备开始rehash:

![准备开始rehash](/static/img/redis/Ready-to-start-Rehash.png)

rehash索引0上的键值对:

![rehash索引0上的键值对](/static/img/redis/Key-value-pairs-on-rehash-index-0.png)

rehash索引1上的键值对:

![rehash索引1上的键值对](/static/img/redis/Key-value-pairs-on-rehash-index-1.png)

rehash索引2上的键值对:

![rehash索引2上的键值对](/static/img/redis/Key-value-pairs-on-rehash-index-2.png)

rehash索引3上的键值对:

![rehash索引3上的键值对](/static/img/redis/Key-value-pairs-on-rehash-index-3.png)

rehash执行完毕:

![rehash执行完毕](/static/img/redis/Rehash-execution-complete.png)

##### 渐进式reahsh执行期间的哈希表操作

因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。

例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。

另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。

### 链表

#### 链表和链表节点的实现

* 链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。
* 每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
* 每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。
* 因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。
* 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。

链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。

除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区（output buffer）

```c
// adlist.h/listNode
typedef struct listNode {
    // 前置节点
    struct listNode * prev;
    // 后置节点
    struct listNode * next;
    // 节点的值
    void * value;
}listNode;
```

多个listNode可以通过prev和next指针组成双端链表：

![由多个listNode组成的双端链表](/static/img/redis/Two-terminal-linked-list-consisting-of-multiple-ListNode.png)

使用adlist.h/list来持有链表的话，操作起来会更方便：

```c
typedef struct list {
    // 表头节点
    listNode * head;
    // 表尾节点
    listNode * tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr,void *key);
} list;
```

由list结构和listNode结构组成的链表：

![由list结构和listNode结构组成的链表](/static/img/redis/List-structure-and-listnode-structure-of-the-chain-list.png)

Redis的链表实现的特性可以总结如下：

* 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。
* 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
* 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。
* 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。
* 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

Redis的列表是简单的字符串列表，排序插入顺序。可以添加元素到Redis的列表的头部或尾部。

Redis列表是双向链表，适合做大数据集合的增删和任务队列

### 压缩列表（ziplist）

* 压缩列表是一种为节约内存而开发的顺序型数据结构。
* 压缩列表被用作列表键和哈希键的底层实现之一。
* 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
* 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。

压缩列表（ziplist）是列表键和哈希键的底层实现之一。

当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

```shell
redis> RPUSH lst 1 3 5 10086 "hello" "world"
(integer)6
redis> OBJECT ENCODING lst
"ziplist"
```

当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

```shell
redis> HMSET profile "name" "Jack" "age" 28 "job" "Programmer"
OK
redis> OBJECT ENCODING profile
"ziplist"
```

#### 压缩列表的构成

压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

压缩列表的各个组成部分：

![压缩列表的各个组成部分](/static/img/redis/Compress-each-part-of-a-list.png)

压缩列表各个组成部分的详细说明：

| 属性    | 类型     | 长度   | 用途                                                                                                                                                                                              |
| ------- | -------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| zlbytes | uint32_t | 4 字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。                                                                                                      |
| zltail  | uint32_t | 4 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。                                                                         |
| zllen   | uint16_t | 2 字节 | 记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。 |
| entryX  | 列表节点 | 不定   | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。                                                                                                                                          |
| zlend   | uint8_t  | 1 字节 | 特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。                                                                                                                                             |

包含三个节点的压缩列表：

![包含三个节点的压缩列表](/static/img/redis/Compressed-list-containing-three-nodes.png)

* 列表zlbytes属性的值为0x50（十进制80），表示压缩列表的总长为80字节。
* 列表zltail属性的值为0x3c（十进制60），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出表尾节点entry3的地址。
* 列表zllen属性的值为0x3（十进制3），表示压缩列表包含三个节点。

#### 压缩列表节点的构成

每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种：

* 长度小于等于63（2 6–1）字节的字节数组；
* 长度小于等于16383（2 14–1）字节的字节数组；
* 长度小于等于4294967295（2 32–1）字节的字节数组；

而整数值则可以是以下六种长度的其中一种：

* 4位长，介于0至12之间的无符号整数；
* 1字节长的有符号整数；
* 3字节长的有符号整数；
* int16_t类型整数；
* int32_t类型整数；
* int64_t类型整数。

每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成：

![压缩列表的各个组成部分](/static/img/redis/Each-component-of-the-indented-list-node.png)

##### previous_entry_length

节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：

* 如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。
* 如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。

当前节点的前一节点的长度为5字节：

![压缩列表的各个组成部分](/static/img/redis/The-previous-node-of-the-current-node-has-a-length-of-5-bytes.png)

包含一字节长previous_entry_length属性的压缩列表节点，属性的值为0x05，表示前一节点的长度为5字节。

当前节点的前一节点的长度为10086字节：

![当前节点的前一节点的长度为10086字节](/static/img/redis/The-previous-node-of-the-current-node-has-a-length-of-10086-bytes.png)

包含五字节长previous_entry_length属性的压缩节点，属性的值为0xFE00002766，其中值的最高位字节0xFE表示这是一个五字节长的previous_entry_length属性，而之后的四字节0x00002766（十进制值10086）才是前一节点的实际长度。

因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。  
压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。

从表尾节点向表头节点进行遍历的完整过程：

* 首先，我们拥有指向压缩列表表尾节点entry4起始地址的指针p1（指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上zltail属性的值得出）；
* 通过用p1减去entry4节点previous_entry_length属性的值，我们得到一个指向entry4前一节点entry3起始地址的指针p2；
* 通过用p2减去entry3节点previous_entry_length属性的值，我们得到一个指向entry3前一节点entry2起始地址的指针p3；
* 通过用p3减去entry2节点previous_entry_length属性的值，我们得到一个指向entry2前一节点entry1起始地址的指针p4，entry1为压缩列表的表头节点；
* 最终，我们从表尾节点向表头节点遍历了整个列表。

![从表尾向表头遍历的例子](/static/img/redis/Example-of-traversing-from-the-end-of-a-table-to-the-header.png)

##### encoding

节点的encoding属性记录了节点的content属性所保存数据的类型以及长度：

* 一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；
* 一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；

字节数组编码：

| 编码                                         | 编码长度 | content 属性保存的值                 |
| -------------------------------------------- | -------- | ------------------------------------ |
| 00bbbbbb                                     | 1 字节   | 长度小于等于 63 字节的字节数组。     |
| 01bbbbbb xxxxxxxx                            | 2 字节   | 长度小于等于 16383 字节的字节数组。  |
| 10______ aaaaaaaa bbbbbbbb cccccccc dddddddd | 5 字节   | 长度小于等于 4294967295 的字节数组。 |

整数编码：

| 编码     | 编码长度 | content 属性保存的值                                                                                                                  |
| -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 11000000 | 1 字节   | int16_t 类型的整数。                                                                                                                  |
| 11010000 | 1 字节   | int32_t 类型的整数。                                                                                                                  |
| 11100000 | 1 字节   | int64_t 类型的整数。                                                                                                                  |
| 11110000 | 1 字节   | 24 位有符号整数。                                                                                                                     |
| 11111110 | 1 字节   | 8 位有符号整数。                                                                                                                      |
| 1111xxxx | 1 字节   | 使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。 |

##### content

节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。

一个保存字节数组的节点示例：

![一个保存字节数组的节点示例](/static/img/redis/Nodes-with-the-section-array-Hello-world-saved.png)

* 编码的最高两位00表示节点保存的是一个字节数组；
* 编码的后六位001011记录了字节数组的长度11；
* content属性保存着节点的值"hello world"。

#### 连锁更新

考虑这样一种情况：在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，
因为e1至eN的所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性

![包含节点el至eN的压缩列表](/static/img/redis/Contains-a-compressed-list-of-nodes-el-to-en.png)

这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点

![添加新节点到压缩列表](/static/img/redis/Add-new-node-to-compressed-list.png)

因为e1的previous_entry_length属性仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节长扩展为5字节长。  
现在，麻烦的事情来了，e1原本的长度介于250字节至253字节之间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度就变成了介于254字节至257字节之间，而这种长度使用1字节长的previous_entry_length属性是没办法保存的。  
因此，为了让e2的previous_entry_length属性可以记录下e1的长度，程序需要再次对压缩列表执行空间重分配操作，并将e2节点的previous_entry_length属性从原来的1字节长扩展为5字节长。  
正如扩展e1引发了对e2的扩展一样，扩展e2也会引发对e3的扩展，而扩展e3又会引发对e4的扩展……为了让每个节点的previous_entry_length属性都符合压缩列表对节点的要求，程序需要不断地对压缩列表执行空间重分配操作，直到eN为止。  
Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）

除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。

如果e1至eN都是大小介于250字节至253字节的节点，big节点的长度大于等于254字节（需要5字节的previous_entry_length来保存），
而small节点的长度小于254字节（只需要1字节的previous_entry_length来保存），那么当我们将small节点从压缩列表中删除之后，
为了让e1的previous_entry_length属性可以记录big节点的长度，程序将扩展e1的空间，并由此引发之后的连锁更新。

![连锁更新过程](/static/img/redis/Chain-update-process.png)

因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N 2)。

要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：

* 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；
* 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；

因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)，在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。

### 整数集合（intset）

* 整数集合是集合键的底层实现之一。
* 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。
* 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
* 整数集合只支持升级操作，不支持降级操作。

整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

```shell
redis> SADD numbers 1 3 5 7 9
(integer) 5
redis> OBJECT ENCODING numbers
"intset"
```

#### 整数集合的实现

整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。

每个intset.h/intset结构表示一个整数集合：

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。  
length属性记录了整数集合包含的元素数量，也即是contents数组的长度。

虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：

* 如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为-32768，最大值为32767）。
* 如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为-2147483648，最大值为2147483647）。
* 如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为-9223372036854775808，最大值为9223372036854775807）。

一个包含五个int16_t类型整数值的整数集合：

![一个包含五个int16_t类型整数值的整数集合](/static/img/redis/An-integer-set-containing-five-integer-values-of-the-int16_t-type.png)

* encoding属性的值为INTSET_ENC_INT16，表示整数集合的底层实现为int16_t类型的数组，而集合保存的都是int16_t类型的整数值。
* length属性的值为5，表示整数集合包含五个元素。
* contents数组按从小到大的顺序保存着集合中的五个元素。
* 因为每个集合元素都是int16_t类型的整数值，所以contents数组的大小等于sizeof（int16_t）*5=16*5=80位。

一个包含四个int16_t类型整数值的整数集合：

![一个包含四个int16_t类型整数值的整数集合](/static/img/redis/An-integer-set-containing-four-integer-values-of-the-int16_t-type.png)

* encoding属性的值为INTSET_ENC_INT64，表示整数集合的底层实现为int64_t类型的数组，而数组中保存的都是int64_t类型的整数值。
* length属性的值为4，表示整数集合包含四个元素。
* contents数组按从小到大的顺序保存着集合中的四个元素。
* 因为每个集合元素都是int64_t类型的整数值，所以contents数组的大小为sizeof（int64_t）*4=64*4=256位。

虽然contents数组保存的四个整数值中，只有-2675256175807981027是真正需要用int64_t类型来保存的，而其他的1、3、5三个值都可以用int16_t类型来保存，
不过根据整数集合的升级规则，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型，
所以contents数组保存的四个整数值都是int64_t类型的，不仅仅是-2675256175807981027。

#### 升级

每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步进行：

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

一个包含三个int16_t类型的元素的整数集合，要将类型为int32_t的整数值65535添加到整数集合里面：

![一个包含三个int16_t类型的元素的整数集合](/static/img/redis/upgrade1.png)

contents数组的各个元素，以及它们所在的位：

![contents数组的各个元素，以及它们所在的位](/static/img/redis/upgrade2.png)

进行空间重分配之后的数组：

![进行空间重分配之后的数组](/static/img/redis/upgrade3.png)

将这三个元素转换成int32_t类型，并将转换后的元素放置到正确的位上面，而且在放置元素的过程中，需要维持底层数组的有序性质不变。  

对元素3进行类型转换，并保存在适当的位上：

![对元素3进行类型转换，并保存在适当的位上](/static/img/redis/upgrade4.png)

对元素2进行类型转换，并保存在适当的位上：

![对元素2进行类型转换，并保存在适当的位上](/static/img/redis/upgrade5.png)

对元素1进行类型转换，并保存在适当的位上：

![对元素1进行类型转换，并保存在适当的位上](/static/img/redis/upgrade6.png)

添加65535到数组：

![添加65535到数组](/static/img/redis/upgrade7.png)

程序将整数集合encoding属性的值从INTSET_ENC_INT16改为INTSET_ENC_INT32，并将length属性的值从3改为4，完成添加操作之后的整数集合：

![添加65535到数组](/static/img/redis/upgrade8.png)

因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。

##### 升级之后新元素的摆放位置

因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：

* 在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）；
* 在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引length-1）。

#### 升级的好处

整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个是尽可能地节约内存。

##### 提升灵活性

因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。  
例如，我们一般只使用int16_t类型的数组来保存int16_t类型的值，只使用int32_t类型的数组来保存int32_t类型的值，诸如此类。

但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中，而不必担心出现类型错误，这种做法非常灵活。

##### 节约内存

整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。

#### 降级

整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

### 跳跃表的实现

* 跳跃表是有序集合的底层实现之一。
* Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。
* 每个跳跃表节点的层高都是1至32之间的随机数。
* 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
* 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。

跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。

Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。

和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。

Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。

一个跳跃表：

![A-jump-Table](/static/img/redis/A-jump-Table.png)

位于图片最左边的是zskiplist结构，该结构包含以下属性：

* header：指向跳跃表的表头节点。
* tail：指向跳跃表的表尾节点。
* level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。
* length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。

位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：

* 层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。
	* 每个层都带有两个属性：前进指针和跨度。
		* 前进指针用于访问位于表尾方向的其他节点
		* 而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。
* 后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。
* 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。
* 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。

注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。

#### 跳跃表节点

跳跃表节点的实现由redis.h/zskiplistNode结构定义：

```c++
typedef struct zskiplistNode {
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
} zskiplistNode;
```

##### 层

跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。

每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。

高度为1层、3层和5层的节点：

![高度为1层、3层和5层的节点](/static/img/redis/Nodes-with-a-height-of-1-layers-3-layers-and-5-layers.png)

##### 前进指针

每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。

遍历整个跳跃表，用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：

![遍历整个跳跃表](/static/img/redis/Traverse-the-entire-Jump-table.png)

1. 迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。
2. 在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。
3. 在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。
4. 当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。

##### 跨度

层的跨度（level[i].span属性）用于记录两个节点之间的距离：

* 两个节点之间的跨度越大，它们相距得就越远。
* 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。

看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的：  
在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。

虚线标记了在跳跃表中查找分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。

![计算节点的排位](/static/img/redis/Calculate-the-rank-of-a-node.png)

虚线标记了在跳跃表中查找分值为2.0、成员对象为o2的节点时，沿途经历的层：在查找节点的过程中，程序经过了两个跨度为1的节点，因此可以计算出，目标节点在跳跃表中的排位为2。

![计算节点的排位](/static/img/redis/Calculate-the-rank-of-a-node1.png)

##### 后退指针

节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。

如果从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，于是访问结束。

从表尾向表头方向遍历跳跃表:

![从表尾向表头方向遍历跳跃表](/static/img/redis/To-traverse-a-jump-table-from-the-end-of-a-table-to-the-header-direction.png)

##### 分值和成员

节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。  
节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。

在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：  
分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。

三个带有相同分值的跳跃表节点:

![三个带有相同分值的跳跃表节点](/static/img/redis/Three-hop-table-nodes-with-the-same-score.png)

#### 跳跃表

```c++
typedef struct zskiplist {
    // 表头节点和表尾节点
    structz skiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
```

仅靠多个跳跃表节点就可以组成一个跳跃表

![由多个跳跃节点组成的跳跃表](/static/img/redis/Jump-table-made-up-of-multiple-jumping-nodes.png)

但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息

![带有zskiplist结构的跳跃表](/static/img/redis/Jump-table-with-zskiplist-structure.png)

header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。
通过使用length属性来记录节点的数量，程序可以在O(1)复杂度内返回跳跃表的长度。
level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。

## 对象

* Redis数据库中的每个键值对的键和值都是一个对象。
* Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
* 服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
* Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
* Redis会共享值为0到9999的字符串对象。
* 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，
这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面所介绍的数据结构。

通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。  
使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。  
除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；  
另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。  
最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。

### 对象的类型与编码

Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。

Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：

```c++
typedef struct redisObject {
    // 类型
    unsigned type:4;
    // 编码
    unsigned encoding:4;
    // 指向底层实现数据结构的指针
    void *ptr;
    // ...
} robj;
```

#### 类型

对象的type属性记录了对象的类型，这个属性的值可以是表中列出的常量的其中一个。

对象的类型：

| 类型常量     | 对象的名称   |
| ------------ | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |

对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。

TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型：

```shell
# 键为字符串对象，值为字符串对象
redis> SET msg "hello world"
OK
redis> TYPE msg
string
# 键为字符串对象，值为列表对象
redis> RPUSH numbers 1 3 5
(integer) 6
redis> TYPE numbers
list
# 键为字符串对象，值为哈希对象
redis> HMSET profile name Tome age 25 career Programmer
OK
redis> TYPE profile
hash
# 键为字符串对象，值为集合对象
redis> SADD fruits apple banana cherry
(integer) 3
redis> TYPE fruits
set
# 键为字符串对象，值为有序集合对象
redis> ZADD price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
redis> TYPE price
zset
```

不同类型值对象的TYPE命令输出：

| 对象         | 对象 type 属性的值 | TYPE 命令的输出 |
| ------------ | ------------------ | --------------- |
| 字符串对象   | REDIS_STRING       | "string"        |
| 列表对象     | REDIS_LIST         | "list"          |
| 哈希对象     | REDIS_HASH         | "hash"          |
| 集合对象     | REDIS_SET          | "set"           |
| 有序集合对象 | REDIS_ZSET         | "zset"          |

#### 编码和底层实现

对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。

encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是表中列出的常量的其中一个。

对象的编码：

| 编码常量                  | 编码所对应的底层数据结构    |
| ------------------------- | --------------------------- |
| REDIS_ENCODING_INT        | long 类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr 编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字符串              |
| REDIS_ENCODING_HT         | 字典                        |
| REDIS_ENCODING_LINKEDLIST | 双端链表                    |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                    |
| REDIS_ENCODING_INTSET     | 整数集合                    |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典                |

每种类型的对象都至少使用了两种不同的编码，表中列出了每种类型的对象可以使用的编码。

不同类型和编码的对象：

| 类型         | 编码                      | 对象                                               |
| ------------ | ------------------------- | -------------------------------------------------- |
| REDIS_STRING | REDIS_ENCODING_INT        | 使用整数值实现的字符串对象。                       |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | 使用 embstr 编码的简单动态字符串实现的字符串对象。 |
| REDIS_STRING | REDIS_ENCODING_RAW        | 使用简单动态字符串实现的字符串对象。               |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的列表对象。                       |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 使用双端链表实现的列表对象。                       |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的哈希对象。                       |
| REDIS_HASH   | REDIS_ENCODING_HT         | 使用字典实现的哈希对象。                           |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 使用整数集合实现的集合对象。                       |
| REDIS_SET    | REDIS_ENCODING_HT         | 使用字典实现的集合对象。                           |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的有序集合对象。                   |
| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   | 使用跳跃表和字典实现的有序集合对象。               |

使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：

```shell
redis> SET msg "hello wrold"
OK
redis> OBJECT ENCODING msg
"embstr"
redis> SET story "long long long long long long ago ..."
OK
redis> OBJECT ENCODING story
"raw"
redis> SADD numbers 1 3 5
(integer) 3
redis> OBJECT ENCODING numbers
"intset"
redis> SADD numbers "seven"
(integer) 1
redis> OBJECT ENCODING numbers
"hashtable"
```

不同编码的对象所对应的OBJECT ENCODING命令输出：

| 对象所使用的底层数据结构           | 编码常量                  | OBJECT ENCODING 命令输出 |
| ---------------------------------- | ------------------------- | ------------------------ |
| 整数                               | REDIS_ENCODING_INT        | "int"                    |
| embstr 编码的简单动态字符串（SDS） | REDIS_ENCODING_EMBSTR     | "embstr"                 |
| 简单动态字符串                     | REDIS_ENCODING_RAW        | "raw"                    |
| 字典                               | REDIS_ENCODING_HT         | "hashtable"              |
| 双端链表                           | REDIS_ENCODING_LINKEDLIST | "linkedlist"             |
| 压缩列表                           | REDIS_ENCODING_ZIPLIST    | "ziplist"                |
| 整数集合                           | REDIS_ENCODING_INTSET     | "intset"                 |
| 跳跃表和字典                       | REDIS_ENCODING_SKIPLIST   | "skiplist"               |

通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，
因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

### 字符串对象

#### 编码

##### int

字符串对象的编码可以是int、raw或者embstr。

如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。

```shell
redis> SET number 10086
OK
redis> OBJECT ENCODING number
"int"
```

![INT-encoded-String-object](/static/img/redis/INT-encoded-String-object.png)

##### raw

如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。

```shell
redis> SET story "Long, long ago there lived a king ..."
OK
redis> STRLEN story
(integer) 37
redis> OBJECT ENCODING story
"raw"
```

![Raw-encoded-String-Object](/static/img/redis/Raw-encoded-String-Object.png)

##### embstr

如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。

embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，
但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，
空间中依次包含redisObject和sdshdr两个结构

![Memory-block-structure-created-by-EMBSTR-encoding](/static/img/redis/Memory-block-structure-created-by-EMBSTR-encoding.png)

embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：

* embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
* 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。
* 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。

![EMBSTR-encoded-String-Object](/static/img/redis/EMBSTR-encoded-String-Object.png)

##### long和double的编码

最后要说的是，可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。

在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。

```shell
redis> INCRBYFLOAT pi 2.0
"5.14"
redis> OBJECT ENCODING pi
"embstr"
```

程序首先会取出字符串对象里面保存的字符串值"3.14"，将它转换回浮点数值3.14，然后把3.14和2.0相加得出的值5.14转换成字符串"5.14"，并将这个"5.14"保存到字符串对象里面。

| 值                                                                                                                      | 编码            |
| ----------------------------------------------------------------------------------------------------------------------- | --------------- |
| 可以用 long 类型保存的整数。                                                                                            | int             |
| 可以用 long double 类型保存的浮点数。                                                                                   | embstr 或者 raw |
| 字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。 | embstr 或者 raw |

#### 编码的转换

int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。

* 对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。
* embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。
	* embstr编码的字符串对象实际上是只读的。因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），
	* 程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。

```shell
redis> SET number 10086
OK
redis> OBJECT ENCODING number
"int"
redis> APPEND number " is a good number!"
(integer) 23
redis> GET number
"10086 is a good number!"
redis> OBJECT ENCODING number
"raw"
```

```shell
redis> SET msg "hello world"
OK
redis> OBJECT ENCODING msg
"embstr"
redis> APPEND msg " again!"
(integer) 18
redis> OBJECT ENCODING msg
"raw"
```

#### 字符串操作

```shell
redis 127.0.0.1:6379> SET name "yiibai"
OK
redis 127.0.0.1:6379> GET name
"yiibai"
```

| 命令                             | 作用                                       | 示例                                                                                                                                                                                             |
| :------------------------------- | :----------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SET key value                    | 此命令用于在指定键设置值                   |                                                                                                                                                                                                  |
| GET key                          | 键对应的值。                               |                                                                                                                                                                                                  |
| GETRANGE key start end           | 得到字符串的子字符串存放在一个键           | redis 127.0.0.1:6379> SET mykey "This is my test key"<br/>OK<br/>redis 127.0.0.1:6379> GETRANGE mykey 0 3<br/>"This"<br/>redis 127.0.0.1:6379> GETRANGE mykey 0 -1<br/>"This is my test key"     |
| GETSET key value                 | 设置键的字符串值，并返回旧值               |                                                                                                                                                                                                  |
| GETBIT key offset                | 返回存储在键位值的字符串值的偏移           |                                                                                                                                                                                                  |
| MGET key1 [key2..]               | 得到所有的给定键的值                       | redis 127.0.0.1:6379> SET key1 "hello"<br/>OK<br/>redis 127.0.0.1:6379> SET key2 "world"<br/>OK<br/>redis 127.0.0.1:6379> MGET key1 key2 someOtherKey<br/>1) "Hello"<br/>2) "World"<br/>3) (nil) |
| SETBIT key offset value          | 设置或清除该位在存储在键的字符串值偏移     |                                                                                                                                                                                                  |
| SETEX key seconds value          | 键到期时设置值                             |                                                                                                                                                                                                  |
| SETNX key value                  | 设置键的值，只有当该键不存在               |                                                                                                                                                                                                  |
| SETRANGE key offset value        | 覆盖字符串的一部分从指定键的偏移           |                                                                                                                                                                                                  |
| STRLEN key                       | 得到存储在键的值的长度                     |                                                                                                                                                                                                  |
| MSET key value [key value ...]   | 设置多个键和多个值                         |                                                                                                                                                                                                  |
| MSETNX key value [key value ...] | 设置多个键多个值，只有在当没有按键的存在时 |                                                                                                                                                                                                  |
| PSETEX key milliseconds value    | 设置键的毫秒值和到期时间                   |                                                                                                                                                                                                  |
| INCR key                         | 增加键的整数值一次                         | 不存在的值incr后为1，非数值型报错                                                                                                                                                                |
| INCRBY key increment             | 由给定的数量递增键的整数值                 |                                                                                                                                                                                                  |
| INCRBYFLOAT key increment        | 由给定的数量递增键的浮点值                 |                                                                                                                                                                                                  |
| DECR key                         | 递减键一次的整数值                         | 不存在的值incr后为-1                                                                                                                                                                             |
| DECRBY key decrement             | 由给定数目递减键的整数值                   |                                                                                                                                                                                                  |
| APPEND key value                 | 追加值到一个键                             | 拼接字符串，返回拼接后长度                                                                                                                                                                       |

#### 字符串命令的实现

| 命令        | int 编码的实现方法                                                                                            | embstr 编码的实现方法                                                                                                                                                           | raw 编码的实现方法                                                                                                                                                              |
| ----------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SET         | 使用 int 编码保存值。                                                                                         | 使用 embstr 编码保存值。                                                                                                                                                        | 使用 raw 编码保存值。                                                                                                                                                           |
| GET         | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。                            | 直接向客户端返回字符串值。                                                                                                                                                      | 直接向客户端返回字符串值。                                                                                                                                                      |
| APPEND      | 将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。                                                     | 将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。                                                                                                                       | 调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。                                                                                                                      |
| INCRBYFLOAT | 取出整数值并将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 | 取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 | 取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 |
| INCRBY      | 对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。                                                   | embstr 编码不能执行此命令， 向客户端返回一个错误。                                                                                                                              | raw 编码不能执行此命令， 向客户端返回一个错误。                                                                                                                                 |
| DECRBY      | 对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。                                                   | embstr 编码不能执行此命令， 向客户端返回一个错误。                                                                                                                              | raw 编码不能执行此命令， 向客户端返回一个错误。                                                                                                                                 |
| STRLEN      | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。                            | 调用 sdslen 函数， 返回字符串的长度。                                                                                                                                           | 调用 sdslen 函数， 返回字符串的长度。                                                                                                                                           |
| SETRANGE    | 将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。                                                     | 将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。                                                                                                                       | 将字符串特定索引上的值设置为给定的字符。                                                                                                                                        |
| GETRANGE    | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。                    | 直接取出并返回字符串指定索引上的字符。                                                                                                                                          | 直接取出并返回字符串指定索引上的字符。                                                                                                                                          |

### 列表对象

#### 编码

列表对象的编码可以是ziplist或者linkedlist。

##### ziplist

```shell
redis> RPUSH numbers 1 "three" 5
(integer) 3
```

如果numbers键的值对象使用的是ziplist编码:

![ziplist编码的numbers列表对象](/static/img/redis/Ziplist-encoded-Numbers-List-Object.png)

##### linkedlist

如果numbers键的值对象使用的是linkedlist编码:

![linkedlist编码的numbers列表对象](/static/img/redis/LinkedList-encoded-Numbers-List-Object.png)

_注意：为了简化字符串对象的表示，使用了一个带有StringObject字样的格子来表示一个字符串对象_  
_注意：linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现。_  
_Tips：字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。_

#### 编码转换

当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：

* 列表对象保存的所有字符串元素的长度都小于64字节；
* 列表对象保存的元素数量小于512个；

不能满足这两个条件的列表对象需要使用linkedlist编码。

_Tips:以上两个条件的上限值是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。_

对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，
原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从ziplist变为linkedlist。

```shell
# 因为保存了长度太大的元素而进行编码转换的情况：
# 所有元素的长度都小于64字节
redis> RPUSH blah "hello" "world" "again"
(integer)3
redis> OBJECT ENCODING blah
"ziplist"
# 将一个65字节长的元素推入列表对象中
redis> RPUSH blah "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww"
(integer) 4
# 编码已改变
redis> OBJECT ENCODING blah
"linkedlist"
```

```shell
# 因为保存的元素数量过多而进行编码转换的情况：
# 列表对象包含512个元素
redis> EVAL "for i=1, 512 do redis.call('RPUSH', KEYS[1],i)end" 1 "integers"
(nil)
redis> LLEN integers
(integer) 512
redis> OBJECT ENCODING integers
"ziplist"
# 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个
redis> RPUSH integers 513
(integer) 513
# 编码已改变
redis> OBJECT ENCODING integers
"linkedlist"
```

#### 列表操作

```shell
redis 127.0.0.1:6379> lpush tutoriallist redis
(integer) 1
redis 127.0.0.1:6379> lpush tutoriallist mongodb
(integer) 2
redis 127.0.0.1:6379> lpush tutoriallist rabitmq
(integer) 3
redis 127.0.0.1:6379> lrange tutoriallist 0 10

1) "rabitmq"
2) "mongodb"
3) "redis"
```

列表的最大长度为 2^32 - 1 元素（4294967295，每个列表中可容纳超过4十亿的元素）。

| 命令                                    | 作用                                                            | 备注                                                              |
| :-------------------------------------- | :-------------------------------------------------------------- | ----------------------------------------------------------------- |
| BLPOP key1 [key2 ] timeout              | 取出并获取列表中的第一个元素，或阻塞，直到有可用                |                                                                   |
| BRPOP key1 [key2 ] timeout              | 取出并获取列表中的最后一个元素，或阻塞，直到有可用              |                                                                   |
| BRPOPLPUSH source destination timeout   | 从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用 |                                                                   |
| LINDEX key index                        | 从一个列表其索引获取对应的元素                                  |                                                                   |
| LINSERT key BEFORE（AFTER） pivot value | 在列表中的其他元素之后或之前插入一个元素                        | 要建立索引效率不高                                                |
| LLEN key                                | 获取列表的长度                                                  |                                                                   |
| LPOP key                                | 获取并取出列表中的第一个元素                                    | 取出为空后列表也被删除                                            |
| LPUSH key value1 [value2]               | 在前面加上一个或多个值的列表                                    |                                                                   |
| LPUSHX key value                        | 在前面加上一个值列表，仅当列表中存在                            |                                                                   |
| LRANGE key start stop                   | 从一个列表获取各种元素                                          | 可以为负数，从后面开始数，range为0 -1则是整个列表                 |
| LREM key count value                    | 从列表中删除元素                                                | 要建立索引效率不高，count为0删除所有，为负数从尾部开始向前删除    |
| LSET key index value                    | 在列表中的索引设置一个元素的值                                  | 要建立索引效率不高                                                |
| LTRIM key start stop                    | 修剪列表到指定的范围内                                          |                                                                   |
| RPOP key                                | 取出并获取列表中的最后一个元素                                  |                                                                   |
| RPOPLPUSH source destination            | 删除最后一个元素的列表，将其附加到另一个列表并返回它            | 两个参数都是自身实现列表循环                                      |
| RPUSH key value1 [value2]               | 添加一个或多个值到列表                                          | lpush list1 a b c d [d,c,b,a] <br/> rpush list2 a b c d [a,b,c,d] |
| RPUSHX key value                        | 添加一个值列表，仅当列表中存在                                  |                                                                   |

#### 列表命令的实现

| 命令    | ziplist 编码的实现方法                                                                                                                      | linkedlist 编码的实现方法                                                                                          |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| LPUSH   | 调用 ziplistPush 函数， 将新元素推入到压缩列表的表头。                                                                                      | 调用 listAddNodeHead 函数， 将新元素推入到双端链表的表头。                                                         |
| RPUSH   | 调用 ziplistPush 函数， 将新元素推入到压缩列表的表尾。                                                                                      | 调用 listAddNodeTail 函数， 将新元素推入到双端链表的表尾。                                                         |
| LPOP    | 调用 ziplistIndex 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表头节点。                     | 调用 listFirst 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表头节点。 |
| RPOP    | 调用 ziplistIndex 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表尾节点。                     | 调用 listLast 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表尾节点。  |
| LINDEX  | 调用 ziplistIndex 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素。                                                                 | 调用 listIndex 函数定位双端链表中的指定节点， 然后返回节点所保存的元素。                                           |
| LLEN    | 调用 ziplistLen 函数返回压缩列表的长度。                                                                                                    | 调用 listLength 函数返回双端链表的长度。                                                                           |
| LINSERT | 插入新节点到压缩列表的表头或者表尾时， 使用 ziplistPush 函数； 插入新节点到压缩列表的其他位置时， 使用 ziplistInsert 函数。                 | 调用 listInsertNode 函数， 将新节点插入到双端链表的指定位置。                                                      |
| LREM    | 遍历压缩列表节点， 并调用 ziplistDelete 函数删除包含了给定元素的节点。                                                                      | 遍历双端链表节点， 并调用 listDelNode 函数删除包含了给定元素的节点。                                               |
| LTRIM   | 调用 ziplistDeleteRange 函数， 删除压缩列表中所有不在指定索引范围内的节点。                                                                 | 遍历双端链表节点， 并调用 listDelNode 函数删除链表中所有不在指定索引范围内的节点。                                 |
| LSET    | 调用 ziplistDelete 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 ziplistInsert 函数， 将一个包含给定元素的新节点插入到相同索引上面。 | 调用 listIndex 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值。                              |

### 哈希对象

#### 编码

哈希对象的编码可以是ziplist或者hashtable。

##### ziplist

ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：

* 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
* 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

```shell
redis> HSET profile name "Tom"
(integer) 1
redis> HSET profile age 25
(integer) 1
redis> HSET profile career "Programmer"
(integer) 1
```

如果profile键的值对象使用的是ziplist编码，ziplist编码的profile哈希对象：

![ziplist编码的profile哈希对象](/static/img/redis/Ziplist-encoded-profile-hash-object.png)

profile哈希对象的压缩列表底层实现：

![profile哈希对象的压缩列表底层实现](/static/img/redis/Bottom-implementation-of-compressed-list-of-profile-hash-object.png)

##### hashtable

hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：

* 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
* 字典的每个值都是一个字符串对象，对象中保存了键值对的值。

hashtable编码的profile哈希对象:

![hashtable编码的profile哈希对象](/static/img/redis/Hashtable-encoded-profile-hash-object.png)

#### 编码的转换

当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：

* 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
* 哈希对象保存的键值对数量小于512个；

不能满足这两个条件的哈希对象需要使用hashtable编码。

_Tips：这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明。_

```shell
# 因为键值对的键长度太大而引起编码转换的情况：
# 哈希对象只包含一个键和值都不超过64个字节的键值对
redis> HSET book name "Mastering C++ in 21 days"
(integer) 1
redis> OBJECT ENCODING book
"ziplist"
# 向哈希对象添加一个新的键值对，键的长度为66字节
redis> HSET book long_long_long_long_long_long_long_long_long_long_long_description "content"
(integer) 1
# 编码已改变
redis> OBJECT ENCODING book
"hashtable"
```

```shell
# 值的长度太大也会引起编码转换：
# 哈希对象只包含一个键和值都不超过64个字节的键值对
redis> HSET blah greeting "hello world"
(integer) 1
redis> OBJECT ENCODING blah
"ziplist"
# 向哈希对象添加一个新的键值对，值的长度为68字节
redis> HSET blah story "many string ... many string ... many string ... many string ... many"
(integer) 1
# 编码已改变
redis> OBJECT ENCODING blah
"hashtable"
```

```shell
# 因为包含的键值对数量过多而引起编码转换的情况：
# 创建一个包含512个键值对的哈希对象
redis> EVAL "for i=1, 512 do redis.call('HSET', KEYS[1], i, i)end" 1 "numbers"
(nil)
redis> HLEN numbers
(integer) 512
redis> OBJECT ENCODING numbers
"ziplist"
# 再向哈希对象添加一个新的键值对，使得键值对的数量变成513个
redis> HMSET numbers "key" "value"
OK
redis> HLEN numbers
(integer) 513
# 编码改变
redis> OBJECT ENCODING numbers
"hashtable"
```

#### 哈希操作

Redis的哈希是键值对的集合。Redis的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象。

Hash占用的空间很小

```shell
redis 127.0.0.1:6379> HMSET user:1 username yiibai password yiibai points 200
OK
redis 127.0.0.1:6379> HGETALL user:1

1) "username"
2) "yiibai"
3) "password"
4) "yiibai"
5) "points"
6) "200"

# 返回结果为key value对应的列表 count大小决定查询总数 
# key后面的0表示cursor位置，如果未查询到需要在下次查询中携带上次位置
# match及参数为模糊匹配
redis 127.0.0.1:6379> HSCAN key 0 match "*1*" count 10000000
1) "0"
2) 1) "1232"
   2) "value1"
   3) "1862324"
   4) "value2"

redis-cli -h localhost -p 6379 -a password hvals key| grep "valuegrep" |wc -l
```

| 命令                                           | 作用                               | 备注                        |
| ---------------------------------------------- | ---------------------------------- | --------------------------- |
| HDEL key field2 [field2]                       | 删除一个或多个哈希字段             | 如果filed为空，hash也被删除 |
| HEXISTS key field                              | 判断一个哈希字段存在与否           |                             |
| HGET key field                                 | 获取存储在指定的键散列字段的值     | 返回新增的map键的个数       |
| HGETALL key                                    | 返回哈希中所有的键和值             |                             |
| HINCRBY key field increment                    | 由给定数量增加的哈希字段的整数值   |                             |
| HINCRBYFLOAT key field increment               | 由给定的递增量哈希字段的浮点值     |                             |
| HKEYS key                                      | 获取所有在哈希字段                 |                             |
| HLEN key                                       | 获取哈希字段数                     |                             |
| HMGET key field1 [field2]                      | 获得所有给定的哈希字段的值         |                             |
| HMSET key field1 value1 [field2 value2 ]       | 设置多个哈希字段的多个值           |                             |
| HSET key field value                           | 设置哈希字段的字符串值             |                             |
| HSETNX key field value                         | 设置哈希字段的值，仅当该字段不存在 |                             |
| HVALS key                                      | 获取在哈希中的所有值               |                             |
| HSCAN key cursor [MATCH pattern] [COUNT count] | 增量迭代哈希字段及相关值           |                             |

#### 哈希命令的实现

| 命令    | ziplist 编码实现方法                                                                                                                           | hashtable 编码的实现方法                                                                              |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| HSET    | 首先调用 ziplistPush 函数， 将键推入到压缩列表的表尾， 然后再次调用 ziplistPush 函数， 将值推入到压缩列表的表尾。                              | 调用 dictAdd 函数， 将新节点添加到字典里面。                                                          |
| HGET    | 首先调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后调用 ziplistNext 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点。 | 调用 dictFind 函数， 在字典中查找给定键， 然后调用 dictGetVal 函数， 返回该键所对应的值。             |
| HEXISTS | 调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。                       | 调用 dictFind 函数， 在字典中查找给定键， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。 |
| HDEL    | 调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后将相应的键节点、 以及键节点旁边的值节点都删除掉。                             | 调用 dictDelete 函数， 将指定键所对应的键值对从字典中删除掉。                                         |
| HLEN    | 调用 ziplistLen 函数， 取得压缩列表包含节点的总数量， 将这个数量除以 2 ， 得出的结果就是压缩列表保存的键值对的数量。                           | 调用 dictSize 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量。                |
| HGETALL | 遍历整个压缩列表， 用 ziplistGet 函数返回所有键和值（都是节点）。                                                                              | 遍历整个字典， 用 dictGetKey 函数返回字典的键， 用 dictGetVal 函数返回字典的值。                      |

### 集合对象

#### 编码

集合对象的编码可以是intset或者hashtable。

##### intset

intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

```shell
redis> SADD numbers 1 3 5
(integer) 3
```

intset编码的numbers集合对象：

![intset编码的numbers集合对象](/static/img/redis/Intset-encoded-Numbers-collection-Object.png)

##### hashtable

hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。

```shell
redis> SAD Dfruits "apple" "banana" "cherry"
(integer)3
```

hashtable编码的fruits集合对象：

![hashtable编码的fruits集合对象](/static/img/redis/Hashtable-encoded-Fruits-collection-Object.png)

#### 编码的转换

当集合对象可以同时满足以下两个条件时，对象使用intset编码：

* 集合对象保存的所有元素都是整数值；
* 集合对象保存的元素数量不超过512个。

不能满足这两个条件的集合对象需要使用hashtable编码。

_Tips：第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明。_

```shell
# 向只包含整数元素的集合对象添加一个字符串元素，编码转移操作就会被执行：
redis> SADD numbers 1 3 5
(integer) 3
redis> OBJECT ENCODING numbers
"intset"
redis> SADD numbers "seven"
(integer) 1
redis> OBJECT ENCODING numbers
"hashtable"
```

```shell
# 向集合添加一个新的整数元素，使得这个集合的元素数量超过512，的编码转换操作就会被执行：
redis> EVAL "for i=1, 512 do redis.call('SADD', KEYS[1], i) end" 1 integers
(nil)
redis> SCARD integers
(integer) 512
redis> OBJECT ENCODING integers
"intset"
redis> SADD integers 10086
(integer) 1
redis> SCARD integers
(integer) 513
redis> OBJECT ENCODING integers
"hashtable"
```

#### 集合操作

Redis的集合是字符串的无序集合，不允许重复。在Redis您可以添加，删除和测试文件是否存在，在成员O(1)的时间复杂度。

大数据集合的交集、并集、差集运算都依赖set

```shell
redis 127.0.0.1:6379> sadd tutoriallist redis
(integer) 1
redis 127.0.0.1:6379> sadd tutoriallist mongodb
(integer) 1
redis 127.0.0.1:6379> sadd tutoriallist rabitmq
(integer) 1
redis 127.0.0.1:6379> sadd tutoriallist rabitmq
(integer) 0
redis 127.0.0.1:6379> smembers tutoriallist

1) "rabitmq"
2) "mongodb"
3) "redis"
```

| 命令                                           | 说明                             |
| ---------------------------------------------- | -------------------------------- |
| SADD key member1 [member2]                     | 将一个或多个成员添加到集合       |
| SCARD key                                      | 获取集合中的成员数               |
| SDIFF key1 [key2]                              | 减去多个集合                     |
| SDIFFSTORE destination key1 [key2]             | 减去多个集并将结果集存储在键中   |
| SINTER key1 [key2]                             | 相交多个集合                     |
| SINTERSTORE destination key1 [key2]            | 交叉多个集合并将结果集存储在键中 |
| SISMEMBER key member                           | 判断确定给定值是否是集合的成员   |
| SMOVE source destination member                | 将成员从一个集合移动到另一个集合 |
| SPOP key                                       | 从集合中删除并返回随机成员       |
| SRANDMEMBER key [count]                        | 从集合中获取一个或多个随机成员   |
| SREM key member1 [member2]                     | 从集合中删除一个或多个成员       |
| SUNION key1 [key2]                             | 添加多个集合                     |
| SUNIONSTORE destination key1 [key2]            | 添加多个集并将结果集存储在键中   |
| SSCAN key cursor [MATCH pattern] [COUNT count] | 递增地迭代集合中的元素           |
| SMEMBERS key                                   | 查看set中所有元素                |

*在上面的例子中rabitmq集合添加加两次，但由于集合元素具有唯一属性。*

#### 集合命令的实现

| 命令        | intset 编码的实现方法                                                                                                                              | hashtable 编码的实现方法                                                                                                                                         |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SADD        | 调用 intsetAdd 函数， 将所有新元素添加到整数集合里面。                                                                                             | 调用 dictAdd ， 以新元素为键， NULL 为值， 将键值对添加到字典里面。                                                                                              |
| SCARD       | 调用 intsetLen 函数， 返回整数集合所包含的元素数量， 这个数量就是集合对象所包含的元素数量。                                                        | 调用 dictSize 函数， 返回字典所包含的键值对数量， 这个数量就是集合对象所包含的元素数量。                                                                         |
| SISMEMBER   | 调用 intsetFind 函数， 在整数集合中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。                                  | 调用 dictFind 函数， 在字典的键中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。                                                  |
| SMEMBERS    | 遍历整个整数集合， 使用 intsetGet 函数返回集合元素。                                                                                               | 遍历整个字典， 使用 dictGetKey 函数返回字典的键作为集合元素。                                                                                                    |
| SRANDMEMBER | 调用 intsetRandom 函数， 从整数集合中随机返回一个元素。                                                                                            | 调用 dictGetRandomKey 函数， 从字典中随机返回一个字典键。                                                                                                        |
| SPOP        | 调用 intsetRandom 函数， 从整数集合中随机取出一个元素， 在将这个随机元素返回给客户端之后， 调用 intsetRemove 函数， 将随机元素从整数集合中删除掉。 | 调用 dictGetRandomKey 函数， 从字典中随机取出一个字典键， 在将这个随机字典键的值返回给客户端之后， 调用 dictDelete 函数， 从字典中删除随机字典键所对应的键值对。 |
| SREM        | 调用 intsetRemove 函数， 从整数集合中删除所有给定的元素。                                                                                          | 调用 dictDelete 函数， 从字典中删除所有键为给定元素的键值对。                                                                                                    |

### 有序集合对象

有序集合的编码可以是ziplist或者skiplist。

#### 编码

##### ziplist

ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。

压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

```shell
redis> ZADD price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
```

ziplist编码的有序集合对象：

![ziplist编码的有序集合对象](/static/img/redis/Ziplist-coded-ordered-collection-object.png)

有序集合元素在压缩列表中按分值从小到大排列：

![有序集合元素在压缩列表中按分值从小到大排列](/static/img/redis/Ordered-collection-elements-are-sorted-from-small-to-large-in-the-compressed-list.png)

##### skiplist

skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

```c++
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
} zset;
```

* zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素
	* 跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。
	* 通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。
* 除此之外，zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素
	* 字典的键保存了元素的成员，而字典的值则保存了元素的分值。
	* 通过这个字典，程序可以用O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。

有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。

虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。

**为什么有序集合需要同时使用跳跃表和字典来实现？**

无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。

skiplist编码的有序集合对象：

![skiplist编码的有序集合对象](/static/img/redis/Skiplist-coded-ordered-collection-object.png)

有序集合元素同时被保存在字典和跳跃表中：

![有序集合元素同时被保存在字典和跳跃表中](/static/img/redis/Ordered-collection-elements-are-also-saved-in-dictionaries-and-jump-tables.png)

_注意：在字典和跳跃表中重复展示了各个元素的成员和分值，实际中字典和跳跃表会共享元素的成员和分值_

#### 编码的转换

当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

* 有序集合保存的元素数量小于128个；
* 有序集合保存的所有元素成员的长度都小于64字节；

不能满足以上两个条件的有序集合对象将使用skiplist编码。

_Tips：以上两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明。_

```shell
# 因为包含了过多元素而引发编码转换的情况：
# 对象包含了128个元素
redis> EVAL "for i=1, 128 do redis.call('ZADD', KEYS[1], i, i) end" 1 numbers
(nil)
redis> ZCARD numbers
(integer) 128
redis> OBJECT ENCODING numbers
"ziplist"
# 再添加一个新元素
redis> ZADD numbers 3.14 pi
(integer) 1
# 对象包含的元素数量变为129个
redis> ZCARD numbers
(integer) 129
# 编码已改变
redis> OBJECT ENCODING numbers
"skiplist"
```

```shell
# 元素的成员过长而引发编码转换的情况：
# 向有序集合添加一个成员只有三字节长的元素
redis> ZADD blah 1.0 www
(integer) 1
redis> OBJECT ENCODING blah
"ziplist"
# 向有序集合添加一个成员为66字节长的元素
redis> ZADD blah 2.0 ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
(integer) 1
# 编码已改变
redis> OBJECT ENCODING blah
"skiplist"
```

#### 有序集合操作

Redis的有序集合类似于Redis的集合，字符串不重复的集合。不同的是，一个有序集合的每个成员用分数，以便采取有序set命令，从最小的到最大的成员分数有关。虽然成员具有唯一性，但分数可能会重复。

使用分数保证元素有序，每个元素都要手动赋分，适合做排行榜

```shell
redis 127.0.0.1:6379> zadd tutoriallist 0 redis
(integer) 1
redis 127.0.0.1:6379> zadd tutoriallist 0 mongodb
(integer) 1
redis 127.0.0.1:6379> zadd tutoriallist 0 rabitmq
(integer) 1
redis 127.0.0.1:6379> zadd tutoriallist 0 rabitmq
(integer) 0
redis 127.0.0.1:6379> ZRANGEBYSCORE tutoriallist 0 1000

1) "redis"
2) "mongodb"
3) "rabitmq"
```

| 命令                                           | 作用                                                           | 示例                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| :--------------------------------------------- | :------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ZADD key score1 member1 [score2 member2]       | 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZCARD key                                      | 得到的有序集合成员的数量                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZCOUNT key min max                             | 计算一个有序集合成员与给定值范围内的分数                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZINCRBY key increment member                   | 在有序集合增加成员的分数                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZINTERSTORE destination numkeys key [key ...]  | 多重交叉排序集合，并存储生成一个新的键有序集合。               | redis 127.0.0.1:6379> ZADD myset 1 "hello"<br/>(integer) 1<br/>redis 127.0.0.1:6379> ZADD myset 2 "world"<br/>(integer) 1<br/>redis 127.0.0.1:6379> ZADD myset2 1 "hello"<br/>(integer) 1<br/>redis 127.0.0.1:6379> ZADD myset2 2 "world"<br/>(integer) 1<br/>redis 127.0.0.1:6379> ZADD myset2 3 "foo"<br/>(integer) 1<br/>redis 127.0.0.1:6379> ZINTERSTORE out 2 myset1 myset2 WEIGHTS 2 3"<br/>(integer) 3<br/>redis 127.0.0.1:6379> ZRANGE out 0 -1 WITHSCORES<br/>1) "hello"<br/>2) "5"<br/>3) "world"<br/>4) "10" |
| ZLEXCOUNT key min max                          | 计算一个给定的字典范围之间的有序集合成员的数量                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZRANGE key start stop [WITHSCORES]             | 由索引返回一个成员范围的有序集合。                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZRANGEBYLEX key min max [LIMIT offset count]   | 返回一个成员范围的有序集合（由字典范围）                       | redis 127.0.0.1:6379> ZADD myzset 0 a 0 b 0 c 0 d 0 e<br/>(integer) 5<br/>redis 127.0.0.1:6379> ZADD myzset 0 f 0 g<br/>(integer) 2<br/>redis 127.0.0.1:6379> ZRANGEBYLEX myzset - [c<br/>1) "a"<br/>2) "b"<br/>3) "c"<br/>redis 127.0.0.1:6379> ZRANGEBYLEX myzset - (c<br/>1) "a"<br/>2) "b" <br/> **两个开始和结束是从零开始的索引，其中0是第一个元素，1是下一个元素等等。它们也可以是表示偏移量从有序集的结尾，以-1作为排序的集合的最后一个元素，-2倒数第二元素等负数。**                                            |
| ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] | 按分数返回一个成员范围的有序集合。                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZRANK key member                               | 确定成员的索引中有序集合                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZREM key member [member ...]                   | 从有序集合中删除一个或多个成员                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZREMRANGEBYLEX key min max                     | 删除所有成员在给定的字典范围之间的有序集合                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZREMRANGEBYRANK key start stop                 | 在给定的索引之内删除所有成员的有序集合                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZREMRANGEBYSCORE key min max                   | 在给定的分数之内删除所有成员的有序集合                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZREVRANGE key start stop [WITHSCORES]          | 返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZREVRANGEBYSCORE key max min [WITHSCORES]      | 返回一个成员范围的有序集合，按分数，以分数排序从高分到低分     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZREVRANK key member                            | 确定一个有序集合成员的索引，以分数排序，从高分到低分           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZSCORE key member                              | 获取给定成员相关联的分数在一个有序集合                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZUNIONSTORE destination numkeys key [key ...]  | 添加多个集排序，所得排序集合存储在一个新的键                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ZSCAN key cursor [MATCH pattern] [COUNT count] | 增量迭代排序元素集和相关的分数                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

#### 有序集合命令的实现

| 命令      | ziplist 编码的实现方法                                                                                                               | zset 编码的实现方法                                                                                                                |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| ZADD      | 调用 ziplistInsert 函数， 将成员和分值作为两个节点分别插入到压缩列表。                                                               | 先调用 zslInsert 函数， 将新元素添加到跳跃表， 然后调用 dictAdd 函数， 将新元素关联到字典。                                        |
| ZCARD     | 调用 ziplistLen 函数， 获得压缩列表包含节点的数量， 将这个数量除以 2 得出集合元素的数量。                                            | 访问跳跃表数据结构的 length 属性， 直接返回集合元素的数量。                                                                        |
| ZCOUNT    | 遍历压缩列表， 统计分值在给定范围内的节点的数量。                                                                                    | 遍历跳跃表， 统计分值在给定范围内的节点的数量。                                                                                    |
| ZRANGE    | 从表头向表尾遍历压缩列表， 返回给定索引范围内的所有元素。                                                                            | 从表头向表尾遍历跳跃表， 返回给定索引范围内的所有元素。                                                                            |
| ZREVRANGE | 从表尾向表头遍历压缩列表， 返回给定索引范围内的所有元素。                                                                            | 从表尾向表头遍历跳跃表， 返回给定索引范围内的所有元素。                                                                            |
| ZRANK     | 从表头向表尾遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 | 从表头向表尾遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 |
| ZREVRANK  | 从表尾向表头遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 | 从表尾向表头遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 |
| ZREM      | 遍历压缩列表， 删除所有包含给定成员的节点， 以及被删除成员节点旁边的分值节点。                                                       | 遍历跳跃表， 删除所有包含了给定成员的跳跃表节点。 并在字典中解除被删除元素的成员和分值的关联。                                     |
| ZSCORE    | 遍历压缩列表， 查找包含了给定成员的节点， 然后取出成员节点旁边的分值节点保存的元素分值。                                             | 直接从字典中取出给定成员的分值。                                                                                                   |

### 类型检查与命令多态

Redis中用于操作键的命令基本上可以分为两种类型。

* 其中一种命令可以对任何类型的键执行
	* 比如DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。
* 而另一种命令只能对特定类型的键执行
	* SET、GET、APPEND、STRLEN等命令只能对字符串键执行；
	* HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；
	* RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；
	* SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；
	* ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行；

#### 类型检查的实现

类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：

* 在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；
* 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。

#### 多态命令的实现

Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

DEL、EXPIRE等命令和LLEN等命令的区别在于，前者是基于类型的多态——一个命令可以同时用于处理多种不同类型的键，而后者是基于编码的多态——一个命令可以同时用于处理多种不同编码。

LLEN命令的执行过程：

![LLEN命令的执行过程](/static/img/redis/Execution-of-the-Llen-command.png)

### 内存回收

因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息由redisObject结构的refcount属性记录：

```c++
typedef struct redisObject {
    // ...
    // 引用计数
    int refcount;
    // ...
} robj;
```

对象的引用计数信息会随着对象的使用状态而不断变化：

* 在创建一个新对象时，引用计数的值会被初始化为1；
* 当对象被一个新程序使用时，它的引用计数值会被增一；
* 当对象不再被一个程序使用时，它的引用计数值会被减一；
* 当对象的引用计数值变为0时，对象所占用的内存会被释放。

修改对象引用计数的API：

| 函数          | 作用                                                                                              |
| ------------- | ------------------------------------------------------------------------------------------------- |
| incrRefCount  | 将对象的引用计数值增一。                                                                          |
| decrRefCount  | 将对象的引用计数值减一， 当对象的引用计数值等于 0 时， 释放对象。                                 |
| resetRefCount | 将对象的引用计数值设置为 0 ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |

对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。

作为例子， 以下代码展示了一个字符串对象从创建到释放的整个过程：

```c++
// 创建一个字符串对象 s ，对象的引用计数为 1
robj *s = createStringObject(...)

// 对象 s 执行各种操作 ...

// 将对象 s 的引用计数减一，使得对象的引用计数变为 0
// 导致对象 s 被释放
decrRefCount(s)
```

### 对象共享

除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。

在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：

1. 将数据库键的值指针指向一个现有的值对象；
2. 将被共享的值对象的引用计数增一。

目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改。

使用OBJECT REFCOUNT命令查看键A的值对象的引用计数:

```shell
# 引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键A
redis> SET A 100
OK
redis> OBJECT REFCOUNT A
(integer) 2
```

![引用数为3的共享对象](/static/img/redis/Shared-objects-with-a-reference-number-of-3.png)

这些共享对象不单单只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象、hashtable编码的集合对象，以及zset编码的有序集合对象）都可以使用这些共享对象。

**为什么Redis不共享包含字符串的对象？**

当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，
只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，
而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：

* 如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O(1)；
* 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)；
* 如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N2)。

因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。

### 对象的空转时长

除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：

```c++
typedef struct redisObject {
    // ...
    unsigned lru:22;
    // ...
} robj;
```

OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：

```shell
redis> SET msg "hello world"
OK
# 等待一小段时间
redis> OBJECT IDLETIME msg
(integer) 20
# 等待一阵子
redis> OBJECT IDLETIME msg
(integer) 180
# 访问msg键的值
redis> GET msg
"hello world"
# 键处于活跃状态，空转时长为0 
redis> OBJECT IDLETIME msg
(integer) 0
```

_注意：OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。_

键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，
那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。

配置文件的maxmemory选项和maxmemory-policy选项的说明介绍了关于这方面的更多信息。

## 数据库

| 命令           | 作用                    | 示例                                                                                                   |
| :------------- | :---------------------- | :----------------------------------------------------------------------------------------------------- |
| SELECT index   | 更改当前连接所选数据库  | 默认在0号数据库，总共16个数据库<br/>redis 127.0.0.1:6379> SELECT 1<br/>OK<br/>redis 127.0.0.1:6379[1]> |
| MOVE key index | 将key移动到指定的数据库 |                                                                                                        |
| FLUSHDB        | 清空数据库              |                                                                                                        |
| FLUSHALL       | 清空整个redis           |                                                                                                        |

## 消息订阅和发布

| 命令                                      | 说明                               |
| ----------------------------------------- | ---------------------------------- |
| PSUBSCRIBE pattern [pattern …]            | 订阅一个或多个符合给定模式的频道。 |
| PUBSUB subcommand [argument [argument …]] | 查看订阅与发布系统状态。           |
| PUBLISH channel message                   | 将信息发送到指定的频道。           |
| PUNSUBSCRIBE [pattern [pattern …]]        | 退订所有给定模式的频道。           |
| SUBSCRIBE channel [channel …]             | 订阅给定的一个或多个频道的信息。   |
| UNSUBSCRIBE [channel [channel …]]         | 退订给定的频道。                   |

## 事务

Redis事务让一组命令在单个步骤执行。事务中有两个属性，说明如下：

* 在一个事务中的所有命令按顺序执行作为单个隔离操作。通过另一个客户端发出的请求在Redis的事务的过程中执行，这是不可能的。

* Redis的事务具有原子性。原子意味着要么所有的命令都执行或都不执行。

* 有一条命令执行失败，剩余的命令还是会执行

```shell
redis 127.0.0.1:6379> MULTI
OK
redis 127.0.0.1:6379> SET tutorial redis
QUEUED
redis 127.0.0.1:6379> GET tutorial
QUEUED
redis 127.0.0.1:6379> INCR visitors
QUEUED
redis 127.0.0.1:6379> EXEC

1) OK
2) "redis"
3) (integer) 1
```

| 命令                | 作用                               |
| :------------------ | :--------------------------------- |
| DISCARD             | 发出命令MULTI后丢弃所有            |
| EXEC                | MULTI后执行发出所有命令            |
| MULTI               | 标记事务块的开始                   |
| UNWATCH             | 取消所有的对应关注键               |
| WATCH key [key ...] | 关注给定项，以确定执行MULTI/EXEC块 |

## 脚本

Redis脚本使用Lua解释器用于计算脚本。它Redis从2.6.0版本开始内置。使用脚本eval命令。

```shell
redis 127.0.0.1:6379> EVAL "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second

1) "key1"
2) "key2"
3) "first"
4) "second"
```

| 命令                                             | 作用                          |
| :----------------------------------------------- | :---------------------------- |
| EVAL script numkeys key [key ...] arg [arg ...]  | 执行一个Lua脚本。             |
| EVALSHA sha1 numkeys key [key ...] arg [arg ...] | 执行一个Lua脚本。             |
| SCRIPT EXISTS script [script ...]                | 检查脚本是否存在于缓存中。    |
| SCRIPT FLUSH                                     | 删除脚本缓存中的所有脚本。    |
| SCRIPT KILL                                      | 终止目前在执行的脚本。        |
| SCRIPT LOAD script                               | 加载指定的Lua脚本到脚本缓存。 |

## 连接

Redis的连接命令基本上都是用于管理Redis的服务器与客户端连接。

```shell
redis 127.0.0.1:6379> AUTH "password"
OK
redis 127.0.0.1:6379> PING
PONG
```

| 命令          | 作用                   | 示例                                                                                                   |
| :------------ | :--------------------- | :----------------------------------------------------------------------------------------------------- |
| AUTH password | 服务器验证给定的密码   |                                                                                                        |
| ECHO message  | 打印给定的字符串       |                                                                                                        |
| PING          | 检查服务器是否正在运行 |                                                                                                        |
| QUIT          | 关闭当前连接           |                                                                                                        |
| SELECT index  | 更改当前连接所选数据库 | 默认在0号数据库，总共16个数据库<br/>redis 127.0.0.1:6379> SELECT 1<br/>OK<br/>redis 127.0.0.1:6379[1]> |

## 服务端

Redis服务器命令基本上都用于管理Redis服务器。

| 命令                                         | 作用                                       |
| :------------------------------------------- | :----------------------------------------- |
| BGREWRITEAOF                                 | 异步改写仅追加文件                         |
| BGSAVE                                       | 异步保存数据集到磁盘（快照）               |
| CLIENT KILL [ip:port] [ID client-id]         | 杀死一个客户端的连接                       |
| CLIENT LIST                                  | 获取客户端连接到服务器的连接列表           |
| CLIENT GETNAME                               | 获取当前连接的名称                         |
| CLIENT PAUSE timeout                         | 停止指定的时间处理来自客户端的命令         |
| CLIENT SETNAME connection-name               | 设置当前连接名称                           |
| CLUSTER SLOTS                                | 获取集群插槽数组节点的映射                 |
| COMMAND                                      | 获取Redis的命令的详细信息数组              |
| COMMAND COUNT                                | 得到的Redis命令的总数                      |
| COMMAND GETKEYS                              | 给予充分的Redis命令提取键                  |
| COMMAND INFO command-name [command-name ...] | 获取具体的Redis命令的详细信息数组          |
| CONFIG GET parameter                         | 获取配置参数的值                           |
| CONFIG REWRITE                               | 重写的存储器配置的配置文件                 |
| CONFIG SET parameter value                   | 配置参数设置为给定值                       |
| CONFIG RESETSTAT                             | 复位信息返回的统计                         |
| DBSIZE                                       | 返回所选数据库中的键的数目                 |
| DEBUG OBJECT key                             | 获取有关的一个关键的调试信息               |
| DEBUG SEGFAULT                               | 使服务器崩溃                               |
| FLUSHALL                                     | 从所有数据库中删除所有项                   |
| FLUSHDB                                      | 从当前数据库中删除所有项                   |
| INFO [section]                               | 获取有关服务器的信息和统计数据             |
| LASTSAVE                                     | 获得最后成功的UNIX时间时间戳保存到磁盘     |
| MONITOR                                      | 监听由实时服务器接收到的所有请求           |
| ROLE                                         | 返回在复制的情况下实例的角色               |
| SAVE                                         | 同步保存数据集到磁盘（快照）               |
| SHUTDOWN [NOSAVE] [SAVE]                     | 同步的数据集保存到磁盘，然后关闭服务器     |
| SLAVEOF host port                            | 使服务器为另一个实例的从站或者促进其作为主 |
| SLOWLOG subcommand [argument]                | 管理Redis的慢查询日志                      |
| SYNC                                         | 命令用于复制                               |
| TIME                                         | 返回当前服务器时间                         |

## 持久化

两种持久化策略

* RDB：相当于照快照，默认开启
	- 优点
		+ 速度快，占用空间小
		+ 适用于灾难备份
	- 缺点
		+ 符合要求就会照快照，占用系统资源（突然的），小内存机器不适合使用
			* 服务器正常关闭时
				- redis-cli shutdown
			* key满足条件时
				- save 900 1 每900秒，有一个key发生变化
				- save 300 10 每5分钟，至少有10个key发生变化
				- save 60 10000 每60秒，至少有10000个key发生变化
* AOF：使用日志功能保存数据，默认关闭
	- 机制：只保存导致key发生变化的语句
		+ everysec 每秒同步，默认机制（安全性低，节省资源）
		+ always 每修改同步（比较安全，浪费资源）
		+ no 完全交给操作系统，操作系统不繁忙时同步（不安全）
	- 优点
		+ 持续性占用少量资源
	- 缺点
		+ 日志文件会很大，不适用于灾难恢复

```conf
appendonly yes

# appendfsync always
appendfsync everysec
# appendfsync no

```

## 备份和还原

### 备份

Redis SAVE命令用来创建备份当前Redis数据库。

```shell
127.0.0.1:6379> SAVE

OK
```

这个命令将创建dump.rdb文件在Redis目录。

要创建Redis备份备用命令BGSAVE也可以的。这个命令将开始备份过程，并在后台运行。

```shell
127.0.0.1:6379> BGSAVE

Background saving started
```

### 还原

要恢复Redis数据只是移动Redis备份文件(dump.rdb)到Redis目录，然后启动服务器。为了让Redis读取到Redis目录，使用CONFIG命令如下所示：

```shell
redis 127.0.0.1:6379> config get dir
1) "dir"
2) "/var/lib/redis"
```

在上述的输出命令/var/lib/redis是目录，在安装redis服务器。

## 安全

Redis数据库可以设置安全，所以做出相关的任何客户端都需要在执行命令之前进行身份验证。为了确保Redis需要设置在配置文件中的密码验证一致。

```shell
127.0.0.1:6379> CONFIG get requirepass
1) "requirepass"
2) ""
127.0.0.1:6379> CONFIG set requirepass "yiibai"
OK
127.0.0.1:6379> CONFIG get requirepass
1) "requirepass"
2) "yiibai"
```

在配置文件中修改：

```conf
requirepass password
```

**认证**

```shell
127.0.0.1:6379> AUTH "yiibai"
OK
127.0.0.1:6379> SET mykey "Test value"
OK
127.0.0.1:6379> GET mykey
"Test value"
```

```shell
redis-cli -h 127.0.0.1 -p 6379 -a password
```

## 性能

Redis的基准是实用程序运行n个命令检查Redis 的性能。

```shell
redis-benchmark -n 100000

PING_INLINE: 141043.72 requests per second
PING_BULK: 142857.14 requests per second
SET: 141442.72 requests per second
GET: 145348.83 requests per second
INCR: 137362.64 requests per second
LPUSH: 145348.83 requests per second
LPOP: 146198.83 requests per second
SADD: 146198.83 requests per second
SPOP: 149253.73 requests per second
LPUSH (needed to benchmark LRANGE): 148588.42 requests per second
LRANGE_100 (first 100 elements): 58411.21 requests per second
LRANGE_300 (first 300 elements): 21195.42 requests per second
LRANGE_500 (first 450 elements): 14539.11 requests per second
LRANGE_600 (first 600 elements): 10504.20 requests per second
MSET (10 keys): 93283.58 requests per second
```

Redis的基准有许多可供选择

| 选项  | 描述                                  | 默认值    |
| :---- | :------------------------------------ | :-------- |
| -h    | 指定服务器的主机名                    | 127.0.0.1 |
| -p    | 指定服务器端口                        | 6379      |
| -s    | 指定服务器套接字                      |           |
| -c    | 指定并行连接数                        | 50        |
| -n    | 指定请求总数                          | 10000     |
| -d    | 指定以字节为单位设置/获取值的数据大小 | 2         |
| -k    | 1=保持活动0=重新连接                  | 1         |
| -r    | 使用随机键对SET/GET/INCR，随机SADD值  |           |
| -p    | 管道<numreq>请求                      | 1         |
| -h    | 指定服务器的主机名                    |           |
| -q    | Redis强制安静操作。只显示查询/秒值    |           |
| --csv | 输出为CSV格式                         |           |
| -l    | 产生循环，永远运行测试                |           |
| -t    | 只有运行的逗号分隔的测试列表。        |           |
| -I    | 空闲模式。刚刚开N个空闲连接和等待。   |           |

```shell
redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 100000 -q

SET: 146198.83 requests per second
LPUSH: 145560.41 requests per second
```

### 客户端设置

Redis接受上配置监听TCP端口和Unix套接字客户端的连接，如果启用。当一个新的客户端连接被接受，如有以下操作进行：

客户端套接字置于非阻塞状态，因为Redis的使用复用和非阻塞I/O操作。

TCP_NODELAY选项设定是为了以确保我们没有连接延迟。

创建一个可读的文件时，这样Redis能够尽快收集客户端的查询作为新的数据可供读取的Socket中。

**客户端的最大数量**

```shell
config get maxclients

1) "maxclients"
2) "10000"
```

默认情况下，此属性设置为10000(这取决于操作系统的文件描述符限制最大数量)，但你可以改变这个属性。.

```shell
redis-server --maxclients 100000
```

| 命令           | 描述                                                                  |
| :------------- | :-------------------------------------------------------------------- |
| CLIENT LIST    | 返回客户端的列表连接到Redis服务器                                     |
| CLIENT SETNAME | 指定名称的当前连接                                                    |
| CLIENT GETNAME | 返回由CLIENT SETNAME设置当前连接的名称。                              |
| CLIENT PAUSE   | 这是一个连接控制命令可以暂停所有Redis客户指定的时间量(以毫秒为单位)。 |
| CLIENT KILL    | 该命令关闭特定的客户端连接。                                          |

## 管道

**管道传输的含义**

管道的基本含义是，客户端可以发送多个请求给服务器，而无需等待答复所有，并最后读取在单个步骤中的答应。

要检查redis的管道，只要开始Redis的实例，然后在终端键入以下命令。

```shell
$(echo -en "PING\r\n SET tutorial redis\r\nGET tutorial\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n"; sleep 10) | nc localhost 6379

+PONG
+OK
redis
:1
:2
:3
```

在上述例子中，我们必须使用PING命令检查Redis的连接，之后，我们已经设定Redis字符串的值命名为tutorial，之后取到key值和增量参访问数的三倍。在结果中，我们可以检查所有的命令都一次提交给Redis，Redis在单一步骤中给定所有命令的输出。

**管道的好处**

这种技术的好处是显着提高协议的性能。获得通过管道范围从5个之中的一个因素的连接提高，localhost至少达到过百倍的网络连接速度。

## 分区

分区是一种将数据分成多个Redis的情况下，让每一个实例将只包含关键字的子集的过程。

**分区的好处**

* 它允许更大的数据库，使用的多台计算机的内存的总和。如果不分区，一台计算机有限的内存可以支持有限的数量。
* 它允许以大规模的计算能力，以多个内核和多个计算机，以及网络带宽向多台计算机和网络适配器在一起使用。

**分区的缺点**

* 通常不支持涉及多个按键的操作。例如，不能两个集合之间执行交叉点，如果它们被存储在被映射到不同的Redis实例中的键。
* 涉及多个键的Redis事务不能被使用。
* 分区粒度是键，所以它不可能将分片数据集用一个硕大的键在一个非常大的有序集合。
* 当分区时，数据处理比较复杂，比如要处理多个RDB/AOF文件，使数据备份，需要从多个实例和主机聚集持久性文件。
* 添加和删除的能力可能很复杂。比如Redis集群支持有加，并在运行时删除节点不支持此功能的能力，但其他系统，如客户端的分区和代理的数据大多是透明平衡。有一个叫Presharding技术有助于解决这方面的问题。

### 分区的类型

redis提供两种类型的分区。假设我们有四个的Redis实例R0，R1，R2，R3和代表用户喜欢的用户很多键： user:1, user:2, ... 等等

#### 范围分区

范围分区被映射对象转化为具体的Redis实例的范围内实现。假定在本例中用户ID0〜ID10000将进入实例R0，而用户形成ID10001至20000号将进入实例R1等等。

#### 散列分区

在这种类型的分区，一个散列函数(例如，模数函数)被用于转换键成数字，然后数据被存储在不同地方 - 它们是不同redis的实例。

*以上资源来源于[Redis快速入门](http://www.yiibai.com/redis/redis_quick_guide.html)*

---

## 使用场景

* 关系型数据库的缓存存在
* 做任务队列
* 大量数据集合运算
* 大量数据排序

## 启动和连接

```shell
# 后端启动需要配置daemonize yes
redis-server ./redis.confg
service redis-server start
# --raw命令获取中文不会返回unicode编码
redis-cli -h 127.0.0.1 -p 6379 --raw
# 正常停止redis
redis-cli -h 127.0.0.1 -p 6379 shutdown
```

## Redis存储key设计

> [表名]:[主键名]:[主键值]:[列名]

```shell
set b2c_user:id:1:name zhangsan
keys b2c_user:id:1*
get b2c_user:id:1:name
```

## 绑定多个IP

```shell
# 2.8 以后可以绑定到多个特定的地址上
bind 127.0.0.1 192.168.3.3
```

*以上资源来源于传智播客Redis视频教程*
