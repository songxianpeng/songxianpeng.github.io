---  
lajout: post  
title: 基本类型包装类  
tags: Java基础 Math BigInteger BigDecimal  
categories: Java  
published: true  
---  

将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。

# 基本类型和包装类的对应

| 基本类型 |  包装类   |
|----------|-----------|
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| char     | Character |
| boolean  | Boolean   |

# Integer

## Java程序中的进制范围

> public static String toString(int i,int radix)//大于36小于2的参数不会报错，但是结果依然是i值  
> 由这个我们也看到了进制的范围：2-36  
> 为什么呢?0,...9,a...z共36个，只能表示36进制数  

## Integer i = 1; i += 1;做了哪些事情

```java
Integer i = 1;//1自动装箱成包装类型
i += 1;//i拆箱成基本数据类型，进行运算后自动装箱成包装类型

// 通过反编译后的代码
Integer ii = Integer.valueOf(100); //自动装箱
ii = Integer.valueOf(ii.intValue() + 200); //自动拆箱，再自动装箱
System.out.println((new StringBuilder("ii:")).append(ii).toString());
```

## 缓冲池

-128到127之间的数据缓冲池问题

```java
Integer i1 = new Integer(127);
Integer i2 = new Integer(127);
System.out.println(i1 == i2);//false 这里因为是new出来的所以内存地址不同
System.out.println(i1.equals(i2));//true

Integer i3 = new Integer(128);
Integer i4 = new Integer(128);
System.out.println(i3 == i4);//false
System.out.println(i3.equals(i4));//true

Integer i5 = 127;//编译后的代码为Integer.valueOf(127);
Integer i6 = 127;
System.out.println(i5 == i6);//true 这里由于缓冲池存在所以相等
System.out.println(i5.equals(i6));//true

Integer i7 = 128;
Integer i8 = 128;
System.out.println(i7 == i8);//false 超过127范围不在缓冲池范围内
System.out.println(i7.equals(i8));//true

//通过查看源码，我们就知道了，针对-128到127之间的数据，做了一个数据缓冲池
//如果数据是该范围内的，每次并不创建新的空间
public static Integer valueOf(int i) {
    if(i >= -128 && i <= IntegerCache.high)//high的值为127
        return IntegerCache.cache[i + 128];
    else
        return new Integer(i);//超出范围new
}
```

# Math类

Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数、获取随机数等。

```java
public static int getRandom(int start, int end) {
	return (int) (Math.random() * (end - start + 1)) + start;
}
```

# BigInteger

可以让超过Integer范围内的数据进行运算

```java
BigInteger bi1 = new BigInteger("100");
BigInteger bi2 = new BigInteger("50");

System.out.println(bi1.add(bi2));
System.out.println(bi1.subtract(bi2));
System.out.println(bi1.multiply(bi2));
System.out.println(bi1.divide(bi2));
BigInteger[] b = bi1.divideAndRemainder(bi2);//除法并取余
System.outprintln. (b[0]);
System.out.println(b[1]);

```

# BigDecimal

由于在运算的时候，float类型和double很容易丢失精度，演示案例。所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal

```java
//在运算的过程中，float类型和double类型容易引起精度的丢失
System.out.println(0.09 + 0.01);//0.09999999999999999
System.out.println(1.0 - 0.32);//0.6799999999999999
System.out.println(1.015 * 100);//101.49999999999999
System.out.println(1.301 / 100);//0.013009999999999999
```

public BigDecimal(double val) 查看API的解释，说其有不可预知性。而字符串参数的是结果可预知的。所以构造函数推荐实用String参数的构造函数 

```java
BigDecimal bd1 = new BigDecimal("0.09");
BigDecimal bd2 = new BigDecimal("0.01");
System.out.println(bd1.add(bd2));//0.10
BigDecimal bd3 = new BigDecimal("1.0");
BigDecimal bd4 = new BigDecimal("0.32");
System.out.println(bd3.subtract(bd4));//0.68
BigDecimal bd5 = new BigDecimal("1.015");
BigDecimal bd6 = new BigDecimal("100");
System.out.println(bd5.multiply(bd6));//101.500
BigDecimal bd7 = new BigDecimal("1.301");
BigDecimal bd8 = new BigDecimal("100");
System.out.println(bd7.divide(bd8));//0.01301
System.out.println(bd7.divide(bd8, 2,BigDecimal.ROUND_HALF_UP));// 0.01 这里需要给定保留小数位数和舍入模式
```

----------

*以上概念总结于传智播客Java基础课程*