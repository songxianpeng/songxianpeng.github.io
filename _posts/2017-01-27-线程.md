---  
lajout: post  
title: 线程  
tags: Thread  
categories: Java  
published: true  
---  

## 线程

* 进程：
	- 正在运行的程序，是系统进行资源分配和调用的独立（基本）单位。
	- 每一个进程都有它自己的内存空间和系统资源。
* 线程：
	- 是进程中的单个顺序控制流，是一条执行路径，程序使用CPU的基本单位
	- 一个进程如果只有一条执行路径，则称为单线程程序。
	- 一个进程如果有多条执行路径，则称为多线程程序。

### 对于单核计算机来讲，游戏进程和音乐进程是同时运行吗

不是。

> 因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。  
> 多进程的作用不是提高执行速度，而是提高CPU的使用率。


### 多进程有什么意义

能在同一个`时间段`内执行多个任务。提高CPU的使用率。

### 多线程有什么意义

多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。(程序抢占CPU时间片几率更大)  
而多线程却给了我们一个错觉：让我们认为多个线程是并发执行的。其实不是。  
因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。

### 什么是并发

大家注意两个词汇的区别：*并行和并发*。

前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。  
后者是物理上同时发生，指在某一个时间点同时运行多个程序。  
那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。

### JVM虚拟机的启动是单线程的还是多线程的？

JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。

## 多线程的实现方案

### 继承Thread类

#### 步骤

 1. 自定义类MyThread继承Thread类。
 2. MyThread类里面重写run()
 3. 创建对象
 4. 启动线程

```java
public class MyThread extends Thread {
	@Override
	public void run() {
		System.out.println("thread running");
	}
}
```

#### 线程能不能多次启动

```java
// MyThread my = new MyThread();
// my.start();
// // IllegalThreadStateException:非法的线程状态异常
// // 为什么呢?因为这个相当于是my线程被调用了两次。而不是两个线程启动。
// my.start();

// 创建两个线程对象
MyThread my1 = new MyThread();
MyThread my2 = new MyThread();

my1.start();
my2.start();
```

### 实现Runnable接口

#### 步骤

 1. 自定义类MyRunnable实现Runnable接口
 2. 重写run()方法
 3. 创建MyRunnable类的对象
 4. 创建Thread类的对象，并把C步骤的对象作为构造参数传递

```java
public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int x = 0; x < 100; x++) {
			// 由于实现接口的方式就不能直接使用Thread类的方法了,但是可以间接的使用
			System.out.println(Thread.currentThread().getName() + ":" + x);
		}
	}

}


MyRunnable my = new MyRunnable();

// 创建Thread类的对象，并把C步骤的对象作为构造参数传递
// Thread(Runnable target)
// Thread t1 = new Thread(my);
// Thread t2 = new Thread(my);
// t1.setName("林青霞");
// t2.setName("刘意");

// Thread(Runnable target, String name)
Thread t1 = new Thread(my, "林青霞");
Thread t2 = new Thread(my, "刘意");

t1.start();
t2.start()
```

#### 如何获取和设置线程名称

通过Thread.currentThread()获取当前线程后获取或设置县城名

#### 实现接口方式的好处

* 可以避免由于Java单继承带来的局限性。
* 适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。

### 多线程两种方式比较及区别

![多线程两种方式的图解比较及区别](/static/img/线程/多线程两种方式的图解比较及区别.jpg "多线程两种方式的图解比较及区别")

### 实现Callable接口或者Runable接口（和线程池结合）

* 好处：
	- 可以有返回值
	- 可以抛出异常
* 弊端：
	- 代码比较复杂，所以一般不用

## 线程调度

* 分时调度模型
	- 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
* 抢占式调度模型
	- 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 

> Java使用的是抢占式调度模型。

```java
// 设置getPriority()和获取setPriority()线程优先级 默认是5 范围是1-10
// 线程优先级高仅仅表示线程获取的 CPU时间片的几率高
// 但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。
Thread thread = Thread.currentThread();
System.out.println(thread.getPriority());// 5
```

## 线程操作

* 线程休眠
	- public static void sleep(long millis)
* 线程加入(等待某线程执行结束后才继续执行)
	- public final void join()

```java
ThreadJoin tj1 = new ThreadJoin();
ThreadJoin tj2 = new ThreadJoin();
ThreadJoin tj3 = new ThreadJoin();

tj1.setName("李渊");
tj2.setName("李世民");
tj3.setName("李元霸");

tj1.start();
try {
	tj1.join();//tj1执行结束后继续执行下面的start()语句
} catch (InterruptedException e) {
	e.printStackTrace();
}

tj2.start();
tj3.start();
```

* 线程礼让(暂停当前正在执行的线程对象，并执行其他线程，让多个线程的执行更和谐，但是不能靠它保证一人一次。)
	- public static void yield() 
* 后台线程(守护线程，主进程结束后守护进程也结束)
	- public final void setDaemon(boolean on)
* 中断线程
	- public final void stop() 强制中断
	- public void interrupt() 中断线程。 把线程的状态终止，并抛出一个InterruptedException。
* 获取线程名
```java
Thread myThread = Thread.currentThread();
String name = myThread.getName();//通过setName()方法设置线程名
System.out.println(name);//main
```

### sleep()和wait()的区别

* sleep() 必须指时间;不释放锁。
* wait() 可以不指定时间，也可以指定时间;释放锁。

### 线程生命周期

新建 -- 就绪 -- 运行 -- 死亡  
新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡

![线程生命周期](/static/img/线程/线程生命周期.png "线程生命周期")

## 线程安全问题

### 判断是否有问题

1. 是否是多线程环境
2. 是否有共享数据
3. 是否有多条语句操作共享数据

### 解决多线程安全问题

让程序没有安全问题的环境.把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

#### 同步代码块

> synchronized(对象){需要同步的代码;}

#### 同步方法

把同步关键字加到方法上  
这里的锁对象是this

##### 静态同步方法

这里的锁对象是当前类的字节码文件对象

#### 同步方法选择

如果锁对象是this，就可以考虑使用同步方法。  
否则能使用同步代码块的尽量使用同步代码块。

#### 同步弊端

* 当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。
* 如果出现了同步嵌套，就容易产生死锁问题

#### Jdk1.5 使用Lock锁

```java
// 定义票
private int tickets = 100;

// 定义锁对象
private Lock lock = new ReentrantLock();//ReentrantLock是Lock的实现类

@Override
public void run() {
    while (true) {
        try {
            // 加锁
            lock.lock();
            if (tickets > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()
                        + "正在出售第" + (tickets--) + "张票");
            }
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```

## 死锁

是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象

## 线程通信

### 唤醒机制

* wait():等待 
	- 将来醒过来的时候，是从wait()方法向下执行
* notify():唤醒单个线程 立即释放锁。
	- 唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。
* notifyAll():唤醒所有线程

### 线程的状态转换

![线程的状态转换](/static/img/线程/线程的状态转换.jpg "线程的状态转换")

**为什么wait(),notify(),notifyAll()等方法都定义在Object类中**

* 这些方法存在与同步中。
* 使用这些方法时必须要标识所属的同步的锁。
* 锁可以是任意对象，所以任意对象调用的方法一定定义Object类中。

## 线程组

Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。  
默认情况下，所有的线程都属于主线程组。

### 设置线程分组

> Thread(ThreadGroup group, Runnable target, String name)

```java
// ThreadGroup(String name)
ThreadGroup tg = new ThreadGroup("这是一个新的组");

MyRunnable my = new MyRunnable();
// Thread(ThreadGroup group, Runnable target, String name)
Thread t1 = new Thread(tg, my, "林青霞");
Thread t2 = new Thread(tg, my, "刘意");

System.out.println(t1.getThreadGroup().getName());
System.out.println(t2.getThreadGroup().getName());

//通过组名称设置后台线程，表示该组的线程都是后台线程
tg.setDaemon(true);

// 通过结果我们知道了：线程默认情况下属于main线程组
// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组
System.out.println(Thread.currentThread().getThreadGroup().getName());
```

## 线程池

程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。

* 线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
* 在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池
	
### Jdk1.5 Executors工厂类来产生线程池

* public static ExecutorService newCachedThreadPool() 创建一个具有缓存功能的线程池
* public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用的，具有固定线程数的线程池
* public static ExecutorService newSingleThreadExecutor() 创建一个只有单线程的线程池，相当于上个方法的参数是1

```java

//Callable:是带泛型的接口。
//这里指定的泛型其实是call()方法的返回值类型。
public class MyCallable implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
    	int sum = 0;
		for (int x = 0; x < 100; x++) {
			sum += x;
		}
		return sum;
	}

}

public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int x = 0; x < 100; x++) {
			System.out.println(Thread.currentThread().getName() + ":" + x);
		}
	}

}

// 创建一个线程池对象，控制要创建几个线程对象。
// public static ExecutorService newFixedThreadPool(int nThreads)
ExecutorService pool = Executors.newFixedThreadPool(2);

// 可以执行Runnable对象或者Callable对象代表的线程
pool.submit(new MyRunnable());
pool.submit(new MyRunnable());

Future<Integer> result = pool.submit(new MyCallable());

Integer i = result.get();

//结束线程池
pool.shutdown();
```

## 定时器

### Timer

```java
public class TimerDemo {
	public static void main(String[] args) {
		// 创建定时器对象
		Timer t = new Timer();
		// 3秒后执行爆炸任务第一次，如果不成功，每隔2秒再继续炸
		t.schedule(new MyTask(t), 3000, 2000);
	}
}

// 做一个任务
class MyTask extends TimerTask {

	private Timer t;
	
	public MyTask(){}
	
	public MyTask(Timer t){
		this.t = t;
	}
	
	@Override
	public void run() {
		System.out.println("beng,爆炸了");
		t.cancel();// 爆炸成功结束任务
	}

}
```

----------

*以上概念总结于传智播客Java基础课程*