---
layout: post  
title: 线程  
tags: Thread  
categories: Java  
published: true  
---  

[TOC]

## 操作系统的引入

之所以在计算机中加入操作系统来实现多个程序的同时执行，主要是基于以下原因：

* 资源利用率
	- 在某些情况下，程序必须等待某个外部操作执行完成，例如输入操作或输出操作等，而在等待时程序无法执行其他任何工作。因此，如果在等待的同时可以运行另一个程序，那么无疑将提高资源的利用率。
* 公平性
	- 不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行方式是通过粗粒度的时间分片（Time Slicing）使这些用户和程序能共享计算机资源，而不是由一个程序从头运行到尾，然后再启动下一个程序。
* 便利性
	- 通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。

## 线程

* 进程：
	- 正在运行的程序，是系统进行资源分配和调用的独立（基本）单位。
	- 每一个进程都有它自己的内存空间和系统资源。
* 线程：
	- 是进程中的单个顺序控制流，是一条执行路径，程序使用CPU的基本单位
	- 一个进程如果只有一条执行路径，则称为单线程程序。
	- 一个进程如果有多条执行路径，则称为多线程程序。

### 对于单核计算机来讲，游戏进程和音乐进程是同时运行吗

不是。

> 因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。  
> 多进程的作用不是提高执行速度，而是提高CPU的使用率。


### 多进程有什么意义

能在同一个`时间段`内执行多个任务。提高CPU的使用率。

### 多线程有什么意义

多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。(程序抢占CPU时间片几率更大)  
而多线程却给了我们一个错觉：让我们认为多个线程是并发执行的。其实不是。  
因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。

### 什么是并发

大家注意两个词汇的区别：*并行和并发*。

前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。  
后者是物理上同时发生，指在某一个时间点同时运行多个程序。  
那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。

### JVM虚拟机的启动是单线程的还是多线程的？

JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。

## 多线程的实现方案

### 继承Thread类

#### 步骤

 1. 自定义类MyThread继承Thread类。
 2. MyThread类里面重写run()
 3. 创建对象
 4. 启动线程

```java
public class MyThread extends Thread {
	@Override
	public void run() {
		System.out.println("thread running");
	}
}
```

#### 线程能不能多次启动

```java
// MyThread my = new MyThread();
// my.start();
// // IllegalThreadStateException:非法的线程状态异常
// // 为什么呢?因为这个相当于是my线程被调用了两次。而不是两个线程启动。
// my.start();

// 创建两个线程对象
MyThread my1 = new MyThread();
MyThread my2 = new MyThread();

my1.start();
my2.start();
```

### 实现Runnable接口

#### 步骤

 1. 自定义类MyRunnable实现Runnable接口
 2. 重写run()方法
 3. 创建MyRunnable类的对象
 4. 创建Thread类的对象，并把C步骤的对象作为构造参数传递

```java
public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int x = 0; x < 100; x++) {
			// 由于实现接口的方式就不能直接使用Thread类的方法了,但是可以间接的使用
			System.out.println(Thread.currentThread().getName() + ":" + x);
		}
	}

}


MyRunnable my = new MyRunnable();

// 创建Thread类的对象，并把C步骤的对象作为构造参数传递
// Thread(Runnable target)
// Thread t1 = new Thread(my);
// Thread t2 = new Thread(my);
// t1.setName("林青霞");
// t2.setName("刘意");

// Thread(Runnable target, String name)
Thread t1 = new Thread(my, "林青霞");
Thread t2 = new Thread(my, "刘意");

t1.start();
t2.start()
```

#### 如何获取和设置线程名称

通过Thread.currentThread()获取当前线程后获取或设置线程名

#### 实现接口方式的好处

* 可以避免由于Java单继承带来的局限性。
* 适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。

### 多线程两种方式比较及区别

![多线程两种方式的图解比较及区别](/static/img/线程/多线程两种方式的图解比较及区别.jpg "多线程两种方式的图解比较及区别")

查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run方法，如果Thread类的run方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run方法。

```java
// Thread.java
private Runnable target;
public void run() {
	if (target != null) {
	    target.run();
	}
}
```

**如果在Thread子类覆盖的run方法中编写了运行代码，也为Thread子类对象传递了一个Runnable对象，那么，线程运行时的执行代码是子类的run方法的代码？还是Runnable对象的run方法的代码？**

子类的

### 实现Callable接口或者Runable接口（和线程池结合）

* 好处：
	- 可以有返回值
	- 可以抛出异常
* 弊端：
	- 代码比较复杂，所以一般不用

## 线程调度

* 分时调度模型
	- 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
* 抢占式调度模型
	- 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 

> Java使用的是抢占式调度模型。

```java
// 设置getPriority()和获取setPriority()线程优先级 默认是5 范围是1-10
// 线程优先级高仅仅表示线程获取的 CPU时间片的几率高
// 但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。
Thread thread = Thread.currentThread();
System.out.println(thread.getPriority());// 5
```

## 线程操作

* 线程休眠
	- public static void sleep(long millis)
* 线程加入(等待某线程执行结束后才继续执行)
	- public final void join()

```java
ThreadJoin tj1 = new ThreadJoin();
ThreadJoin tj2 = new ThreadJoin();
ThreadJoin tj3 = new ThreadJoin();

tj1.setName("李渊");
tj2.setName("李世民");
tj3.setName("李元霸");

tj1.start();
try {
	tj1.join();//tj1执行结束后继续执行下面的start()语句
} catch (InterruptedException e) {
	e.printStackTrace();
}

tj2.start();
tj3.start();
```

* 线程礼让(暂停当前正在执行的线程对象，并执行其他线程，让多个线程的执行更和谐，但是不能靠它保证一人一次。)
	- public static void yield() 
* 后台线程(守护线程，主进程结束后守护进程也结束)
	- public final void setDaemon(boolean on)
* 中断线程
	- public final void stop() 强制中断
	- public void interrupt() 中断线程。 把线程的状态终止，并抛出一个InterruptedException。
* 获取线程名
```java
Thread myThread = Thread.currentThread();
String name = myThread.getName();//通过setName()方法设置线程名
System.out.println(name);//main
```

### sleep()和wait()的区别

* sleep() 必须指时间;不释放锁。
* wait() 可以不指定时间，也可以指定时间;释放锁。

### 线程生命周期

新建 -- 就绪 -- 运行 -- 死亡  
新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡

![线程生命周期](/static/img/线程/线程生命周期.jpg "线程生命周期")

## 线程安全性

### 安全性

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

* 在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
* 无状态对象一定是线程安全的。

### 原子性

#### 竞态条件

在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）。

最常见的竞态条件类型就是“先检查后|执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。

“先检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。

使用“先检查后执行”的一种常见情况就是延迟初始化。

#### 复合操作

复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。

在实际情况中，应尽可能地使用现有的线程安全对象（例如AcomicLong）来管理类的状态。
与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。

或者使用下面的加锁机制

#### 加锁机制

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

##### 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。

每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。  
线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。  
获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。  

##### 重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。

“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”

重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。

##### 用锁来保护状态

对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

* 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
* 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

### 活跃性与性能

通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。

当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。

## 对象共享

### 可见性

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

有一种简单的方法能避免这些复杂的问题：只要有数据在多个线程之间共享，就使用正确的同步。

#### 失效数据

由于内存可见性问题导致线程获取到数据是失效数据

仅对set方法进行同步是不够的，调用get的线程仍然会看见失效值。

#### 非原子的64位操作

非volatile类型的64位数值变量（double和long）。

Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。  
当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。  
因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。

参考虚拟机部分的，现代虚拟机对这部分的实现做了优化（处理器支持了64位数值的原子操作），所以可以保证操作原子性

#### 加锁与可见性

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

同步的可见性保证：

![Synchronized-visibility-guarantee](/static/img/线程/Synchronized-visibility-guarantee.png "Synchronized-visibility-guarantee")

#### Volatile变量

> volatile变量是一种比sychronized关键字更轻量级的同步机制。（在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些。）

并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。

仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。
如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。

*volatile变量的正确使用方式包括：*

确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）。

**加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。**

*当且仅当满足以下所有条件时，才应该使用volatile变量：*

* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
* 该变量不会与其他状态变量一起纳入不变性条件中。
* 在访问变量时不需要加锁。

*Tips：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式的JVM进行更多的优化，*

### 发布与逸出

“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用  
当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）

封装能够使得对程序的正确性进行分析变得可可能，并使得无意中破坏设计约束条件变得更难。

* 不要在构造过程中使this引用逸出。this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。
* 在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。
* 在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。

```java
public class ThisEscape {
	public ThisEscape(EventSource source) {
	    source.registerListener(new EventListener() {
	        public void onEvent(Event e) {
	        	// unsafe this escape
	            doSomething(e);
	        }
	    });
	}
	void doSomething(Event e) {}
	interface EventSource {
	    void registerListener(EventListener e);
	}
	interface EventListener {
	    void onEvent(Event e);
	}
	interface Event {}
}
```

使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程

```java
public class SafeListener {
    private final EventListener listener;
    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }
    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
    void doSomething(Event e) {}
    interface EventSource {
        void registerListener(EventListener e);
    }
    interface EventListener {
        void onEvent(Event e);
    }
    interface Event {}
}
```

### 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。
这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。

#### Ad-hoc线程封闭

Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。

Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象的引用通常保存在公有变量中。

当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。
在某些情况下，单线程子系统提供的简便性要胜过Ad-hoc线程封闭技术的脆弱性。  

在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。
在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。

由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。

#### 栈封闭

栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。

正如封装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。
局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。
栈封闭（也被称为线程内部使用或者线程局部使用）比Ad-hoc线程封闭更易于维护，也更加健壮。

```java
public int loadTheArk(Collection<Animal> candidates) {
    SortedSet<Animal> animals;
    int numPairs = 0;
    Animal candidate = null;
    // 只有一个引用指向集合animals，这个引用被封闭在局部变量中，因此也被封闭在执行线程中
    animals = new TreeSet<Animal>(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for (Animal a : animals) {
        if (candidate == null || !candidate.isPotentialMate(a))
            candidate = a;
        else {
            ark.load(new AnimalPair(candidate, a));
            ++numPairs;
            candidate = null;
        }
    }
    return numPairs;
}
```

#### ThreadLocal类

维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来

ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享，这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。

ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。

### 不可变性

满足同步需求的另一种方法是使用不可变对象（Immutable Object）

当满足以下条件时，对象才是不可变的：

* 对象创建以后其状态就不能修改
* 对象的所有域都是final类型（引用的对象也要保证不逸出）
* 对象是正确创建的（在对象的创建期间，this引用没有逸出）

#### final域

final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。
然而，在Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

即使对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。仅包含一个或两个可变状态的“基本不可变”对象仍然比包含多个可变状态的对象简单。通过将域声明为final类型，也相当于告诉维护人员这些域是不会变化的。

> 正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。

使用Volatile类型来发布不可变对象:

```java
public class OneValueCache {
    private final BigInteger lastNumber;
    private final BigInteger[] lastFactors;
    public OneValueCache(BigInteger i, BigInteger[] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length);
    }
    public BigInteger[] getFactors(BigInteger i) {
        if (lastNumber == null || !lastNumber.equals(i)) {
            return null;
        } else {
            return Arrays.copyOf(lastFactors, lastFactors.length);
        }
    }
}
```

```java
public class VolatileCachedFactorizer extends GenericServlet implements Servlet {
    private volatile OneValueCache cache = new OneValueCache(null, null);
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeIntoResponse(resp, factors);
    }
    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {}
    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }
    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}
```

### 安全发布

#### 不可变对象与初始化安全性

> 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。

这种保证还将延伸到被正确创建对象中所有final类型的域。在没有额外同步的情况下，也可以安全地访问final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。

#### 安全发布的常用模式

可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

* 在静态初始化函数中初始化一个对象引用
* 将对象的引用保存到volatile类型的域或者AtomicReferance对象中
* 将对象的引用保存到某个正确构造对象的final类型域中
* 将对象的引用保存到一个由锁保护的域中

* 线程安全库中的容器类提供了以下的安全发布保证：
	- 通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。
	- 通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。
	- 通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。
* 类库中的其他数据传递机制（例如Future和Exchanger）同样能实现安全发布，在介绍这些机制时将讨论它们的安全发布功能。
* 静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布

#### 事实不可变对象

如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”。

> 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

#### 可变对象

对象的发布需求取决于它的可变性：

* 不可变对象可以通过任意机制来发布。
* 事实不可变对象必须通过安全方式来发布。
* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

#### 安全地共享对象

在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：

* 线程封闭
	- 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
* 只读共享
	- 在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
* 线程安全共享
	- 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
* 保护对象
	- 被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## 对象的组合

### 设计线程安全的类

通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。

在设计线程安全类的过程中，需要包含以下三个基本要素：

* 找出构成对象状态的所有变量
* 找出约束状态变量的不变性条件
* 建立对象状态的并发访问管理策略

同步策略（Synchronization Policy）定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。
同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。
要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。

#### 收集同步需求

这些相关的变量必须在单个原子操作中进行读取或更新。不能首先更新一个变量，然后释放锁并再次获得锁，然后再更新其他的变量。
因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。

> 如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。

#### 依赖状态的操作

* 在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。
* 但在并发程序中，先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作。

在Java中，等待某个条件为真的各种内置机制（包括等待和通知等机制）都与内置加锁机制紧密关联，要想正确地使用它们并不容易。
要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类（例如阻塞队列[Blocking Queue]或信号量[Semaphore]）来实现依赖状态的行为。

#### 状态的所有权

许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。然而，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是“共享控制权”。对于从构造函数或者从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权（例如，同步容器封装器的工厂方法）。

### 实例封闭

> 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

在Java平台的类库中还有很多线程封闭的示例，其中有些类的唯一用途就是将非线程安全的类转化为线程安全的类。  
一些基本的容器类并非线程安全的，例如ArrayList和HashMap，但类库提供了包装器工厂方法（例如Collections.synchronizedList及其类似方法），使得这些非线程安全的类可以在多线程环境中安全地使用。
这些工厂方法通过“装饰器（Decorator）”模式（Gamma et al.，1995）将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。
只要包装器对象拥有对底层容器对象的唯一引用（即把底层容器对象封闭在包装器中），那么它就是线程安全的。在这些方法的Javadoc中指出，对底层容器对象的所有访问必须通过包装器来进行。

> 封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。

#### Java监视器模式

从线程封闭原则及其逻辑推论可以得出Java监视器模式。遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。

在许多类中都使用了Java监视器模式，例如Vector和Hashtable。Java监视器模式的主要优势就在于它的简单性。

```java
@ThreadSafe
public class MonitorVehicleTracker {
    @GuardedBy("this") private final Map<String, MutablePoint> locations;
    public MonitorVehicleTracker(Map<String, MutablePoint> locations) {
        this.locations = deepCopy(locations);
    }
    public synchronized Map<String, MutablePoint> getLocations() {
    	// 占用锁时间长，效率低的做法
        return deepCopy(locations);
    }
    public synchronized MutablePoint getLocation(String id) {
        MutablePoint loc = locations.get(id);
        return loc == null ? null : new MutablePoint(loc);
    }
    public synchronized void setLocation(String id, int x, int y) {
        MutablePoint loc = locations.get(id);
        if (loc == null)
            throw new IllegalArgumentException("No such ID: " + id);
        loc.x = x;
        loc.y = y;
    }
    private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
        Map<String, MutablePoint> result = new HashMap<String, MutablePoint>();
        for (String id : m.keySet()) {
            result.put(id, new MutablePoint(m.get(id)));
        }
        return Collections.unmodifiableMap(result);
    }
}

@NotThreadSafe
public class MutablePoint {
    public int x, y;
    public MutablePoint() {
        x = 0;
        y = 0;
    }
    public MutablePoint(MutablePoint p) {
        this.x = p.x;
        this.y = p.y;
    }
}
```

### 线程安全性的委托

大多数对象都是组合对象。当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java监视器模式是非常有用的。  
但是，如果类中的各个组件都已经是线程安全的，是否需要再增加一个额外的线程安全层？答案是“视情况而定”。

```java
// 将线程安全委托给ConcurrentHashMap

@ThreadSafe
public class DelegatingVehicleTracker {
    private final ConcurrentMap<String, Point> locations;
    private final Map<String, Point> unmodifiableMap;
    public DelegatingVehicleTracker(Map<String, Point> points) {
        locations = new ConcurrentHashMap<String, Point>(points);
        unmodifiableMap = Collections.unmodifiableMap(locations);
    }
    public Map<String, Point> getLocations() {
        return unmodifiableMap;
    }
    public Point getLocation(String id) {
        return locations.get(id);
    }
    public void setLocation(String id, int x, int y) {
        if (locations.replace(id, new Point(x, y)) == null){
            throw new IllegalArgumentException("invalid vehicle name: " + id);
        }
    }
    public Map<String, Point> getLocationsAsStatic() {
        return Collections.unmodifiableMap(
                new HashMap<String, Point>(locations));
    }
}
// 使用不可修改的Point对象防止封装性被破坏
@Immutable
public class Point {
    public final int x, y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
// 如果需要返回一个不发生变化的车辆视图，可以返回一个浅拷贝
public Map<String, Point> getLocations() {
    return Collections.unmodifiableMap(new HashMap<String,Point>(locations));
}
```

#### 独立的状态变量

还可以将线程安全性委托给多个状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。

```java
// CopyOnWriteArrayList来保存各个监听器列表。它是一个线程安全的链表，特别适用于管理监听器列表。
// 每个链表都是线程安全的，此外，由于各个状态之间不存在耦合关系，因此VisualComponent可以将它的线程安全性委托给mouseListeners和keyListeners等对象。
public class VisualComponent {
    private final List<KeyListener> keyListeners = new CopyOnWriteArrayList<KeyListener>();
    private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<MouseListener>();
    public void addKeyListener(KeyListener listener) {
        keyListeners.add(listener);
    }
    public void addMouseListener(MouseListener listener) {
        mouseListeners.add(listener);
    }
    public void removeKeyListener(KeyListener listener) {
        keyListeners.remove(listener);
    }
    public void removeMouseListener(MouseListener listener) {
        mouseListeners.remove(listener);
    }
}
```

#### 委托失效

如果某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。

> 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。

#### 发布底层的状态变量

> 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

```java
@ThreadSafe
public class SafePoint {
    @GuardedBy("this")
    private int x, y;
    // 这是私有构造函数捕获模式（Private Constructor Capture Idiom）的一个实例。
    private SafePoint(int[] a) {
        this(a[0], a[1]);
    }
    // 如果将拷贝构造函数实现为this（p.x, p.y），那么会产生竞态条件，而私有构造函数则可以避免这种竞态条件。
    public SafePoint(SafePoint p) {
        this(p.get());
    }
    // get方法同时获得x和y的值，并将二者放在一个数组中返回
    // 如果为x和y分别提供get方法，那么在获得这两个不同坐标的操作之间，x和y的值发生变化，从而导致调用者看到不一致的值
    public SafePoint(int x, int y) {
        this.set(x, y);
    }
    public synchronized int[] get() {
        return new int[]{x, y};
    }
    public synchronized void set(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

// 将其线程安全性委托给底层的ConcurrentHashMap，只是Map中的元素是线程安全的且可变的Point，而并非不可变的。
@ThreadSafe
public class PublishingVehicleTracker {
    private final Map<String, SafePoint> locations;
    private final Map<String, SafePoint> unmodifiableMap;
    public PublishingVehicleTracker(Map<String, SafePoint> locations) {
        this.locations = new ConcurrentHashMap<String, SafePoint>(locations);
        this.unmodifiableMap = Collections.unmodifiableMap(this.locations);
    }
    // getLocation方法返回底层Map对象的一个不可变副本
    // 调用者不能增加或删除车辆，但却可以通过修改返回Map中的SafePoint值来改变车辆的位置
    public Map<String, SafePoint> getLocations() {
        return unmodifiableMap;
    }
    public SafePoint getLocation(String id) {
        return locations.get(id);
    }
    public void setLocation(String id, int x, int y) {
        if (!locations.containsKey(id))
            throw new IllegalArgumentException("invalid vehicle name: " + id);
        locations.get(id).set(x, y);
    }
}
```

### 在现有的线程安全类中添加功能

#### 添加代码或者扩展类

* 要添加一个新的原子操作，最安全的方法是修改原始的类，但这通常无法做到，因为你可能无法访问或修改类的源代码。
	- 要想修改原始的类，就需要理解代码中的同步策略，这样增加的功能才能与原有的设计保持一致。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源代码文件中，从而更容易理解与维护。
* 另一种方法是扩展这个类，假定在设计这个类时考虑了可扩展性。
	- “扩展”方法比直接将代码添加到类中更加脆弱，因为现在的同步策略实现被分布到多个单独维护的源代码文件中。
	- 如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。

在Vector的规范中定义了它的同步策略，因此BetterVector遵循这个规范就不存在被破坏问题。

```java
@ThreadSafe
public class BetterVector <E> extends Vector<E> {
    static final long serialVersionUID = -3963416950630760754L;
    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !contains(x);
        if (absent) {
            add(x);
        }
        return absent;
    }
}
```

#### 客户端加锁机制

对于由Collections.synchronizedList封装的ArrayList，这两种方法在原始类中添加一个方法或者对类进行扩展都行不通，
因为客户代码并不知道在同步封装器工厂方法中返回的List对象的类型。  
第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展代码放入一个“辅助类”中。

要想使这个方法能正确执行，必须使实现客户端加锁或外部加锁时使用同一个锁。客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户代码。要使用客户端加锁，你必须知道对象X使用的是哪一个锁。

```java
@ThreadSafe
class GoodListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    public boolean putIfAbsent(E x) {
    	// 使用内部锁对应的this对象，而不是在方法上使用synchronized而使用不同的锁对象
        synchronized (list) {
            boolean absent = !list.contains(x);
            if (absent) {
                list.add(x);
            }
            return absent;
        }
    }
}
```

* 通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。
* 然而，客户端加锁却更加脆弱，因为它将类C的加锁代码放到与C完全无关的其他类中。当在那些并不承诺遵循加锁策略的类上使用客户端加锁时，要特别小心。

客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起。正如扩展会破坏实现的封装性，客户端加锁同样会破坏同步策略的封装性。

#### 组合

当为现有的类添加一个原子操作时，有一种更好的方法：组合（Composition）。ImprovedList通过自身的内置锁增加了一层额外的加锁。

它并不关心底层的List是否是线程安全的，即使List不是线程安全的或者修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。虽然额外的同步层可能导致轻微的性能损失（性能损失很小，因为在底层List上的同步不存在竞争，所以速度很快），但与模拟另一个对象的加锁策略相比，ImprovedList更为健壮。  
事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。

```java
public class ImprovedList<T> implements List<T> {
    private final List<T> list;
    // PRE: list argument is thread-safe.
    public ImprovedList(List<T> list) {
        this.list = list;
    }
    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (contains) {
            list.add(x);
        }
        return !contains;
    }
    //……按照类似的方式委托List的其他方法
}
```

### 将同步策略文档化

> 在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

synchronized、volatile或者任何一个线程安全类都对应于某种同步策略，用于在并发访问时确保数据的完整性。
这种策略是程序设计的要素之一，因此应该将其文档化。当然，设计阶段是编写设计决策文档的最佳时间。

在设计同步策略时需要考虑多个方面：

* 将哪些变量声明为volatile类型
* 哪些变量用锁来保护
* 哪些锁保护哪些变量
* 哪些变量必须是不可变的或者被封闭在线程中的
* 哪些操作必须是原子操作等。

其中某些方面是严格的实现细节，应该将它们文档化以便于日后的维护。还有一些方面会影响类中加锁行为的外在表现，也应该将其作为规范的一部分写入文档。

最起码，应该保证将类中的线程安全性文档化。

* 它是否是线程安全的
* 在执行回调时是否持有一个锁
* 是否有某些特定的锁会影响其行为

不要让客户冒着风险去猜测。如果你不想支持客户端加锁也是可以的，但一定要明确地指出来。

## 基础构建模块

### 同步容器类

* 同步容器类包括Vector和Hashtable，二者是早期JDK的一部分
* 此外还包括在JDK l.2中添加的一些功能相似的类，这些同步的封装器类是由Collections.synchronizedXxx等工厂方法创建的
	- 这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态

#### 同步容器类的问题

```java
// 在使用客户端加锁的Vector上的复合操作，使用同一个锁对象
public static Object getLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}
```

```java
// 带有客户端加锁的迭代
// 这同样会导致其他线程在迭代期间无法访问它，因此降低了并发性。
synchronized (list) {
    for (int i = 0; i < list.size(); i++) {
        doSomething(list.get(i));
    }
}
```

#### 迭代器与ConcurrentModificationException

如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException（在单线程代码中也可能抛出ConcurrentModificationException异常。当对象直接从容器中删除而不是通过Iterator.remove来删除时，就会抛出这个异常）。  
然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的计数值，而迭代器可能并没有意识到已经发生了修改。
这是一种设计上的权衡，从而降低并发修改操作的检测代码对程序性能带来的影响。

要想避免出现ConcurrentModificationException，就必须在迭代过程持有容器的锁。

如果容器的规模很大，或者在每个元素上执行操作的时间很长，那么这些线程将长时间等待。
即使不存在饥饿或者死锁等风险，长时间地对容器加锁也会降低程序的可伸缩性。持有锁的时间越长，那么在锁上的竞争就可能越激烈，如果许多线程都在等待锁被释放，那么将极大地降低吞吐量和CPU的利用率

如果不希望在迭代期间对容器加锁，那么一种替代方法就是“克隆”容器，并在副本上进行迭代。
由于副本被封闭在线程内，因此其他线程不会在选代期间对其进行修改，这样就避免了抛出ConcurrentModificationException（在克隆过程中仍然需要对容器加锁）。
在克隆容器时存在显著的性能开销。这种方式的好坏取决于多个因素，包括容器的大小，在每个元素上执行的工作，迭代操作相对于容器其他操作的调用频率，以及在响应时间和吞吐量等方面的需求。

#### 隐藏迭代器

所有这些间接的迭代操作都可能抛出ConcurrentModificationException：

* 容器的toString、hashCode和equals等方法会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。
* 同样，containsAll、removeAll和retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。

> 正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。

```java
public class HiddenIterator {
    @GuardedBy("this")
    private final Set<Integer> set = new HashSet<Integer>();
    public synchronized void add(Integer i) {
        set.add(i);
    }
    public synchronized void remove(Integer i) {
        set.remove(i);
    }
    public void addTenThings() {
        Random r = new Random();
        for (int i = 0; i < 10; i++) {
            add(r.nextInt());
        }
        // 这里必须使用同步synchronized(this)，因为会toString会调用Iterator
        System.out.println("DEBUG: added ten elements to " + set);
    }
}
```

### 并发容器

> 通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。

同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低。

Java 5.0提供了多种并发容器类来改进同步容器的性能。

并发容器是针对多个线程并发访问设计的。
在Java 5.0中增加了ConcurrentHashMap，用来替代同步且基于散列的Map，以及CopyOnWriteArrayList，用于在遍历操作为主要操作的情况下代替同步的List。
在新的ConcurrentMap接口中增加了对一些常见复合操作的支持，例如“若没有则添加”、替换以及有条件删除等。

Java 5. 0增加了两种新的容器类型：Queue和BlockingQueue。

Queue用来临时保存一组等待处理的元素。

它提供了几种实现，包括：ConcurrentLinkedQueue，这是一个传统的先进先出队列，以及PriorityQueue，这是一个（非并发的）优先队列。
Queue上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。虽然可以用List来模拟Queue的行为——事实上，正是通过LinkedList来实现Queue的，但还需要一个Queue的类，因为它能去掉List的随机访问需求，从而实现更高效的并发。

BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。
如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。
如果队列已满（对于有界队列来说），那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。在“生产者-消费者”这种设计模式中，阻塞队列是非常有用的。

正如ConcurrentHashMap用于代替基于散列的同步Map, Java 6也引入了Concurrent-SkipListMap和ConcurrentSkipListSet，分别作为同步的SortedMap和SortedSet的并发替代品（例如用synchronizedMap包装的TreeMap或TreeSet）。

#### ConcurrentHashMap

同步容器类在执行每个操作期间都持有一个锁。

与HashMap一样，ConcurrentHashMap也是一个基于散列的Map，但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。  
ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁（Lock Striping）。  
在这种机制中，任意数量的读取线程可以并发地访问Map，执行读取操作的线程和执行写入操作的线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map。
ConcurrentHashMap带来的结果是，在并发访问环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。

ConcurrentHashMap与其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。  
ConcurrentHashMap返回的迭代器具有弱一致性（Weakly Consistent），而并非“及时失败”。
弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反映给容器。

尽管有这些改进，但仍然有一些需要权衡的因素。对于一些需要在整个Map上进行计算的方法，例如size和isEmpty，这些方法的语义被略微减弱了以反映容器的并发特性。  
由于size返回的结果在计算时可能已经过期了，它实际上只是一个估计值，因此允许size返回一个近似值而不是一个精确值。
虽然这看上去有些令人不安，但事实上size和isEmpty这样的方法在并发环境下的用处很小，因为它们的返回值总在不断变化。
因此，这些操作的需求被弱化了，以换取对其他更重要操作的性能优化，包括get、put、containsKey和remove等。

* 在ConcurrentHashMap中没有实现对Map加锁以提供独占访问。
* 在Hashtable和synchronizedMap中，获得Map的锁能防止其他线程访问这个Map。

在一些不常见的情况中需要这种功能，例如通过原子方式添加一些映射，或者对Map迭代若干次并在此期间保持元素顺序相同。然而，总体来说这种权衡还是合理的，因为并发容器的内容会持续变化。

与Hashtable和synchronizedMap相比，ConcurrentHashMap有着更多的优势以及更少的劣势，因此在大多数情况下，用ConcurrentHashMap来代替同步Map能进一步提高代码的可伸缩性。  
只有当应用程序需要加锁Map以进行独占访问(或者需要依赖于同步Map带来的一些其他作用)时，才应该放弃使用ConcurrentHashMap。

#### 额外的原子Map操作

由于ConcurrentHashMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作，
但是，一些常见的复合操作都已经实现为原子操作并且在ConcurrentMap的接口中声明

```java
public interface ConcurrentMap＜K, V＞extends Map＜K, V＞{
	//仅当K没有相应的映射值时才插入
	V putIfAbsent（K key, V value）；
	//仅当K被映射到V时才移除
	boolean remove（K key, V value）；
	//仅当K被映射到oldValue时才替换为newValue
	boolean replace（K key, V oldValue, V newValue）；
	//仅当K被映射到某个值时才替换为newValue
	V replace（K key, V newValue）；
}
```

#### CopyOnWriteArrayList

CopyOnWriteArrayList用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。（类似地，CopyOnWriteArraySet的作用是替代同步Set。）

“写入时复制（Copy-On-Write）”容器的线程安全性在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。  
“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。
因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰。    
“写入时复制”容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作所带来的影响。

显然，每当修改容器时都会复制底层数组，这需要一定的开销，特别是当容器的规模较大时。仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。  
这个准则很好地描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每一个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接收事件通知的操作。

### 阻塞队列和生产者-消费者模式

在类库中包含了BlockingQueue的多种实现：

* 其中，LinkedBlockingQueue和ArrayBlocking-Queue是FIFO队列
	- 二者分别与LinkedList和ArrayList类似，但比同步List拥有更好的并发性能。  
* PriorityBlockingQueue是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列将非常有用。
	- 正如其他有序的容器一样，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素（如果它们实现了Comparable方法），也可以使用Comparator来比较。
* 最后一个BlockingQueue实现是SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。
	- 因为SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。

阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。  
如果队列已经满了，那么put方法将阻塞直到有空间可用；
如果队列为空，那么take方法将会阻塞直到有元素可用。  
队列可以是有界的也可以是无界的，无界队列永远都不会充满，因此无界队列上的put方法也永远不会阻塞。  

生产者-消费者模式能简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性，
此外，该模式还将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。

BlockingQueue简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。
一种最常见的生产者-消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中就体现了这种模式

阻塞队列同样提供了一个offer方法，如果数据项不能被添加到队列中，那么将返回一个失败状态。这样你就能够创建更多灵活的策略来处理负荷过载的情况，
例如减轻负载，将多余的工作项序列化并写入磁盘，减少生产者线程的数量，或者通过某种方式来抑制生产者线程。

> 在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。

开发人员总会假设消费者处理工作的速率能赶上生产者生成工作项的速率，因此通常不会为工作队列的大小设置边界，但这将导致在之后需要重新设计系统架构。
因此，应该尽早地通过阻塞队列在设计中构建资源管理机制—这件事情做得越早，就越容易。  
在许多情况下，阻塞队列能使这项工作更加简单，如果阻塞队列并不完全符合设计需求，那么还可以通过信号量（Semaphore）来创建其他的阻塞数据结构。

生产者-消费者模式同样能带来许多性能优势。生产者和消费者可以并发地执行。如果一个是I/O密集型，另一个是CPU密集型，那么并发执行的吞吐率要高于串行执行的吞吐率。

```java
public class IndexingService {
    private static final int CAPACITY = 1000;
    private static final File POISON = new File("");
    private final IndexerThread consumer = new IndexerThread();
    private final CrawlerThread producer = new CrawlerThread();
    private final BlockingQueue<File> queue;
    private final FileFilter fileFilter;
    private final File root;
    public IndexingService(File root, final FileFilter fileFilter) {
        this.root = root;
        this.queue = new LinkedBlockingQueue<File>(CAPACITY);
        this.fileFilter = new FileFilter() {
            public boolean accept(File f) {
                return f.isDirectory() || fileFilter.accept(f);
            }
        };
    }
    private boolean alreadyIndexed(File f) {
        return false;
    }
    class CrawlerThread extends Thread {
        @Override
        public void run() {
            try {
                crawl(root);
            } catch (InterruptedException e) { /* fall through */
            } finally {
                while (true) {
                    try {
                        queue.put(POISON);
                        break;
                    } catch (InterruptedException e1) { /* retry */
                    }
                }
            }
        }
        private void crawl(File root) throws InterruptedException {
            File[] entries = root.listFiles(fileFilter);
            if (entries != null) {
                for (File entry : entries) {
                    if (entry.isDirectory()) {
                        crawl(entry);
                    } else if (!alreadyIndexed(entry)) {
                        queue.put(entry);
                    }
                }
            }
        }
    }
    class IndexerThread extends Thread {
        @Override
        public void run() {
            try {
                while (true) {
                    File file = queue.take();
                    if (file == POISON) {
                        break;
                    } else {
                        indexFile(file);
                    }
                }
            } catch (InterruptedException ignored) {
            }
        }
        public void indexFile(File file) {
            /*...*/
        }
    }
    public void start() {
        producer.start();
        consumer.start();
    }
    public void stop() {
        producer.interrupt();
    }
    public void awaitTermination() throws InterruptedException {
        consumer.join();
    }
}
```

#### 串行线程封闭


对于可变对象，生产者-消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者。
线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来“转移”所有权。  
在转移所有权后，也只有另一个线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。
这种安全的发布确保了对象状态对于新的所有者来说是可见的，并且由于最初的所有者不会再访问它，因此对象将被封闭在新的线程中。
新的所有者线程可以对该对象做任意修改，因为它具有独占的访问权。

对象池利用了串行线程封闭，将对象“借给”一个请求线程。只要对象池包含足够的内部同步来安全地发布池中的对象，并且只要客户代码本身不会发布池中的对象，或者在将对象返回给对象池后就不再使用它，那么就可以安全地在线程之间传递所有权。

我们也可以使用其他发布机制来传递可变对象的所有权，但必须确保只有一个线程能接受被转移的对象。阻塞队列简化了这项工作。
除此之外，还可以通过ConcurrentMap的原子方法remove或者AtomicReference的原子方法compareAndSet来完成这项工作。

#### 双端队列与工作密取

Java 6增加了两种容器类型，Deque（发音为“deck”）和BlockingDeque，它们分别对Queue和BlockingQueue进行了扩展。
Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。

正如阻塞队列适用于生产者-消费者模式，双端队列同样适用于另一种相关模式，即工作密取（Work Stealing）。

* 在生产者-消费者设计中，所有消费者有一个共享的工作队列
* 而在工作密取设计中，每个消费者都有各自的双端队列。

如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。
密取工作模式比传统的生产者-消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。
在大多数时候，它们都只是访问自己的双端队列，从而极大地减少了竞争。
当工作者线程需要访问另一个队列时，它会从队列的尾部而不是从头部获取工作，因此进一步降低了队列上的竞争程度。

工作密取非常适用于既是消费者也是生产者问题——当执行某个工作时可能导致出现更多的工作。  
当一个工作线程找到新的任务单元时，它会将其放到自己队列的末尾（或者在工作共享设计模式中，放入其他工作者线程的队列中）。当双端队列为空时，它会在另一个线程的队列队尾查找新的任务，从而确保每个线程都保持忙碌状态。  
例如，在网页爬虫程序中处理一个页面时，通常会发现有更多的页面需要处理。类似的还有许多搜索图的算法，例如在垃圾回收阶段对堆进行标记，都可以通过工作密取机制来实现高效并行。

### 阻塞方法与中断方法

线程可能会阻塞或暂停执行，原因有多种：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep方法中醒来，或是等待另一个线程的计算结果。  
当线程阻塞时，它通常被挂起，并处于某种阻塞状态（BLOCKED、WAITING或TIMED_WAITING）。  
当某个外部事件发生时，线程被置回RUNNABLE状态，并可以再次被调度执行。

中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。
当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作—前提是如果线程B愿意停止下来。  
虽然在API或者语言规范中并没有为中断定义任何特定应用级别的语义，但最常使用中断的情况就是取消某个操作。
方法对中断请求的响应度越高，就越容易及时取消那些执行时间很长的操作。

当在代码中调用了一个将抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。对于库代码来说，有两种基本选择：

* 传递InterruptedException
	- 避开这个异常通常是最明智的策略——只需把InterruptedException传递给方法的调用者。传递InterruptedException的方法包括，根本不捕获该异常，或者捕获该异常，然后在执行某种简单的清理工作后再次抛出这个异常。
* 恢复中断
	- 有时候不能抛出InterruptedException，例如当代码是Runnable的一部分时。在这些情况下，必须捕获InterruptedException，并通过调用当前线程上的interrupt方法恢复中断状态，这样在调用栈中更高层的代码将看到引发了一个中断

```java
public class TaskRunnable implements Runnable {
    BlockingQueue<Task> queue;
    public void run() {
        try {
            processTask(queue.take());
        } catch (InterruptedException e) {
            // restore interrupted status
            Thread.currentThread().interrupt();
        }
    }
    void processTask(Task task) {
        // Handle the task
    }
    interface Task {
    }
}
```

还可以采用一些更复杂的中断处理方法，但上述两种方法已经可以应付大多数情况了。
然而在出现InterruptedException时不应该做的事情是，捕获它但不做出任何响应。
这将使调用栈上更高层的代码无法对中断采取处理措施，因为线程被中断的证据已经丢失。
只有在一种特殊的情况中才能屏蔽中断，即对Thread进行扩展，并且能控制调用栈上所有更高层的代码。

### 同步工具类

所有的同步工具类都包含一些特定的结构化属性：

它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。

#### 闭锁和CountDownLatch

闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。

闭锁可以用来确保某些活动直到其他活动都完成后才继续执行，如：

* 确保某个计算在其需要的所有资源都被初始化之后才继续执行
* 确保某个服务在其依赖的所有其他服务都已经启动之后才启动
* 等待直到某个操作的所有参与者都就绪再继续执行

CountDownLatch是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。

```java
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {
                    }
                }
            };
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

#### FutureTask

FutureTask也可以做闭锁，它实现了Future语义，表示一种抽象的可生成结果的计算。

FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：等待运行（Waiting to run)、正在运行（Running）和运行完成（Completed）。  
“执行完成”表示计算的所有可能结束方式，包括正常结束、由于取消而结束和由于异常而结束等。当FutureTask进入完成状态后，它会停止在这个状态上。

Future.get的行为取决于任务的状态，如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。  
FutureTask将计算结果从执行计算的线程到获取这个结果的线程，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。

FutureTask在Executor框架中表示异步任务，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。

```java
// 提前加载稍后要使用的数据
public class Preloader {
    ProductInfo loadProductInfo() throws DataLoadException {
        return null;
    }
    private final FutureTask<ProductInfo> future =
            new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
                public ProductInfo call() throws DataLoadException {
                    return loadProductInfo();
                }
            });
    private final Thread thread = new Thread(future);
    public void start() {
        thread.start();
    }
    public ProductInfo get() throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException) {
                throw (DataLoadException) cause;
            } else {
                throw LaunderThrowable.launderThrowable(cause);
            }
        }
    }
    interface ProductInfo {}
}
class DataLoadException extends Exception {}
```

Callable表示的任务可以抛出受检查的或未受检查的异常，并且任何代码都可能抛出一个Error。无论任务代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get中被重新抛出。  
这将使调用get的代码变得复杂，因为它不仅需要处理可能出现的ExecutionException（以及未检查的CancellationException），而且还由于ExecutionException是作为一个Throwable类返回的，因此处理起来并不容易。

```java
public class LaunderThrowable {
    public static RuntimeException launderThrowable(Throwable t) {
        if (t instanceof RuntimeException) {
        	// 直接抛出给调用者
            return (RuntimeException) t;
        } else if (t instanceof Error) {
        	// 如果是错误直接抛出错误
            throw (Error) t;
        } else {
        	// 非RuntimeException表示这是一个逻辑错误
            throw new IllegalStateException("Not unchecked", t);
        }
    }
}
```

#### 信号量

计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。

Semaphore中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放即可。
如果没有许可，那么aquire将阻塞直到有许可（或者直到被中断或者操作超时）。release方法将返回一个许可给信号量。
（在这种实现中不包含真正的许可对象，并且Semaphore也不会将许可与线程关联起来，因此在一个线程中获得的许可可以在另一个线程中释放。可以将acquire操作视为是消费一个许可，而release操作是创建一个许可，Semaphore并不受限于它在创建时的初始许可数量。）  

计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore。二值信号量可以用作互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。

```java
// 设置容器边界
public class BoundedHashSet<T> {
    private final Set<T> set;
    private final Semaphore sem;
    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }
    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        } finally {
            if (!wasAdded) {
                sem.release();
            }
        }
    }
    public boolean remove(Object o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved) {
            sem.release();
        }
        return wasRemoved;
    }
}
```

#### 栅栏CyclicBarrier和Exchanger

栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。

栅栏与闭锁的关键区别在于：

所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。

CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用：

这种算法通常将一个问题拆分成为一系列相互独立的自问题。

* 当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有的线程到达栅栏位置。
* 如果所有的线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都被释放，而栅栏将被重置一遍下次使用。
* 如果对await方法的调用超时，或者await阻塞的线程被中断，那么栅栏就认为是被打破了，所有阻塞的await都将终止并且抛出BorkenBarrierException。
* 如果成功的通过栅栏，那么await将会为每个线程都返回一个唯一的索引号，我们可以利用这些索引来“选举”产生一个“领导线程”,并在下一次迭代中由该领导线程执行一些特殊的工作。

CycleBarrier还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，当成功通过栅栏会（在一个子任务线程中）执行它，但在阻塞线程被释放之前是不能执行的。

```java
// 通过CyclicBarrier协调细胞自动衍生系统中的计算
// 将问题分解成一定数量的子问题，为每个子问题分配一个线程来求解，之后再将所有的结果合并起来
public class CellularAutomata {
    private final Board mainBoard;
    private final CyclicBarrier barrier;
    private final Worker[] workers;
    public CellularAutomata(Board board) {
        this.mainBoard = board;
        int count = Runtime.getRuntime().availableProcessors();
        this.barrier = new CyclicBarrier(count,
                new Runnable() {
                    public void run() {
                        mainBoard.commitNewValues();
                    }
                });
        this.workers = new Worker[count];
        for (int i = 0; i < count; i++) {
            workers[i] = new Worker(mainBoard.getSubBoard(count, i));
        }
    }
    private class Worker implements Runnable {
        private final Board board;
        public Worker(Board board) {
            this.board = board;
        }
        public void run() {
            while (!board.hasConverged()) {
                for (int x = 0; x < board.getMaxX(); x++) {
                    for (int y = 0; y < board.getMaxY(); y++) {
                        board.setNewValue(x, y, computeValue(x, y));
                    }
                }
                try {
                    barrier.await();
                } catch (InterruptedException ex) {
                    return;
                } catch (BrokenBarrierException ex) {
                    return;
                }
            }
        }
        private int computeValue(int x, int y) {
            // Compute the new value that goes in (x,y)
            return 0;
        }
    }
    public void start() {
        for (Worker worker : workers) {
            new Thread(worker).start();
        }
        mainBoard.waitForConvergence();
    }
    interface Board {
        int getMaxX();
        int getMaxY();
        int getValue(int x, int y);
        int setNewValue(int x, int y, int value);
        void commitNewValues();
        boolean hasConverged();
        void waitForConvergence();
        Board getSubBoard(int numPartitions, int index);
    }
}
```

另一种形式的栅栏是Exchanger，它是一种两方（Two-Party）栅栏，各方在栅栏位置上交换数据。当两方执行不对称的操作时，Exchanger会非常有用

当两个线程通过Exchanger交换对象时，这种交换就把这两个对象安全的发布给另一方。

### 使用同步工具类构造高效且可伸缩的缓存

看上去简单的缓存，可能会将性能瓶颈转变成伸缩性瓶颈，即使缓存是用来提高单线程性能的。

```java
public class Memoizer<A, V> implements Computable<A, V> {
    private final ConcurrentMap<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;
    public Memoizer(Computable<A, V> c) {
        this.c = c;
    }
    public V compute(final A arg) throws InterruptedException {
        while (true) {
            Future<V> f = cache.get(arg);
            if (f == null) {
                Callable<V> eval = new Callable<V>() {
                    public V call() throws InterruptedException {
                        return c.compute(arg);
                    }
                };
                FutureTask<V> ft = new FutureTask<V>(eval);
                f = cache.putIfAbsent(arg, ft);
                if (f == null) {
                    f = ft;
                    ft.run();
                }
            }
            try {
                return f.get();
            } catch (CancellationException e) {
                cache.remove(arg, f);
            } catch (ExecutionException e) {
                throw LaunderThrowable.launderThrowable(e.getCause());
            }
        }
    }
}
```

## 任务执行

### 在线程中执行任务

当围绕“任务执行”来设计应用程序结构时，第一步就是要找出清晰的任务边界。  
独立有利于实现并发，因为如果存在足够多的处理资源，那么这些独立的任务都可以并行执行。为了在调度与负载均衡等过程中实现更高的灵活性，每项任务还应该表示应用程序的一小部分处理能力。

在理想情况下，各个任务之间是相互独立的：任务不依赖于其他任务的状态、结果或边界效应。

* 在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。
* 应用程序提供商希望程序支持尽可能多的用户，从而降低每个每个用户的服务成本，而用户则希望获得尽快的响应。
* 而且，当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败。

要实现上述目标，应该选择清晰的任务边界以及明确的任务执行策略。

大多数服务器应用程序都提供了一种自然的任务边界选择方式：以独立的客户请求为边界。  
Web服务器、邮件服务器、文件服务器、EJB容器以及数据库服务器等，这些服务器都能通过网络接受远程客户的连接请求。将独立的请求作为任务边界，既可以实现任务的独立性，又可以实现合理的任务规模。

#### 显示地为任务创建线程

主循环都将创建一个新线程来处理请求，而不是在主循环中进行处理。由此可得出3个主要结论：

* 任务处理程序从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的请求。
	- 这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。
* 任务可以并行处理，从而能同时服务多个请求。
	- 如果有多个处理器，或者任务由于某种原因被阻塞，例如等待I/O完成，获取锁或者资源可用性等，程序的吞吐量将得到提高。
* 任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。

在正常的负载情况下，“为每个任务分配一个线程”的方法能提升串行执行的性能。只要请求的到达率不超出服务器的请求处理能力，那么这种方法可以同时带来更快地响应性和更高的吞吐率。

#### 无限制创建线程的不足

在生产环境中，“为每个任务分配一个线程”这种方法存在一些缺陷，尤其是当需要创建大量的线程时：

* 线程声明周期的开销非常高
	- 线程的创建与销毁并不是没有代价的。根据平台的不同，实际的开销也有所不同，但线程的创建过程都会需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。如果请求的到达率非常高且请求的处理过程是轻量级的，例如大多数服务器应用程序就是这种情况，那么为每个请求创建一个新线程将消耗大量的计算资源。
* 资源消耗
	- 活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用处理器的数量，那么有些线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用处理器的数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收期带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。如果你已经拥有足够多的线程使CPU保持忙碌状态，那么再创建更多地线程反而会降低性能。
* 稳定性
	- 在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么很可能抛出OutOfMemoryError异常，要想从这种错误中恢复过来是非常危险的，更简单的办法是通过构造程序来避免超出这些限制。

### Executor框架

* 串行执行的问题在于其糟糕的响应性和吞吐量
* “为每个任务分配一个线程”的问题在于资源管理的复杂性

java.util.concurrent提供了一种灵活的线程池实现作为Executor框架的一部分

```java
public interface Executor {
    void execute(Runnable command);
}
```

Executor接口为灵活且强大的异步任务执行框架提供了基础，该框架能支持多重不同类型的任务执行策略。
它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。  
Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。

Executor基于生产者—消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程则相当于消费者（执行完成这些工作单元）。
如果要在程序中实现一个生产者—消费者的设计，那么最简单的方式通常就是使用Executor。

#### 执行策略

通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的“What、Where、When、How“等方面，包括：

* 在什么（What）线程中执行任务？
* 任务按照什么（What）顺序执行（FIFO、LIFO、优先级）？
* 有多少个（How Many）任务能并发执行？
* 在队列中有多少个（How Many）任务在等待执行？
* 如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？
* 在执行一个任务之前或之后，应该进行哪些（What）动作？

> 每当看到下面这种形式的代码时： 
> new Thread(runnable).start() 
> 并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread。

#### 线程池Executor

线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。  
工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。

优势：

* 通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。
* 另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而延迟任务的执行，从而提高了响应性。
* 通过适当调整线程池的大小，可以创建足够多得线程以便使处理器保持忙碌状态，同时还可以方式过多线程相互竞争资源而使应用程序耗尽内存或失败。

可以通过调用Executors中的静态工厂方法之一来创建一个线程池： 

* newFixedThreadPool
	- newFixedThreadPool将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。 
* newCachedThreadPool
	- newCachedThreadPool将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。 
* newSingleThreadExecutor
	- newSingleThreadExecutor是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能够确保依照任务在队列中的顺序来串行执行（例如FIFO、LIFO、优先级）。 
	- 单线程的Executor还提供了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是可见的，这意味着，即使这个线程会不时地被另一个线程替代，单对象总是可以安全的封闭在“任务线程”中
* newScheduledThreadPool
	- newScheduledThreadPool创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

newFixedThreadPool与newCachedThreadPool两个工厂方法返回通用的ThreadPoolExecutor实例。

通过使用Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其他功能。

参看《Jdk1.5 Executors工厂类来产生线程池》部分

#### Executor的生命周期

Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出。因此，如果无法正确的关闭Executor，那么JVM将无法结束。

为了解决执行服务的声明周期问题，Executor扩展了ExecutorService接口，添加了一些用于声明周期管理的方法。

```java
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException;
    <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;
    <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
```

ExecutorService的生命周期有3种状态：运行、关闭、已终止。初始创建时处于运行状态。

* shutdown方法将执行平缓的关闭过程
	- 不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务
* shutdownNow方法将执行粗暴的关闭过程
	- 它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始的任务

在ExecutorService关闭后提交的任务由拒绝执行处理器RejectedExecutionHandler处理，它会抛弃任务，或者使得execute方法抛出一个未受检的RejectedExecutionException。  
等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止。  
通常在调用awaitTermination后立即调用shutdown，从而产生同步关闭ExecutorService的效果。

```java
public class LifecycleWebServer {
	// guava包ThreadFactoryBuilder
    private ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
            .setNameFormat("demo-pool-%d").build();
    private ExecutorService exec = new ThreadPoolExecutor(
            5,
            200,
            0L,
            TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(1024),
            namedThreadFactory,
            new ThreadPoolExecutor.AbortPolicy());
    public void start() throws IOException {
        try (ServerSocket socket = new ServerSocket(80)) {
            while (!exec.isShutdown()) {
                try {
                    final Socket conn = socket.accept();
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            handleRequest(conn);
                        }
                    });
                } catch (RejectedExecutionException e) {
                    if (!exec.isShutdown()) {
                        log("task submission rejected", e);
                    }
                }
            }
        }
    }
    public void stop() {
        exec.shutdown();
    }
    private void log(String msg, Exception e) {
        Logger.getAnonymousLogger().log(Level.WARNING, msg, e);
    }
    void handleRequest(Socket connection) {
        Request req = readRequest(connection);
        if (isShutdownRequest(req)) {
            stop();
        } else {
            dispatchRequest(req);
        }
    }
    private Request readRequest(Socket s) {
        return null;
    }
    private void dispatchRequest(Request r) {}
    private boolean isShutdownRequest(Request r) {
        return false;
    }
    interface Request {}
}
```

#### 延迟任务与周期任务

Timer类负责管理延迟任务和周期任务。然后，Timer类存在一些缺陷（Timer支持基于绝对时间而不是相对时间的调度机制，因此任务的执行对系统时钟变化很敏感，而ScheduledThreadPoolExecutor只支持基于相对时间的调度），因此应该考虑使用ScheduledThreadPoolExecutor来代替。  
可以通过ScheduledThreadPoolExecutor的构造函数或newScheduledThreadPool工厂方法来创建该类对象。

Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行事件过长，那么将破坏其他TimerTask的定时精确性。  
线程池能弥补这个缺陷，它可以提供多个线程来执行延时任务和周期任务。

Timer线程并不捕获异常，如果TimerTask抛出了一个未受检的异常，那么将终止定时线程。
这种情况下，Timer不会恢复线程的运行，而是会错误的认为整个Timer都被取消了。
因此，已经被调度但尚未执行的TimerTask将不会执行，新的任务也不能被调度。（这个问题被称之为“线程泄漏”）

因此在Java5.0之后的版本，将很少使用Timer。

如果要构建自己的调度服务，可以使用DelayQueue，它实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能。
DelayQueue管理一组Delayed对象。每个Delayed对象都有一个相应的延迟时间：  
在DelayQueue中，只有某个元素与气候，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据它们的延迟时间进行排序。

### 找出可利用的并行性

#### 携带结果的任务Callable与Future

##### Callable

Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，它不能返回一个值或抛出一个受检查的异常。  
对于存在延迟的计算，Callable是一种更好的抽象：它认为主入口点将返回一个值，并可能抛出一个异常。（可以使用Callable<Void>表示无返回值的任务）。Executor中包含了一些辅助方法将其他类型的任务封装为一个Callable。

##### Future

Future表示一个任务的生命周期，并提供了相应的方法判断是否已经完成或取消，以及获取任务的结果和取消任务。  
Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退。当某个任务完成后，就永远停留在“完成”状态上。

get方法的行为取决于任务的状态：

* 已完成的任务，get会立刻返回或抛出Exception。任务没完成，get将阻塞到任务完成。
* 任务抛出异常时，get将该异常封装为ExecutionException重新抛出。
	- 如果get抛出ExecutionException，可以通过getCause来获得被封装的初始异常。
* 任务取消时get抛出CancellationException。

**ExecutorService返回Future**：

ExecutorService中的所有submit方法都返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或取消任务。
还可以显式的为某个指定的Runnable或Callable实例化一个FutureTask。FutureTask实现了Runnable，可以被提交给Executor执行，或直接调用run()方法。

Java6开始，ExecutorService实现可以改写AbstractExecutorService中的newTaskFor方法，从而根据已提交的Runnable或Callable来控制Future的实例化过程。在默认实现中仅创建了一个新的FutureTask。

在将Runnable或Callable提交到Executor的过程中，包含了一个安全发布过程，即将Runnable或Callable从提交线程发布到最终执行任务的线程。
在设置Future结果的过程中也包含了一个安全发布，即将这个结果从计算它的线程发布到任何通过get获得它的线程。

get方法拥有“状态依赖”的内在特性，因而调用者不需要知道任务的状态，此外在任务提交和获得结果中包含的安全发布属性也确保了这个方法是线程安全的。

Future.get的异常处理代码将处理两个可能的问题：

任务遇到一个Exception，或者调用get的线程在获得结果之前被中断。

```java
// 异步获取图片和渲染文本
public abstract class FutureRenderer {
	// 这里使用自定义ExecutorService
    private final ExecutorService executor = ...;
    void renderPage(CharSequence source) {
        final List<ImageInfo> imageInfos = scanForImageInfo(source);
        // 分离下载线程
        Callable<List<ImageData>> task =
                new Callable<List<ImageData>>() {
                    @Override
                    public List<ImageData> call() {
                        List<ImageData> result = new ArrayList<ImageData>();
                        for (ImageInfo imageInfo : imageInfos) {
                            result.add(imageInfo.downloadImage());
                        }
                        return result;
                    }
                };
        Future<List<ImageData>> future = executor.submit(task);
        renderText(source);
        try {
        	// 下载结束后渲染所有
            List<ImageData> imageData = future.get();
            for (ImageData data : imageData) {
                renderImage(data);
            }
        } catch (InterruptedException e) {
            // Re-assert the thread's interrupted status
            Thread.currentThread().interrupt();
            // We don't need the result, so cancel the task too
            future.cancel(true);
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }
    abstract void renderText(CharSequence s);
    abstract List<ImageInfo> scanForImageInfo(CharSequence s);
    abstract void renderImage(ImageData i);
    interface ImageData {}
    interface ImageInfo {
        ImageData downloadImage();
    }
}
```

#### 在异构任务并行化中的局限

通过对异构任务进行并行化来获得重大的性能提升是很困难的。

如果没有找出相似的任务之间找出细粒度的并行性，那么这种方法带来的好处将减少。为了使任务分解提高性能，任务协调开销不能高于并行实现的提升。

只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升

#### CompletionService：Executor与BlockingQueue

CompletionService将Executor和BlockingQueue的功能融合在一起。
可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，这些结果在完成时会封装成Future。
ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor。

ExecutorCompletionService的实现非常简单。在构造函数中创建一个BlockingQueue来保存计算完成的结果。计算完成时，调用Future-Task中的done方法。
当提交某个任务时，该任务将首先包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，并将结果放入BlockingQueue中。
take和poll方法委托给了BlockingQueue，行为与BlockingQueue一致。

多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。
因此，CompletionService的作用就相当于一组计算的句柄，这与Future作为单个计算的句柄类似。
通过记录提交给CompletionService的任务数量，并计算出已经获得的已完成结果的数量，即使使用一个共享的Executor，也能知道已经获得了所有任务结果的时间

```java
public abstract class Renderer {
    private final ExecutorService executor;
    Renderer(ExecutorService executor) {
        this.executor = executor;
    }
    void renderPage(CharSequence source) {
        final List<ImageInfo> info = scanForImageInfo(source);
        CompletionService<ImageData> completionService =
                new ExecutorCompletionService<>(executor);
        for (final ImageInfo imageInfo : info) {
        	// 分配单独线程下载图片
            completionService.submit(new Callable<ImageData>() {
                @Override
                public ImageData call() {
                    return imageInfo.downloadImage();
                }
            });
        }
        renderText(source);
        try {
            for (int t = 0, n = info.size(); t < n; t++) {
            	// 获取结果直接渲染
                Future<ImageData> f = completionService.take();
                ImageData imageData = f.get();
                renderImage(imageData);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }
    abstract void renderText(CharSequence s);
    abstract List<ImageInfo> scanForImageInfo(CharSequence s);
    abstract void renderImage(ImageData i);
    interface ImageData {}
    interface ImageInfo {
        ImageData downloadImage();
    }
}
```

#### 为任务设置时间

有时，如果某个任务无法在指定时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。

在支持时间限制的Future.get中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，将抛出TimeoutException。

在使用限时任务是需要注意，当这些任务超时后应该立即停止，从而避免为计算一个不再使用的结果而浪费计算资源。

要实现这个功能，可以由任务本身来管理它的限时事件，并在超时后终止执行或取消任务。
此时可再次使用Future，如果一个限时的get方法抛出了TimeoutException,那么可以通过Future来取消任务。
如果编写的任务是可取消的，那么可以提前终止它，以免消耗过多的资源。

```java
// 超时加载默认广告并取消任务
public class RenderWithTimeBudget {
    private static final Ad DEFAULT_AD = new Ad();
    private static final long TIME_BUDGET = 1000;
    private static final ExecutorService exec = Executors.newCachedThreadPool();
    Page renderPageWithAd() throws InterruptedException {
        long endNanos = System.nanoTime() + TIME_BUDGET;
        Future<Ad> future = exec.submit(new FetchAdTask());
        // Render the page while waiting for the ad
        Page page = renderPageBody();
        Ad ad;
        try {
            // Only wait for the remaining time budget
            long timeLeft = endNanos - System.nanoTime();
            ad = future.get(timeLeft, TimeUnit.NANOSECONDS);
        } catch (ExecutionException e) {
            ad = DEFAULT_AD;
        } catch (TimeoutException e) {
            ad = DEFAULT_AD;
            future.cancel(true);
        }
        page.setAd(ad);
        return page;
    }
    Page renderPageBody() {
        return new Page();
    }
    static class Ad {}
    static class Page {
        public void setAd(Ad ad) {
        }
    }
    static class FetchAdTask implements Callable<Ad> {
        @Override
        public Ad call() {
            return new Ad();
        }
    }
}
```

**invokeAll**

invokeAll方法的参数为一组任务，返回一组Future。这两个集合有着相同的结构。
invokeAll按照任务集合中迭代器的顺序将所有的Future添加到返回的集合中，从而使调用者能将Future与其表示的Callable关联起来。
当所有任务都执行完毕、或调用线程被中断、或超时时，invokeAll将返回。当超时后，任何还未完成的任务都会取消。
invokeAll返回后，每个任务要么正常的完成，要么被取消，客户端代码可以调用get或isCancelled判断情况。

```java
interface TravelCompany {
    TravelQuote solicitQuote(TravelInfo travelInfo) throws Exception;
}
interface TravelQuote {}
interface TravelInfo {}

public class TimeBudget {
    private static ExecutorService exec = Executors.newCachedThreadPool();
    public List<TravelQuote> getRankedTravelQuotes(
            TravelInfo travelInfo,
            Set<TravelCompany> companies,
            Comparator<TravelQuote> ranking,
            long time,
            TimeUnit unit)
            throws InterruptedException {
        List<QuoteTask> tasks = new ArrayList<QuoteTask>();
        for (TravelCompany company : companies) {
            tasks.add(new QuoteTask(company, travelInfo));
        }
        List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);
        List<TravelQuote> quotes =
                new ArrayList<TravelQuote>(tasks.size());
        Iterator<QuoteTask> taskIter = tasks.iterator();
        for (Future<TravelQuote> f : futures) {
            QuoteTask task = taskIter.next();
            try {
                quotes.add(f.get());
            } catch (ExecutionException e) {
                quotes.add(task.getFailureQuote(e.getCause()));
            } catch (CancellationException e) {
                quotes.add(task.getTimeoutQuote(e));
            }
        }

        Collections.sort(quotes, ranking);
        return quotes;
    }

}

class QuoteTask implements Callable<TravelQuote> {
    private final TravelCompany company;
    private final TravelInfo travelInfo;
    public QuoteTask(TravelCompany company, TravelInfo travelInfo) {
        this.company = company;
        this.travelInfo = travelInfo;
    }
    TravelQuote getFailureQuote(Throwable t) {
        return null;
    }
    TravelQuote getTimeoutQuote(CancellationException e) {
        return null;
    }
    @Override
    public TravelQuote call() throws Exception {
        return company.solicitQuote(travelInfo);
    }
}
```

## 取消与关闭

Java没有提供任何机制来安全地终止线程（Thread.stop 和 suspend 等方法存在着一些严重缺陷，应该避免使用），但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的工作。

立即停止会使共享的数据结构处于不一致的状态，需要停止时，发出中断请求，被要求中断的线程处理完他当前的任务后会自己判断是否停下来

一个行为良好的软件与勉强运行的软件之间的最主要区别就是，行为良好的软件能很完善的处理失败、关闭和取消等过程。

### 任务取消

如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的。

取消某个操作的原因很多：

* 用户请求取消
* 有时间限制的操作
* 应用程序事件
	- 多线程任务中一个已经得到结果，其他程序应该取消
* 错误
	- 如磁盘满无法继续写入
* 关闭
	- 服务关闭

在Java中没有一种安全的抢占方法来停止线程，因此没有安全的抢占式方法停止任务，只有协作式的机制。

其中一种协作机制是设置某个 已取消请求Cancellation requested标志，任务定期的查看该标志。

取消策略：

详细地定义取消操作的“How”、“When”以及“What”，即其他代码如何（How）请求取消该任务，任务在何时（When）检查是否已经请求了取消，以及在响应取消请求时应该执行哪些（What）操作

```java
// 客户代码通过cancel取消请求
// 每次操作前首先检查是否存在取消请求，如果存在就推出
@ThreadSafe
public class PrimeGenerator implements Runnable {
    private static ExecutorService exec = Executors.newCachedThreadPool();
    @GuardedBy("this")
    private final List<BigInteger> primes = new ArrayList<BigInteger>();
    private volatile boolean cancelled;
    static List<BigInteger> aSecondOfPrimes() throws InterruptedException {
        PrimeGenerator generator = new PrimeGenerator();
        exec.execute(generator);
        try {
            SECONDS.sleep(1);
        } finally {
            generator.cancel();
        }
        return generator.get();
    }
    @Override
    public void run() {
        BigInteger p = BigInteger.ONE;
        while (!cancelled) {
            p = p.nextProbablePrime();
            synchronized (this) {
                primes.add(p);
            }
        }
    }
    public void cancel() {
        cancelled = true;
    }
    public synchronized List<BigInteger> get() {
        return new ArrayList<BigInteger>(primes);
    }
}
```

*注意：这是一个有问题的取消方式，若线程阻塞在add操作后，那么即使设置了取消状态，它也不会运行到检验阻塞状态的代码，因此会永远阻塞*

#### 中断

> 在Java的API或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，都是不合适的，并且很难支撑起更大的应用。

每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将被设置为true。在Thread中包含了中断线程以及查询线程中断状态的方法。
interrupt方法能中断目标线程，isInterrupted方法能返回目标线程的中断状态。static的interrupted方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法

阻塞库方法，例如Thread.sleep和Object.wait等，都会检查线程何时中断，并且在发现时提前返回。

它们在响应中断时执行的操作包括 :

清除中断状态，抛出InterruptedException，表示阻塞操作由于中断而提前结束。

当线程在非阻塞状态时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。

通过这样的方法，中断操作将变得“有粘性”——如果不触发InterruptedException，那么中断状态将一直保持，直到明确地清除中断状态。

> 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。

对于中断操作的正确理解是：

它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时候中断自己。

* wait、join、sleep等将严格处理这种请求，他们收到中断请求或者在开始执行时发现某个已被设置好的终端状态时，将会抛出一个异常
* 设计良好的方法应严格的处理这种请求，如果方法能使调用代码对中断请求进行某种处理，那么完全可以忽略这种请求。
* 但在无法处理的时候，应该抛出InterruptedException，以便其他代码可以正确的处理中断请求。

使用 interrupted时应注意。如果在调用interrupted时返回了true，那么除非想屏蔽这个中断，否则必须对它进行处理。可以抛出InterruptedException，或者通过再次调用interrupt来恢复中断状态。

```java
public class Thread {
	// 中断目标线程，恢复中断状态
    public void interrupt() { ... }
    // 返回目标线程的中断状态
    public boolean isInterrupted() { ... }
    // 清除当前线程的中断状态，并返回它之前的值（用于已经设置了中断状态，但还尚未相应中断）
    public static boolean interrupted() { ... }
    ...
}
```

interrupt方法用于中断线程。调用该方法的线程的状态为将被置为"中断"状态。

*注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。
支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。*


> 通常，中断是实现取消的最合理方式

```java
// 存在自定义取消机制无法与可阻塞的库函数实现良好交互的问题
// 如果任务带么能够响应中断，那么可以使用中断作为取消机制，并且利用许多类库中提供的中断支持
class BrokenPrimeProducer extends Thread {
    private final BlockingQueue<BigInteger> queue;
    private volatile boolean cancelled = false;
    BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
        this.queue = queue;
    }
    @Override
    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (!cancelled) {
                queue.put(p = p.nextProbablePrime());
            }
        } catch (InterruptedException consumed) {
        }
    }
    public void cancel() {
        cancelled = true;
    }
}
```

解决上面的不协调问题：

```java
// 使用中断而不是boolean类型请求取消
// 由于调用了queue的put方法，所以并不需要使用显示检测
// 但是显示检测可以提高程序的响应性
public class PrimeProducer extends Thread {
    private final BlockingQueue<BigInteger> queue;
    PrimeProducer(BlockingQueue<BigInteger> queue) {
        this.queue = queue;
    }
    @Override
    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (!Thread.currentThread().isInterrupted()) {
                queue.put(p = p.nextProbablePrime());
            }
        } catch (InterruptedException consumed) {
            /* Allow thread to exit */
        }
    }
    public void cancel() {
        interrupt();
    }
}
```

#### 中断策略

中断策略规定线程如何解释某个中断请求——当发现中断请求时，应该做哪些工作（如果需要的话），哪些工作单元对于中断来说是原子操作，以及以多快的速度来响应中断。

区分任务和线程对中断的反应是很重要的。一个中断请求可以有一个或多个接受者——中断线程池中的某个工作者线程，同事意味着“取消当前任务”和“关闭工作者线程”

这就是为什么大多数可阻塞的库函数都只是抛出InterruptedException作为中断响应。它们永远不会在某个由自己拥有的线程中运行，因此它们为任务或库代码实现了最合理的取消策略：  
尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步的操作。

当检查到中断请求时，任务并不需要放弃所有的操作——它可以推迟处理中断请求，并直到某个更合适的时候。
因此需要记住中断请求，并在完成当前任务后抛出InterruptedException或者表示已收到中断请求。
这项技术能够确保在更新过程中发生中断时，数据结构不会被破坏。

任务并不应该对执行该任务的线程的中断策略做出任何假设，除非该任务被专门设计为在服务中运行，并且在这些服务中包含特定的中断策略。

无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心地保存执行线程的中断状态。
如果除了将InterruptedException传递给调用者外还需要执行其他操作，那么应该在捕获InterruptedException之后恢复中断状态：

```java
Thread.currentThread().interrupt();
```

正如任务代码不应该对其执行所在的线程的中断策略做出假设，执行取消操作的代码也不应该对线程的中断策略做出假设。
线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如shutdown方法

> 由于每个线程拥有各自的中断策略，所以除非知道中断对该线程的含义，否则就不应该中断这个线程。

#### 响应中断

当调用可中断的阻塞函数时，有两种实用策略可用于处理InterruptedException

* 传递异常（可能在执行某个特定于任务的清除操作之后），从而使得你的方法也成为可中断的阻塞方法。
* 恢复中断状态，从而使得调用栈中的上层代码能够对其处理。 

```java
// 传递异常
public Task getNextTask(BlockingQueue<Task> queue) throws InterruptedException {
	// ...
}
```

如果你不想或者无法传递InterruptException（或许通过Runnable来定义任务），一个标准的做法就是通过调用interrupt来恢复中断状态。

> 只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。

对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是捕获 InterruptException 时恢复状态

```java
public class NoncancelableTask {
    public Task getNextTask(BlockingQueue<Task> queue) {
        boolean interrupted = false;
        try {
            while (true) {
                try {
                    return queue.take();
                } catch (InterruptedException e) {
                    interrupted = true;
                    // fall through and retry
                }
            }
        } finally {
            if (interrupted) {
            	// 向上传递中断状态
                Thread.currentThread().interrupt();
            }
        }
    }
    interface Task {
    }
}
```

不要在外围线程中安排中断，因为不了解外围线程的中断策略。在单独的线程中中断任务：

```java
// 依赖于一个限时的join，存在join的不足：无法获知正常退出还是join超时返回
public class TimedRun {
    private static final ScheduledExecutorService cancelExec = newScheduledThreadPool(1);
    public static void timedRun(final Runnable r, long timeout, TimeUnit unit) throws InterruptedException {
        class RethrowableTask implements Runnable {
            private volatile Throwable t;
            @Override
            public void run() {
                try {
                    r.run();
                } catch (Throwable t) {
                    this.t = t;
                }
            }
            void rethrow() {
                if (t != null) {
                    throw LaunderThrowable.launderThrowable(t);
                }
            }
        }
        RethrowableTask task = new RethrowableTask();
        final Thread taskThread = new Thread(task);
        taskThread.start();
        cancelExec.schedule(new Runnable() {
            @Override
            public void run() {
            	// 尝试中断taskThread，有Runnable对象r处理中断响应
                taskThread.interrupt();
            }
        }, timeout, unit);
        // 线程加入(等待某线程执行结束后才继续执行)
        taskThread.join(unit.toMillis(timeout));
        task.rethrow();
    }
}
```

##### 通过Future来实现取消

Future是对管理任务的生命周期、处理异常以及实现取消的一种抽象机制。

ExecutorService.submit将返回一个Future来描述任务。

Future拥有一个cancel方法，该方法带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功。（这只是表示任务是否能够接收中断，而不是表示任务是否能检测并处理中断。）

* 如果mayInterruptIfRunning为true并且任务当前正在某个线程中运行，那么这个线程能被中断。
* 如果这个参数为false，那么意味着“若任务还没有启动，就不要运行它”，这种方式应该用于那些不处理中断的任务中。

```java
public class TimedRun {
    private static final ExecutorService taskExec = Executors.newCachedThreadPool();
    public static void timedRun(Runnable r, long timeout, TimeUnit unit) throws InterruptedException {
        Future<?> task = taskExec.submit(r);
        try {
            task.get(timeout, unit);
        } catch (TimeoutException e) {
            // task will be cancelled below
        } catch (ExecutionException e) {
            // exception thrown in task; rethrow
            throw launderThrowable(e.getCause());
        } finally {
            // Harmless if task already completed
            task.cancel(true); // interrupt if running
        }
    }
}
```

> 当Future.get抛出InterruptedException或TimeoutException时，如果你知道不再需要结果，那么就可以调用Future.cancel来取消任务。

##### 处理不可中断的阻塞

在Java库中，许多可阻塞的方法都是通过提前返回或者抛出InterruptedException来响应中断请求的，从而使开发人员更容易构建出能响应取消请求的任务。  
然而，并非所有的可阻塞方法或者阻塞机制都能响应中断；如果一个线程由于执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。
对于那么由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。

* Java.io包中的同步Socket I/O
	- 虽然InputStream和OutputStream中的read和write等方法都不会响应中断，但通过关闭底层的套接字，可以使得由于执行read或write等方法而被阻塞的线程抛出一个SocketException。
* Java.io包中的同步I/O
	- 当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptedException）并关闭链路（这还会使得其他在这条链路上阻塞的线程同样抛出ClosedByInterruptException）。当关闭一个InterruptibleChannel时，将导致所有在链路操作上阻塞的线程抛出AsynchronousCloseException。大多数标准的Channel都实现了InterruptibleChannel。
* Selector的异步I/O
	- 如果一个线程在调用Selector.select方法（在java.nio.channels中）时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedSelectorException并提前返回。
* 获取某个锁
	- 如果一个线程由于等待某个内置锁而被阻塞，那么将无法响应中断，因为线程认为它肯定获得锁，所以将不会理会中断请求。但是，在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。

```java
public class ReaderThread extends Thread {
    private static final int BUFSZ = 512;
    private final Socket socket;
    private final InputStream in;
    public ReaderThread(Socket socket) throws IOException {
        this.socket = socket;
        this.in = socket.getInputStream();
    }
    @Override
    public void interrupt() {
        try {
        	// 中断socket
            socket.close();
        } catch (IOException ignored) {
        } finally {
        	// 向上层传递中断状态
            super.interrupt();
        }
    }
    @Override
    public void run() {
        try {
            byte[] buf = new byte[BUFSZ];
            while (true) {
                int count = in.read(buf);
                if (count < 0) {
                    break;
                } else if (count > 0) {
                    processBuffer(buf, count);
                }
            }
        } catch (IOException e) { /* Allow thread to exit */
        }
    }
    public void processBuffer(byte[] buf, int count) {
    }
}
```

##### 采用newTaskFor来封装非标准的取消

当把一个Callable提交给ExecutorService时，submit方法会返回一个Future，可以通过这个Future取消任务。  
Java 6在ThreadPoolExecutor中新增了newTaskFor方法。newTaskFor是一个工厂方法，它将创建Future来代表任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable，并由FutureTask实现。

通过定制表示任务的Future可以改变Future.cancel的行为。

```java
interface CancellableTask<T> extends Callable<T> {
    void cancel();
    RunnableFuture<T> newTask();
}
@ThreadSafe
class CancellingExecutor extends ThreadPoolExecutor {
    // ...
    @Override
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        if (callable instanceof CancellableTask) {
            return ((CancellableTask<T>) callable).newTask();
        } else {
            return super.newTaskFor(callable);
        }
    }
}
public abstract class SocketUsingTask<T> implements CancellableTask<T> {
    @GuardedBy("this")
    private Socket socket;
    protected synchronized void setSocket(Socket s) {
        socket = s;
    }
    @Override
    public synchronized void cancel() {
        try {
            if (socket != null) {
                socket.close();
            }
        } catch (IOException ignored) {
        }
    }
    @Override
    public RunnableFuture<T> newTask() {
        return new FutureTask<T>(this) {
            @Override
            public boolean cancel(boolean mayInterruptIfRunning) {
                try {
                	// 关闭socket
                    SocketUsingTask.this.cancel();
                } finally {
                    return super.cancel(mayInterruptIfRunning);
                }
            }
        };
    }
}
```

### 停止基于线程的服务


## 判断是否有问题

1. 是否是多线程环境
2. 是否有共享数据
3. 是否有多条语句操作共享数据

参考虚拟机部分的《先行发生原则》

## 解决多线程安全问题

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

* 不在线程之间共享该状态变量
* 将状态变量修改为不可变的变量
* 在访问状态变量时使用同步

### 线程安全类（类或状态变量不可变）

当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。

### 使用同步

让程序没有安全问题的环境,把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

#### 同步代码块

> synchronized(对象){需要同步的代码;}

#### 同步方法

把同步关键字加到方法上  
这里的锁对象是this

##### 静态同步方法

这里的锁对象是当前类的字节码文件对象

```java
class Outputer{
	public void output1(String name){
		synchronized (Outputer.class){
		}
	}

	public synchronized void output2(String name){
	}

	public static synchronized void output3(String name){
	}
}
// 1和3同步
// 2和3不同步，因为2锁定的是this对象，而3锁定的是当前类的字节码对象
```

#### 同步方法选择

如果锁对象是this，就可以考虑使用同步方法。  
否则能使用同步代码块的尽量使用同步代码块。

#### 同步弊端

* 当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。
* 如果出现了同步嵌套，就容易产生死锁问题

#### Jdk1.5 使用Lock锁

##### Lock锁

Lock比传统线程模型中的synchronized方式更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。

```java
// 定义票
private int tickets = 100;

// 定义锁对象
private Lock lock = new ReentrantLock();//ReentrantLock是Lock的实现类

@Override
public void run() {
    while (true) {
        try {// try finally防止中间代码异常锁不被释放
            // 加锁
            lock.lock();
            if (tickets > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()
                        + "正在出售第" + (tickets--) + "张票");
            }
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```

##### 读写锁

分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，写锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！

```java
private Map<String, Object> cache = new HashMap<String, Object>();
private ReadWriteLock rwl = new ReentrantReadWriteLock();
public  Object getData(String key){
rwl.readLock().lock();
Object value = null;
try{
	value = cache.get(key);
	if(value == null){
		rwl.readLock().unlock();
		rwl.writeLock().lock();
		try{
			if(value==null){//这里的判断防止别的线程在第一个write线程后恢复获取写锁重复写数据
					value = "aaaa";//实际失去queryDB();
				}
			}finally{
				rwl.writeLock().unlock();
			}
			rwl.readLock().lock();
		}
	}finally{
		rwl.readLock().unlock();
	}
	return value;
}
```

##### Condition

在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。对于大多数应用程序，这带来的实际影响很小，因为 Condition 应该总是在一个循环中被等待，并测试正被等待的状态声明。某个实现可以随意移除可能的虚假唤醒，但建议应用程序程序员总是假定这些虚假唤醒可能发生，因此总是在一个循环中等待。  
一个锁内部可以有多个Condition，即有多路等待和通知

```java
//condition条件唤醒实现阻塞队列
class BoundedBuffer {
	final Lock lock = new ReentrantLock();
	final Condition notFull = lock.newCondition(); 
	final Condition notEmpty = lock.newCondition(); 

	final Object[] items = new Object[100];
	int putptr, takeptr, count;

	public void put(Object x) throws InterruptedException {
		lock.lock();
		try {
			while (count == items.length){
				notFull.await();
			}
			items[putptr] = x;
			if (++putptr == items.length) {
				putptr = 0;
			}
			++count;
			notEmpty.signal();
		} finally {
			lock.unlock();
		}
	}

	public Object take() throws InterruptedException {
		lock.lock();
		try {
			while (count == 0){
				notEmpty.await();
			}
			Object x = items[takeptr];
			if (++takeptr == items.length) {
				takeptr = 0;
			}
			--count;
			notFull.signal();
			return x;
		} finally {
			lock.unlock();
		}
	}
}
```

##### Semaphore

Semaphore可以维护当前访问自身的线程个数，并提供了同步机制。使用Semaphore可以控制同时访问资源的线程个数，例如，实现一个文件允许的并发访问数。

```java
public static void main(String[] args) {
	ExecutorService service = Executors.newCachedThreadPool();
	final  Semaphore sp = new Semaphore(3);
	for(int i=0;i<10;i++){
		Runnable runnable = new Runnable(){
			public void run(){
				try {
					sp.acquire();
				} catch (InterruptedException e1) {
					e1.printStackTrace();
				}
				System.out.println("线程" + Thread.currentThread().getName() + 
					"进入，当前已有" + (3-sp.availablePermits()) + "个并发");
				try {
					Thread.sleep((long)(Math.random()*3000));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println("线程" + Thread.currentThread().getName() + 
					"即将离开");					
				sp.release();
				//下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元
				System.out.println("线程" + Thread.currentThread().getName() + 
					"已离开，当前已有" + (3-sp.availablePermits()) + "个并发");					
			}
		};
		service.execute(runnable);
	}
	service.shutdown();
}
```

##### 其他线程同步工具类

* CyclicBarrier
	- 表示大家彼此等待，大家集合好后才开始出发，分散活动后又在指定地点集合碰面
* CountDownLatch
	- 犹如倒计时计数器，调用CountDownLatch对象的countDown方法就将计数器减1，当计数到达0时，则所有等待者或单个等待者开始执行
* Exchanger
	- 用于实现两个线程之间的数据交换，每个线程在完成一定的事务后想与对方交换数据，第一个先拿出数据的线程将一直等待第二个线程拿着数据到来时，才能彼此交换数据。

**CyclicBarrier**

```java
public void timeCount1(Executor executor, int concurrent, final Runnable runnable) throws InterruptedException {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(concurrent);
    IntStream.rangeClosed(1, concurrent).forEach(
            i -> {
                executor.execute(() -> {
                    System.out.println("prepared " + i);
                    try {
                        cyclicBarrier.await();
                    } catch (InterruptedException | BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                    runnable.run();
                });
            }
    );
}
```

**CountDownLatch**

```java
public long timeCount(Executor executor, int concurrent, final Runnable runnable) throws InterruptedException {
    CountDownLatch prepare = new CountDownLatch(concurrent);
    CountDownLatch start = new CountDownLatch(1);
    CountDownLatch done = new CountDownLatch(concurrent);
    IntStream.rangeClosed(1, concurrent).forEach(
            i -> {
                executor.execute(() -> {
                    System.out.println("prepared " + i);
                    prepare.countDown();
                    try {
                        start.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    runnable.run();
                    done.countDown();
                });
            }
    );
    long begin = System.nanoTime();
    prepare.await();
    System.out.println("begin");
    start.countDown();
    done.await();
    System.out.println("done");
    return System.nanoTime() - begin;
}
```

## 死锁

是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象

## 线程通信

### 唤醒机制

* wait():等待 
	- 将来醒过来的时候，是从wait()方法向下执行
* notify():唤醒单个线程 立即释放锁。
	- 唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。
* notifyAll():唤醒所有线程

```java
public static void main(String[] args) {
	final Business business = new Business();
	new Thread(
		new Runnable() {
			@Override
			public void run() {
				for(int i=1;i<=50;i++){
					business.sub(i);
				}
			}
		}
	).start();
	for(int i=1;i<=50;i++){
		business.main(i);
	}
}
```

```java
// 锁和同步机制放在锁对象身上，不用每个调用线程中去写同步代码
class Business {
	private boolean bShouldSub = true;
	public synchronized void sub(int i){
		while(!bShouldSub){// JDK中有阐述使用while防止伪唤醒，即被唤醒以后还是检查是否满足条件
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		for(int j=1;j<=10;j++){
			System.out.println("sub thread sequence of " + j + ",loop of " + i);
		}
		bShouldSub = false;
		this.notify();
	}
	
	public synchronized void main(int i){
		while(bShouldSub){
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		for(int j=1;j<=100;j++){
			System.out.println("main thread sequence of " + j + ",loop of " + i);
		}
		bShouldSub = true;
		this.notify();
	}
}

```

### 线程的状态转换

![线程的状态转换](/static/img/线程/线程的状态转换.jpg "线程的状态转换")

**为什么wait(),notify(),notifyAll()等方法都定义在Object类中**

* 这些方法存在与同步中。
* 使用这些方法时必须要标识所属的同步的锁。
* 锁可以是任意对象，所以任意对象调用的方法一定定义Object类中。

## ThreadLocal

### 作用和目的

用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。

### 原理分析

```java
ThreadLocal{
	HashMap hashMap = new HashMap();
	
    void set(Object obj){
		hashMap.put(Thread.currentThread(),obj);
	}
	object get(){
		return hashMap.get(Thread.currentThread());
	}
}
```

### 特点

一个ThreadLocal代表一个变量，故其中里只能放一个数据，你有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象。如果有一个百个变量要线程共享呢？那请先定义一个对象来装这一百个变量，然后在ThreadLocal中存储这一个对象。

```java
private static ThreadLocal<Integer> x = new ThreadLocal<Integer>();
public static void main(String[] args) {
	for(int i=0;i<2;i++){
		new Thread(new Runnable(){
			@Override
			public void run() {
				int data = new Random().nextInt();
				System.out.println(Thread.currentThread().getName() 
					+ " has put data :" + data);
				x.set(data);
				new A().get();
				new B().get();
			}
		}).start();
	}
}
static class A{
	public void get(){
		int data = x.get();
		System.out.println("A from " + Thread.currentThread().getName() 
			+ " get data :" + data);
	}
}

static class B{
	public void get(){
		int data = x.get();			
		System.out.println("B from " + Thread.currentThread().getName() 
			+ " get data :" + data);
	}
}
// Thread-1 has put data :2094430671
// Thread-0 has put data :-2114425688
// A from Thread-1 get data :2094430671
// A from Thread-0 get data :-2114425688
// B from Thread-1 get data :2094430671
// B from Thread-0 get data :-2114425688
```

**封装写法**

```java
class MyThreadScopeData{
	private MyThreadScopeData(){}
	public static MyThreadScopeData getThreadInstance(){
		MyThreadScopeData instance = map.get();
		if(instance == null){
			instance = new MyThreadScopeData();
			map.set(instance);
		}
		return instance;
	}
	private static ThreadLocal<MyThreadScopeData> map = new ThreadLocal<MyThreadScopeData>();
	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
```

```java
public static void main(String[] args) {
	for(int i=0;i<2;i++){
		new Thread(new Runnable(){
			@Override
			public void run() {
				int data = new Random().nextInt();
				System.out.println(Thread.currentThread().getName() 
					+ " has put data :" + data);
				MyThreadScopeData.getThreadInstance().setName("name" + data);
				MyThreadScopeData.getThreadInstance().setAge(data);
				new A().get();
				new B().get();
			}
		}).start();
	}
}
static class A{
	public void get(){
		MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();
		System.out.println("A from " + Thread.currentThread().getName() 
			+ " getMyData: " + myData.getName() + "," +
			myData.getAge());
	}
}

static class B{
	public void get(){
		MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();
		System.out.println("B from " + Thread.currentThread().getName() 
			+ " getMyData: " + myData.getName() + "," +
			myData.getAge());
	}
}

// Thread-0 has put data :1764488084
// Thread-1 has put data :-1977536471
// A from Thread-1 getMyData: name-1977536471,-1977536471
// A from Thread-0 getMyData: name1764488084,1764488084
// B from Thread-1 getMyData: name-1977536471,-1977536471
// B from Thread-0 getMyData: name1764488084,1764488084
```

## 多个线程访问共享对象和数据的方式

* 将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现针对该数据进行的各个操作的互斥和通信。

```java
public static void main(String[] args) {
	ShareData data = new ShareData();
	new Thread(new MyRunnable1(data)).start();
	new Thread(new MyRunnable2(data)).start();
}
```

```java
class MyRunnable1 implements Runnable{
	private ShareData data;
	public MyRunnable1(ShareData data){
		this.data = data;
	}
	int count = 10;
	@Override
	public void run() {
		while(count-->0){
			data.increment();
		}
	}
}
```

```java
class MyRunnable2 implements Runnable{
	private ShareData data;
	public MyRunnable2(ShareData data){
		this.data = data;
	}
	int count = 10;
	@Override
	public void run() {
		while(count-->0){
			data.decrement();
		}
	}
}
```

```java
class ShareData {
	private int j = 0;
	public synchronized void increment(){
		j++;
		System.out.println("j++:"+j);
	}
	public synchronized void decrement(){
		j--;
		System.out.println("j--:"+j);
	}
}
```

* 将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。

```java
public static void main(String[] args) {
	final ShareData data = new ShareData();
	new Thread(new Runnable(){
		@Override
		public void run() {
			int count = 10;
			while(count-->0){
				data.increment();
			}
		}
	}).start();
	new Thread(new Runnable(){
		int count = 10;
		@Override
		public void run() {
			while(count-->0){
				data.decrement();
			}
		}
	}).start();
}
```

```java
class ShareData{
	private int j = 0;
	public synchronized void increment(){
		j++;
		System.out.println("j++:"+j);
	}
	public synchronized void decrement(){
		j--;
		System.out.println("j--:"+j);
	}
}
```

* 上面两种方式的组合：将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类。

```java
public class Test {
	public static void main(String[] args) {
		Test test = new Test();
		new Thread(test.new MyRunnable1()).start();
		new Thread(test.new MyRunnable2()).start();
	}

	private int j = 0;
	public synchronized void increment(){
		j++;
		System.out.println("j++:"+j);
	}
	
	public synchronized void decrement(){
		j--;
		System.out.println("j--:"+j);
	}

	class MyRunnable1 implements Runnable{
		int count = 10;
		@Override
		public void run() {
			while(count-->0){
				increment();
			}

		}
	}

	class MyRunnable2 implements Runnable{
		int count = 10;
		@Override
		public void run() {
			while(count-->0){
				decrement();
			}
		}
	}
}

```

## 线程组

Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。  
默认情况下，所有的线程都属于主线程组。

### 设置线程分组

> Thread(ThreadGroup group, Runnable target, String name)

```java
// ThreadGroup(String name)
ThreadGroup tg = new ThreadGroup("这是一个新的组");

MyRunnable my = new MyRunnable();
// Thread(ThreadGroup group, Runnable target, String name)
Thread t1 = new Thread(tg, my, "林青霞");
Thread t2 = new Thread(tg, my, "刘意");

System.out.println(t1.getThreadGroup().getName());
System.out.println(t2.getThreadGroup().getName());

//通过组名称设置后台线程，表示该组的线程都是后台线程
tg.setDaemon(true);

// 通过结果我们知道了：线程默认情况下属于main线程组
// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组
System.out.println(Thread.currentThread().getThreadGroup().getName());
```

## 线程池

程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。

* 线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
* 在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池
	
### Jdk1.5 Executors工厂类来产生线程池

* public static ExecutorService newCachedThreadPool() 创建一个具有缓存功能的线程池
* public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用的，具有固定线程数的线程池
* public static ExecutorService newSingleThreadExecutor() 创建一个只有单线程的线程池，相当于上个方法的参数是1

```java

//Callable:是带泛型的接口。
//这里指定的泛型其实是call()方法的返回值类型。
public class MyCallable implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
    	int sum = 0;
		for (int x = 0; x < 100; x++) {
			sum += x;
		}
		return sum;
	}
}

public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int x = 0; x < 100; x++) {
			System.out.println(Thread.currentThread().getName() + ":" + x);
		}
	}
}

// 创建一个线程池对象，控制要创建几个线程对象。
// public static ExecutorService newFixedThreadPool(int nThreads);// 固定数目的线程池
// ExecutorService threadPool = Executors.newCachedThreadPool();// 创建缓存线程池。线程数可随需求变化，不设上限直接交给线程处理
// ExecutorService threadPool = Executors.newSingleThreadExecutor();// 创建单一线程池 线程死掉后会重启一个替代线程，保证至少有一个线程
ExecutorService pool = Executors.newFixedThreadPool(2);// 创建固定大小的线程池

// 可以执行Runnable对象或者Callable对象代表的线程
pool.submit(new MyRunnable());
pool.submit(new MyRunnable());

Future<Integer> result = pool.submit(new MyCallable());

Integer i = result.get();

//结束线程池
pool.shutdown();
```

### 线程池启动定时器

支持间隔重复任务的定时方式，不直接支持绝对定时方式，需要转换成相对时间方式。

```java
public class test {

	public static void main(String[] args) {
		//ExecutorService service = Executors.newFixedThreadPool(3);
		ExecutorService service = Executors.newCachedThreadPool();
		for(int i=1;i<=2;i++){
			final int sequence = i;
			//仔细品味runnable对象放到循环里面和外面的区别，为了让每个对象有自己独立的编号			
			service.execute(new Runnable(){
				public void run() {
					try{Thread.sleep(200);}catch(Exception e){}
					for(int j=1;j<=3;j++){
						System.out.println(Thread.currentThread().getName() + " is serving " 
								+ sequence + " task:" + "loop of " + j);
					}
				}
			});
		}
		/*
		用下面这句代码来说明上面的代码是在提交任务，并且所有的任务都已经提交了，但任务是什么时候执行的，则是由线程池调度的！
		*/
		System.out.println("all task have committed!");	
		//注意与service.shutdownNow()的区别。
		service.shutdown();
		
		ScheduledExecutorService scheduledService = Executors.newScheduledThreadPool(1);// 按时间间隔定时调用
		scheduledService.scheduleAtFixedRate(
				new Runnable(){
					public void run() {
						System.out.println("bomb!!!");
					}}, 
				5, 
				1,
				TimeUnit.SECONDS);
	}
}
// all task have committed!
// pool-1-thread-2 is serving 2 task:loop of 1
// pool-1-thread-1 is serving 1 task:loop of 1
// pool-1-thread-2 is serving 2 task:loop of 2
// pool-1-thread-1 is serving 1 task:loop of 2
// pool-1-thread-2 is serving 2 task:loop of 3
// pool-1-thread-1 is serving 1 task:loop of 3
// bomb!!!
// bomb!!!
// bomb!!!
// ...
```

### Callable&Future

* Future取得的结果类型和Callable返回的结果类型必须一致，这是通过泛型来实现的。
* Callable要采用ExecutorSevice的submit方法提交，返回的future对象可以取消任务。
* CompletionService用于提交一组Callable任务，其take方法返回已完成的一个Callable任务对应的Future对象。

```java
public static void main(String[] args) {
	// Future获取结果
	ExecutorService threadPool =  Executors.newSingleThreadExecutor();
	Future<String> future =
	threadPool.submit(
		new Callable<String>() {
			public String call() throws Exception {
				Thread.sleep(2000);
				return "hello";
			};
		}
		);
	System.out.println("等待结果");
	try {
		System.out.println("拿到结果：" + future.get());
	} catch (InterruptedException e) {
		e.printStackTrace();
	} catch (Exception e) {
		e.printStackTrace();
	}
	// 批量获取结果
	ExecutorService threadPool2 =  Executors.newFixedThreadPool(10);
	CompletionService<Integer> completionService = new ExecutorCompletionService<Integer>(threadPool2);
	for(int i=1;i<=10;i++){
		final int seq = i;
		completionService.submit(new Callable<Integer>() {
			@Override
			public Integer call() throws Exception {
				Thread.sleep(new Random().nextInt(5000));
				return seq;
			}
		});
	}
	for(int i=0;i<10;i++){
		try {
			System.out.println(
				completionService.take().get());
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
	}
}
// 等待结果
// 拿到结果：hello
// 8
// 2
// 5
// 4
// 10
// 1
// 6
// 7
// 9
// 3

```


## 定时器

### Timer

```java
public class TimerDemo {
	public static void main(String[] args) {
		// 创建定时器对象
		Timer t = new Timer();
		// 3秒后执行爆炸任务第一次，如果不成功，每隔2秒再继续炸
		t.schedule(new MyTask(t), 3000, 2000);
	}
}

// 做一个任务
class MyTask extends TimerTask {

	private Timer t;
	
	public MyTask(){}
	
	public MyTask(Timer t){
		this.t = t;
	}
	
	@Override
	public void run() {
		System.out.println("beng,爆炸了");
		t.cancel();// 爆炸成功结束任务
	}

}
```

### ScheduledThreadPoolExecutor

优于Timer

```java
ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(3);
scheduledThreadPoolExecutor.schedule(
        () -> System.out.println("hello"),
        1,
        TimeUnit.SECONDS
);
```

## 阻塞队列

阻塞队列与Semaphore有些相似，但也不同，阻塞队列是一方存放数据，另一方释放数据，Semaphore通常则是由同一方设置和释放信号量。

* ArrayBlockingQueue
	- 只有put方法和take方法才具有阻塞功能
* SynchronousQueue
	- 只有有线程take时才能put，否则阻塞

```java
public static void main(String[] args) {
	final BlockingQueue queue = new ArrayBlockingQueue(3);//设置上限三个，满了以后put阻塞
	for(int i=0;i<2;i++){
		new Thread(){
			public void run(){
				while(true){
					try {
						Thread.sleep((long)(Math.random()*1000));
						System.out.println(Thread.currentThread().getName() + "准备放数据!");							
						queue.put(1);
						System.out.println(Thread.currentThread().getName() + "已经放了数据，" + 							
							"队列目前有" + queue.size() + "个数据");
					} catch (InterruptedException e) {
						e.printStackTrace();
					}

				}
			}
			
		}.start();
	}
	
	new Thread(){
		public void run(){
			while(true){
				try {
					//将此处的睡眠时间分别改为100和1000，观察运行结果
					Thread.sleep(1000);
					System.out.println(Thread.currentThread().getName() + "准备取数据!");
					queue.take();
					System.out.println(Thread.currentThread().getName() + "已经取走数据，" + 							
						"队列目前有" + queue.size() + "个数据");					
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		
	}.start();			
}

// Thread-0准备放数据!
// Thread-0已经放了数据，队列目前有1个数据
// Thread-1准备放数据!
// Thread-1已经放了数据，队列目前有2个数据
// Thread-1准备放数据!
// Thread-1已经放了数据，队列目前有3个数据
// Thread-2准备取数据!
// Thread-2已经取走数据，队列目前有2个数据
// Thread-0准备放数据!
// Thread-0已经放了数据，队列目前有3个数据
// Thread-1准备放数据!
// Thread-0准备放数据!
// Thread-2准备取数据!
// Thread-2已经取走数据，队列目前有2个数据
// Thread-1已经放了数据，队列目前有3个数据
// ....
```

两个具有1个空间的队列可以实现同步通知的功能

## 并发技巧清单

* 可变状态是至关重要的(It's the mutable state stupid)。
	- 所有问题都可以归结为如何协调对并发状态的访问。可变状态越少就越容易确保线程安全性。
* 尽量将域声明为final类型，除非需要他们是可变的。
* 不可变对象一定是线程安全的
	- 不可变对象能极大的降低并发编程的复杂性。它们更为简单而且安全，可以任意共享而无须使用加锁或者保护性复杂等机制。
* 封装有助于管理复杂性
	- 在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但是不建议这么做？将数据封装在对象中，更易于维护不变性条件：将同步机制封装在对象中，更易于遵循同步策略。
* 用锁来保护每个可变变量
* 当保护同一个不变性条件中所有变量时，要使用同一个锁。
* 在执行复合操作期间，要持有锁。
* 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。
* 不要故作聪明地推断出不需要使用同步。
* 再设计过程中考虑线程安全，或者在文档中明确指出它不是线程安全的。
* 将同步策略文档化。

----------

*以上概念总结于传智播客Java基础课程、Java并发编程实战*