---  
layout: post  
title: 数据库  
tags: Database  
categories: Database  
published: true  
---  

数据查询语言DQL（表记录查询），数据操纵语言DML(表记录操作，需要提交事务)，数据定义语言DDL（库或表结构操作），数据控制语言DCL（数据库操作及授权）。

## Mysql

### install

```shell
wget http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.16-1.el6.x86_64.rpm-bundle.tar

rpm -ivh MySQL-client-5.6.16-1.el6.x86_64.rpm
rpm -ivh MySQL-devel-5.6.16-1.el6.x86_64.rpm
rpm -ivh MySQL-server-5.6.16-1.el6.x86_64.rpm
# 更新数据库
sudo mysql_upgrade -u root -p


/etc/my.cnf
/etc/mysql/my.cnf

[mysqld]
bind-address=0.0.0.0
lower_case_table_names=
```

### 启动和停止

windows

```bat
net start mysql
net stop mysql

myql -uroot -ppass -hlocalhost
```

linux

```shell
service mysqld start
service mysqld stop
```

### 创建用户和授权

```sql
// 使用安装时生成的默认密码登陆并首次初始化
set password=PASSWORD('admin');
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'admin' WITH GRANT OPTION;

-- 制定IP上登陆
CREATE USER username@ip IDENTIFIED BY 'password';
-- 任意IP登陆
CREATE USER username@'%' IDENTIFIED BY 'password';
SET PASSWORD FOR username=PASSWORD('password');
```

```sql
GRANT create,alter,drop,insert,update,delete,select ON databasename.* TO username@localhost;
GRANT all ON databasename.* TO username@localhost;
GRANT ALL PRIVILEGES ON *.* TO 'xpress'@'%' IDENTIFIED BY 'admin' WITH GRANT OPTION;
REVOKE all ON databasename.* FROM username@localhost;
FLUSH PRIVILEGES;
SHOW GRANTS FOR username@localhost;
```

### 数据库操作

```sql
show global variables like '%datadir%';
-- 创建数据库
CREATE DATABASE databasename CHARSET=utf8;
-- 删除数据库
DROP DATABASE databasename;
-- 修改数据库
ALTER DATABASE databasename CHARACTER SET utf8;
-- 查看数据
show databases;
-- 数据库切换
use databasename;
```

### 数据类型

|    类型    |        名称        |                             备注                             |
|------------|--------------------|--------------------------------------------------------------|
| int        | 整型               |                                                              |
| double     | 浮点型             | double(5,2)表示最多五位，其中有两位是小树，最大值为999.99    |
| decimal    | 浮点型             | 不会出现精度缺失问题                                         |
| char       | 固定长度字符串类型 | char(255)，数据长度不足时补足到指定长度                      |
| varchar    | 可变长度字符串类型 | varchar(65535) 会占用字节存储实际长度                        |
| text(clob) | 字符串类型         | tinytext 2^8-1,text 2^16-1,mediumtext 2^24-1,longtext 2^32-1 |
| blob       | 字节类型           | tinyblob 2^8-1,blob 2^16-1,mediumblob 2^24-1,longblob 2^32-1 |
| date       | 日期类型           | yyyy-MM-dd                                                   |
| time       | 时间类型           | hh:mm:ss                                                     |
| tomestamp  | 时间戳类型         |                                                              |


*ps:使用blob类型时，在my.ini中配置调整允许发送的包大小*

```ini
max_allowed_packet=10485760
```

### 表操作

#### 创建和删除表

```sql
CREATE TABLE IF NOT EXISTS tablename(
    columnname int,
    columnname1 char(255)
);
DROP TABLE tablename
```

#### 查看表

```sql
show tables;
-- 查看创建语句
show create table tablename;
-- 查看表结构
desc tablename;
```

#### 修改表

* 修改表名

```sql
ALTER TABLE tablename tablename RENAME TO newtablename;
```

* 增加列

```sql
ALTER TABLE tablename ADD(
    columnname int,
    columnname1 char(20)
)
```

* 修改列类型

如果别修改列已存在数据，那么新的类型可能影响已存在的数据

```sql
ALTER TABLE tablename MODIFY columnname int;
```

* 修改列名

```sql
ALTER TABLE tablename CHANGE columnname newcolumnname int;
```

* 删除列

```sql
ALTER TABLE tablename DROP columnname;
```

### 数据操作

#### 插入

```sql
INSERT INTO tablename(columnname,columnname1) values ('value','value');
-- 与创建表时顺序相同
INSERT INTO tablename values ('value','value');
```

#### 更新

```sql
UPDATE tablename SET columnname='value',columnname1='value' where columnname='value';
```

查询条件

|          运算符          |                         备注                         |
|--------------------------|------------------------------------------------------|
| `=`                      |                                                      |
| `!=`或`<>`               |                                                      |
| `>`、`<`和`<=`、`>=`     |                                                      |
| `BETWEEN AND`            | 检查你的数据库是如何处理 BETWEEN....AND 操作符边界的 |
| `IN(...)`                |                                                      |
| `IS NULL`和`IS NOT NULL` | =NULL必返回false                                     |
| `NOT`                    |                                                      |
| `OR`和`AND`              |                                                      |


#### 删除

```sql
DELETE FROM tablename WHERE columnname = 'value';
```

#### 查询

##### 单表查询

###### 检索去重

```sql
SELECT * FROM tablename;
-- 去除重复
SELECT DISTINCT columnname FROM tablename;
```

###### 运算

```sql
SELECT columnname*1.5 FROM tablename;
-- 防止NULL值相加变成NULL
SELECT columnname+ifnull(columnname1,0) FROM tablename;
```

###### 拼接

```sql
SELECT CONCAT(columnname,'--',columnname1) as alias FROM tablename;
```

###### 模糊查询

```sql
SELECT * FROM tablename WHERE columnname LIKE 'value_';
```

| 符号 | 匹配规则      |
| :--: | :---------:   |
| _    | 匹配一个字符  |
| %    | 匹配0~n个字符 |

###### 排序

```sql
-- 默认ASC升序
SELECT * FROM tablename ORDER BY columnname ASC;
-- 多列排序
SELECT * FROM tablename ORDER BY columnname ASC,columnname1 DESC;
```

###### 聚合函数

```sql
-- 总数，列信息不为NULL则计数，*所有列不为NULL计数
SELECT COUNT(*) FROM tablename;
SELECT MIN(*) FROM tablename;
SELECT MAX(*) FROM tablename;
SELECT SUM(*) FROM tablename;
SELECT AVG(*) FROM tablename;
-- 组合使用
SELECT COUNT(*),MAX(columnname),AVG(columnname) FROM tablename;
```

###### 分组

```sql
-- 分组前条件用WHERE
-- 分组后条件用HAVING
SELECT 
    columnname,
    columnname1,
    COUNT(*),
    MAX(columnname),
    AVG(columnname2)
FROM
    tablename
WHERE
    columnname IS NOT NULL
GROUP BY columnname , columnname1
HAVING COUNT(*) > 1;
```

###### LIMIT方言

```sql
-- LIMIT begin,count
SELECT * FROM tablename LIMT 5,10;
```

##### 多表查询

###### 合并结果集
    - 两个结果集的列相同，结果在同列显示

```sql
-- 不去重
SELECT * FROM tablename
UNION ALL
SELECT * FROM tablename1
-- 去除重复
SELECT columnname FROM tablename
UNION
SELECT columnname FROM tablename1
```

###### 连接查询
    - 内连接
    - 外连接
        + 左外连接
        + 右外连接
        + 全外连接（mysql不支持）
    - 自然连接

*内连接*

必须满足两张表都有数据

```sql
-- 方言版本
SELECT * FROM tablename,tablename1 WHERE tablename.columnname = tablename1.columnname;
-- 标准版本
SELECT * FROM tablename INNER JOIN tablename1 ON tablename.columnname = tablename1.columnname;
-- 自然内连接：自动匹配两个table列名相同的列
SELECT * FROM tablename NATURAL JOIN tablename1;
```

*外连接*

外连接一主一次，左外左表为主，主表所有数据都会显示，不满足条件的右表数据为NULL

```sql
-- 左外连接
SELECT * FROM tablename LEFT OUTER JOIN tablename1 ON tablename.columnname = tablename1.columnname;
-- 右外连接
SELECT * FROM tablename RIGHT OUTER JOIN tablename1 ON tablename.columnname = tablename1.columnname;
-- 全外链接，左右表结构都在，不符合条件补NULL（mysql不支持）
SELECT * FROM tablename FULL OUTER JOIN tablename1 ON tablename.columnname = tablename1.columnname;
-- 使用合并结果集模拟全外连接
SELECT * FROM tablename LEFT OUTER JOIN tablename1 ON tablename.columnname = tablename1.columnname;
UNION
SELECT * FROM tablename RIGHT OUTER JOIN tablename1 ON tablename.columnname = tablename1.columnname;
-- 自然外连接：同自然内连接
```

###### 子查询

子查询条件组合

| 子查询结果集 |     可嵌套条件      |
|--------------|---------------------|
| 单行单列     | =、>、<、>=、<=、!= |
| 多行单列     | IN、ALL、ANY        |
| 单行多列     | 多列IN多列          |
| 多行多列     | 当作表连接查询      |

```sql
-- 单行单列
SELECT * FROM tablename WHERE columnname = (SELECT MAX(columnname) FROM tablename);
-- 多行单列
SELECT * FROM tablename WHERE columnname > ANY (SELECT columnname FROM tablename WHERE columnname1 = 'value');
SELECT * FROM tablename WHERE columnname > ALL (SELECT columnname FROM tablename WHERE columnname1 = 'value');
SELECT * FROM tablename WHERE columnname IN (SELECT columnname FROM tablename WHERE columnname1 = 'value');
-- 单行多列
SELECT * FROM tablename WHERE columnname,columnname1 IN (SELECT columnname,columnname1 FROM tablename WHERE columnname1 = 'value');
-- 多行多列 结果集为表要有别名
SELECT MAX(columnname) FROM (SELECT * FROM tablename  WHERE columnname < 'value') alias;
```

### 约束

* 非空约束
* 唯一约束
* 检查约束
* 主键约束
* 外键约束

#### 主键约束

* 非空
* 唯一
* 被引用（外键）

```sql
CREATE TABLE tablename (
    columnname INT PRIMARY KEY AUTO_INCREMENT,-- 自增长，必须整型
    columnname1 VARCHAR(20)
)

CREATE TABLE tablename (
    columnname INT,
    columnname1 VARCHAR(20),
    PRIMARY KEY (columnname)
)

ALTER TABLE tablename ADD PRIMARY KEY(columnname);
ALTER TABLE tablename DROP PRIMARY KEY;
```

#### 非空约束

```sql
CREATE TABLE tablename (
    columnname INT,
    columnname1 VARCHAR(20) NOT NULL -- 非空
)
```

#### 唯一约束

```sql
CREATE TABLE tablename (
    columnname INT,
    columnname1 VARCHAR(20) UNIQUE -- 唯一
)
```

#### 外键约束

* 外键必须是另一个表的主键（另一个表也可以是本表）
* 外键可以重复
* 外键可以为空
* 一张表可以有多个外键

```sql
CREATE TABLE tablename (
    columnname INT,
    columnname1 VARCHAR(20),
    CONSTRAINT fkname FOREIGN KEY (columnname1)
        REFERENCES tablename1 (colunmname) -- 指定外键，外键名和列名可以不同
)

ALTER TABLE tablename ADD
    CONSTRAINT fkname FOREIGN KEY (columnname1)
        REFERENCES tablename1 (colunmname)
```
##### 一对一关系

从表的主键既是外键

##### 一对多关系

普通外键表示一对多关系

##### 多对多关系

中间表两个外键映射多对多关系

### 事务

```sql
-- 开启事务
start transaction;
-- 提交事务
commit;
-- 回滚事务
rollback;
-- 查看隔离级别
SELECT @@tx_isolation;
-- 设置隔离级别isolationlevel 4选1
set transaction isolationlevel;
```

### 视图

视图是由查询结果形成的一张虚拟表，示表通过某种运算得到的一个投影

#### 作用

* 可以简化查询
* 可以进行权限控制
    - 表权限关闭，视图中放表的部分数据

#### 创建、修改和删除视图

```sql
create view view_name as select.....  
alter view view_name as select.....  
drop view view_name
```

* 视图和表同一级别，隶属于数据库
* 视图可以设定自己的字段名，通常不设置

#### 查询视图

同查询表，可以使用where

**查看所有视图**

```sql
show tables;
```

**查看视图结构**

```sql
desc view_name
```

#### 插入视图

* 视图必须包含表中没有默认值的所有列，才可以进行插入
* 一般来说，属兔只是用来查询的不应该执行增删改操作。

### 存储过程

把一段代码封装起来，当要调用这段代码时，可以通过调用储存过程实现。

* 经过一次编译后再次调用不需要再次编译
* 权限控制
* 可复用，配合数据库事务一起使用

```sql
show procedure status; --查询现有存储过程
```

#### 创建、删除存储过程

```sql
create procedure p_name(num int)
begin
...
end

drop procedure p_name;
```

#### 调用存储过程

```sql
call p_name(1);
```

#### 语句结束符

```xml
delimiter $
select * from users$
```

#### 变量

##### 会话变量

在编程环境和非编程环境都可以使用

```sql
set @var_name = 'value';
select @var_name;
```

##### 普通变量

在编程环境使用（存储过程、函数、触发器）

```sql
declare var_name type_name default default_value;
set varname = 'value';
```

##### 变量赋值

```sql
set @var_name = 表达式;
set varname = 表达式;
select @var_name := 表达式; -- 赋值并查询结果
select 表达式 into @var_name;
```

##### 系统变量

以@@开头的都是系统变量

```sql
SELECT @@version;
```

#### 运算符

略

#### 标识符

![begin_label.png](/static/img/数据库/begin_label.png "begin_label.png")

#### 条件

##### if判断

```sql
CREATE PROCEDURE p_name(num INT)
  BEGIN
    IF num = 1
    THEN
      SELECT...
    ELSEIF num = 2
      THEN
        SELECT...
    ELSE
      SELECT...
    END IF;
  END;
```

##### case判断

```sql
CREATE PROCEDURE p_name(num INT)
  BEGIN
    CASE num
      WHEN 1
      THEN
        SELECT 'spring' AS 'season';
      WHEN 2
      THEN
        SELECT 'summer' AS 'season';
      WHEN 3
      THEN
        SELECT 'autumn' AS 'season';
    ELSE SELECT '' AS 'season';
    END CASE;
  END;
```

##### loop循环

```sql
CREATE PROCEDURE p_name(num INT)
  BEGIN
    DECLARE current INT DEFAULT 1;
    DECLARE result INT DEFAULT 0;
    operate: LOOP
      SET result = current + result;
      SET current = current + 1;
      IF current > num
      THEN
        LEAVE operate;
      END IF;
    END LOOP;
    SELECT result;
  END;
```

##### while循环

```sql
CREATE PROCEDURE p_name(num INT)
  BEGIN
    DECLARE current INT DEFAULT 1;
    DECLARE result INT DEFAULT 0;
    WHILE current <= num DO

      SET result = current + result;
      SET current = current + 1;

    END WHILE;

    SELECT result;
  END;
```

##### repeat循环

```sql
CREATE PROCEDURE p_name(num INT)
  BEGIN
    DECLARE current INT DEFAULT 1;
    DECLARE result INT DEFAULT 0;
    REPEAT

      SET result = current + result;
      SET current = current + 1;

    UNTIL current > num
    END REPEAT;

    SELECT result;
  END;
```

#### 参数

* 输入参数（in，默认）
* 输出参数（out）
* 输入输出参数（inout）

```sql
CREATE PROCEDURE p_name(IN n INT, OUT result INT)
  BEGIN
    SET result = n * n;
  END;

SET @result = 0;
CALL p_name(100, @result);
SELECT @result;
```

```sql
CREATE PROCEDURE p_name(INOUT n INT)
  BEGIN
    SET n = n * n;
  END;

SET @n = 100;
CALL p_name(@n);
SELECT @n;
```

### 函数

创建的函数是隶属于库的，只能在创建函数的库中使用

* 函数内部可以有各种编程语言的元素（变量，流程控制，函数调用）
* 函数内部可以有增删改等语句
* 函数内部不可以有select、show、desc这种返回结果集的语句

#### 创建函数

```sql
CREATE FUNCTION mySum(n INT, m INT)
  RETURNS INT
  BEGIN
    RETURN m + n;
  END;

SELECT mySum(1, 2);
DROP FUNCTION mySum;
```

#### 系统函数

##### 数字

```sql
SELECT rand();

SELECT *
FROM users
ORDER BY rand()
LIMIT 2; -- 随机取出2个人

SELECT floor(3.9); -- 3
SELECT ceil(3.1); -- 4
SELECT round(3.5); -- 4 四舍五入
```

##### 字符串

```sql
-- 大小写转换
SELECT ucase('Hello');
SELECT lcase('Hello');
```

```sql
SELECT left('abcdef', 3); -- abc
SELECT right('abcdef', 3); -- def
SELECT substr('abcdef', 2, 3); -- bcd，从2开始截取3个，位置从1开始
SELECT concat('abcdef', 3); -- abcdef3
SELECT concat(USERNAME, '-', NICKNAME) FROM users;
SELECT coalesce(NULL, 123); -- 123 如果第一个值为null，就显示第二个值

SELECT length('abcdef'); -- 6
SELECT length('你好'); -- 6 字节个数
SELECT char_length('你好'); -- 2 字符个数
SELECT replace('abc','b','d'); -- adc
SELECT trim(' abc ');

-- 转义
SELECT * FROM BONUS WHERE BONUS.ENAME LIKE '%$%%' ESCAPE '$';-- 指定字符
SELECT * FROM BONUS WHERE BONUS.ENAME LIKE '%\'%';-- 默认转义为\
SELECT * FROM BONUS WHERE BONUS.ENAME LIKE '%''%';-- 是哦那个'转义'
```

##### 时间

```sql
SELECT unix_timestamp();-- 1495179836
SELECT FROM_UNIXTIME(unix_timestamp(),'%y-%m-%d');-- 17-05-19
SELECT FROM_UNIXTIME(unix_timestamp(),'%Y-%m-%d');-- 2017-05-19
SELECT curdate();-- 2017-05-19
SELECT now();-- 2017-05-19 15:44:46
SELECT
  year(now()),
  month(now()),
  day(now()),
  hour(now()),
  minute(now()),
  second(now());
SELECT datediff(now(),'1997-1-1');-- 7443天

SELECT date_sub(curdate(),INTERVAL 1 DAY);-- 2017-05-18
SELECT date_add(curdate(),INTERVAL 1 DAY);-- 2017-05-20
SELECT date_sub(curdate(),INTERVAL 1 HOUR);-- 2017-05-18 23:00:00

SELECT date_format(curdate(),'%Y-%m-%d');
SELECT str_to_date('2017-07-05 17:08:00','%Y-%m-%d %H:%i:%s');
```

##### 表达式

```sql
SELECT concat(10, if(10 % 2 = 0, '偶数', '奇数'));
```

### 触发器

* 是一个特殊的存储过程，在insert、update、delete的时候自动执行的代码块
* 触发器必须定义在特定的表上
* 自动执行，不能直接调用

目前mysql不支持多个具有同一动作、同一时间、同一事件、同一地点的触发器

#### 触发器使用

```sql
SHOW TRIGGERS;
DROP TRIGGER t_name;

-- 对于新增而言，新增的行用new来表示
CREATE TRIGGER t_name
AFTER INSERT ON orderdetails
FOR EACH ROW
  BEGIN
    UPDATE items
    SET COUNT = COUNT - NEW.COUNT
    WHERE ID = NEW.ITEM_ID;
  END;
-- 对于删除而言，删除的行用old来表示
CREATE TRIGGER t_name
AFTER DELETE ON orderdetails
FOR EACH ROW
  BEGIN
    UPDATE items
    SET COUNT = COUNT + OLD.COUNT
    WHERE ID = OLD.ITEM_ID;
  END;
-- 更新前NEW和更新后OLD
CREATE TRIGGER t_name
AFTER UPDATE ON orderdetails
FOR EACH ROW
  BEGIN
    UPDATE items
    SET COUNT = COUNT + OLD.COUNT
    WHERE ID = OLD.ITEM_ID;
    UPDATE items
    SET COUNT = COUNT - NEW.COUNT
    WHERE ID = NEW.ITEM_ID;
  END;
```

#### before和after区别

* after是先完成数据的增删改，再触发，触发器中的语句晚于监视的增删改，无法影响前面的增删改动作
* before是完成触发，再做增删改，触发的语句优于监视的增删改发生，我们有机会判断修改即将发生的操作。

```sql
CREATE TRIGGER t_name
BEFORE UPDATE ON orderdetails
FOR EACH ROW
  BEGIN
    IF NEW.COUNT > 5
    THEN
      SET NEW.COUNT = 5;
    END IF;
  END;
```

### 编码

* 查询编码

```sql
SHOW VARIABLES LIKE 'char%';
```

|        变量名         |    作用    |              备注             |
|-----------------------|------------|-------------------------------|
| character_set_client  | 客户端编码 | mysql解析客户端发送数据的编码 |
| character_set_results | 结果集编码 | mysql返回结果集的编码         |

* 修改编码

```sql
-- 只在当前窗口有效
set character_set_client=gbk;
set character_set_results=gbk;
```

```ini
# 在配置文件中修改永久有效
# 影响三个变量：client、results、connection
[mysql]

default-character-set=utf8
```

### 备份和恢复

```bat
# 备份数据库内容（结构加数据，没有数据库本身）
mysqldump -uusername -ppassword databasename>/bak.sql
# 恢复
mysql -uusername -ppassword databasename</bak.sql
# 登陆后恢复
mysql -uusername -ppassword
source /bak.sql
```

## Oracle

### 用户

默认用户

| 用户名 |    密码    |    备注   |
|--------|------------|-----------|
| sys    | 安装时设置 | as sysdba |
| system | manager    |           |
| scott  | tigger     |           |

创建用户

```sql
sqlplus / as sysdba
set linesize 300

select * from dba_users;
select * from all_users;
select * from user_users;

create user username identified by password default tablespace users;
drop user username cascade;
-- 解锁用户
alter user scott account unlock;
```

### 表空间

```sql
select username,default_tablespace from   dba_users;
select table_name from user_tables;

sqlplus sys/sys as sysdba
--创建默认表空间
create tablespace mytbs datafile '/home/oracle/oradata/data.dbf' size 300M;
--创建用户
create user mytbs identified by mytbs default tablespace mytbs;
--赋权 需访问到dba_directories
grant dba to mytbs; 


desc user_tables;
SELECT * FROM DICTIONARY;-- 数据字典表
SELECT TABLE_NAME, TABLESPACE_NAME FROM USER_TABLES;
SELECT VIEW_NAME FROM USER_VIEWS;
SELECT TABLE_NAME,CONSTRAINT_NAME FROM USER_CONSTRAINTS;
SELECT INDEX_NAME,TABLE_NAME FROM USER_INDEXES;
SELECT SEQUENCE_NAME FROM USER_SEQUENCES;
```

### 权限

#### 系统权限

* 登陆权限

```sql
grant create session to username;
```

* 创建表

```sql
grant create table to username;
```

* 表空间

```sql
grant unlimited tablespace to username;
```

* 撤销权限

```sql
revoke create table from username;
```

* 赋予所有用户权限

```sql
grant create any table to public;
```

* 查询当前用户系统权限

```sql
select * from user_sys_privs;
```

#### 对象权限

* 赋予用户对象权限

```sql
grant select on tablename to username;
grant insert on tablename to username;
grant all on tablename to username;
revoke all on tablename to username;
```

* 列权限

查询和删除不能控制到列

```sql
grant insert(columnname) on tablename to username;
grant update(columnname) on tablename to username;
```

* 查询当前用户对象权限

```sql
select * from user_tab_privs;-- 表
select * from user_clo_privs;-- 列
```

#### 权限传递

* 赋予用户权限，被赋权限用户可以继续赋予其他用户

```sql
grant select on tablename to username with admin option;
grant alter any table to username with admin option;
grant select on tablename to username with grant option;
```

### 角色

```sql
create role rolename;
grant create session to rolename;
grant rolename to username;
-- 有些权限无法赋给角色，如unlimited tablespace
drop role rolename;
```

### 登陆验证机制

* 操作系统验证(首先采用)
* 密码文件验证
* 数据库验证

* 启动过程

linux

```shell
# new version
lsnrctl start
sqlplus sys/oracle as sysdba
startup
# old version
lsnrctl start
sqlplus /nolog
conn sys/oracle as sysdba
startup
```

windows

```bat
lsnrctl start
oradmin -startup -sid orcl
```

* 修改密码

```sql
alter user username identified by password;
```

### 表操作

```sql
CREATE TABLE tablename AS SELECT * FROM tablename1; -- 创建表并复制数据
INSERT INTO tablename (SELECT * FROM tablename1);
DROP TABLE tablename

ALTER TABLE tablename ADD (id NUMBER);
ALTER TABLE tablename MODIFY (id VARCHAR(10));
ALTER TABLE tablename DROP COLUMN ID;
ALTER TABLE tablename ADD CONSTRAINT pk_tablename PRIMARY KEY (id);
ALTER TABLE TABLENAME ADD CONSTRAINT fk_tablename FOREIGN KEY (EMPNO) REFERENCES EMP(EMPNO);
ALTER TABLE tablename DROP CONSTRAINT pk_tablename;

SELECT * FROM tablename;
DELETE FROM tablename;
```

### 索引

增加了查询效率，降低了插入效率

```sql
CREATE INDEX idx_tablename_columnname ON TABLENAME (columnname)
```

### 序列

```sql
CREATE SEQUENCE SEQUENCE_NAME;

SELECT SEQUENCE_NAME.nextval FROM dual;
SELECT SEQUENCE_NAME.currval FROM dual;

SELECT SEQUENCE_NAME FROM USER_SEQUENCES;
```

### 字符串

```sql
select to_char(sal,'999,999,999.99') FROM EMP;-- 2,975.00
select to_char(sal,'L999,999,999.99') FROM EMP;-- ￥2,975.00
select to_char(sal,'000000.00') FROM EMP;-- 002975.00
select to_number('002975.00','000000.00') FROM dual;-- 2975
```

```sql
select col1 || col2 from tablename;
-- 两个引号转义成一个引号
select 'a' || 'b''c' from dual;-- abc
```

```sql
-- 指定转义字符
SELECT * FROM BONUS WHERE BONUS.ENAME LIKE '%$%%' ESCAPE '$';
-- 使用'转义'
SELECT * FROM BONUS WHERE BONUS.ENAME LIKE '%''%';
```

### 组函数

```sql
SELECT max(SAL) FROM EMP;
SELECT min(SAL) FROM EMP;
SELECT avg(SAL) FROM EMP;
SELECT round(avg(SAL),2) FROM EMP;-- 四舍五入两位
SELECT sum(SAL) FROM EMP;
SELECT count(*) FROM EMP;-- 非空字段
SELECT count(DISTINCT JOB) FROM EMP;

-- 不使用组函数获取最大值
SELECT
  SAL
FROM (
  SELECT
    ROWNUM ,
    EMP.*
  FROM EMP ORDER BY SAL DESC
) t WHERE ROWNUM <2
```

### 分组

```sql
SELECT JOB,count(*) FROM EMP GROUP BY JOB;
SELECT JOB,DEPTNO,count(*) FROM EMP GROUP BY JOB,DEPTNO;
SELECT ENAME FROM EMP WHERE COMM = (SELECT max(COMM) FROM EMP);

SELECT DEPTNO,avg(COMM) AVG_COMM FROM EMP 
WHERE JOB!='KING' GROUP BY DEPTNO 
HAVING avg(COMM)>350 ORDER BY AVG_COMM DESC
```

### 子查询

```sql
-- 查询每个部分薪水最高的员工和薪水
SELECT
  EMP.ENAME,
  SAL,
  t.DEPTNO
FROM EMP, (SELECT
             DEPTNO,
             MAX(SAL) MAXSAL
           FROM EMP
           GROUP BY DEPTNO) t
WHERE EMP.DEPTNO = t.DEPTNO AND EMP.SAL = t.MAXSAL

-- 查询部门平均薪资等级
SELECT
  SALGRADE.GRADE,
  t.DEPTNO,
  t.AVGSAL
FROM SALGRADE
  JOIN
  (SELECT
     DEPTNO,
     avg(SAL) AVGSAL
   FROM EMP
   GROUP BY DEPTNO) t ON
                        t.AVGSAL > SALGRADE.LOSAL AND t.AVGSAL < SALGRADE.HISAL;

-- 查询领导姓名
SELECT
  t1.EMPNO,
  t1.ENAME,
  t2.ENAME MGRNAME
FROM EMP t1, EMP t2
WHERE t1.MGR = t2.EMPNO;

-- 部门员工薪水等级的平均值
SELECT
  avg(GRADE),
  DEPTNO
FROM (
       SELECT
         DEPTNO,
         SALGRADE.GRADE
       FROM EMP
         LEFT JOIN SALGRADE ON EMP.SAL BETWEEN SALGRADE.LOSAL AND SALGRADE.HISAL) t
GROUP BY DEPTNO

-  不使用组函数获取最大值
SELECT SAL
FROM EMP
WHERE EMP.SAL NOT IN (
  SELECT DISTINCT e1.SAL
  FROM EMP e1, EMP e2
  WHERE e1.SAL < e2.SAL)

-- 平均薪水最高的部门
SELECT
  DEPTNO
FROM EMP
GROUP BY DEPTNO
HAVING avg(SAL) = (
  SELECT max(AVGSAL)
  FROM (
    SELECT
      DEPTNO,
      avg(SAL) AVGSAL
    FROM EMP
    GROUP BY DEPTNO
  )
)

SELECT DEPTNO
FROM (SELECT
        DEPTNO,
        avg(SAL) AVGSAL
      FROM EMP
      GROUP BY DEPTNO)
WHERE AVGSAL = (
  SELECT max(AVGSAL)
  FROM (
    SELECT
      DEPTNO,
      avg(SAL) AVGSAL
    FROM EMP
    GROUP BY DEPTNO
  )
)
```

### 空值

```sql
SELECT nvl(COMM, 0) FROM EMP;
```

### 时间

```sql
select sysdate from dual
SELECT to_date('1992-2-2','yyyy-MM-dd') FROM dual;
SELECT to_char(sysdate,'yyyy-MM-dd') FROM dual;
```

### 分页

```sql
-- 第一层：获取数据物理地址
-- 第二层：取得最大页数
-- 第三层：取得最小页数
-- 第四层：因为取得的页数都是物理地址，再根据物理地址，插叙出具体数据

--rowid分页，第一步
SELECT
  rowid rid
FROM emp
ORDER BY sal DESC;
--rowid分页，第二步
SELECT
  rownum rn,
  rid
FROM (SELECT
        rowid rid
      FROM emp
      ORDER BY sal DESC)
WHERE rownum < 10;
--rowid分页，第三步
SELECT rid
FROM (SELECT
        rownum rn,
        rid
      FROM (SELECT
              rowid rid
            FROM emp
            ORDER BY sal DESC)
      WHERE rownum < 10)
WHERE rn > 5;
--rowid分页，第四步
SELECT *
FROM emp
WHERE rowid IN (SELECT rid
                FROM (SELECT
                        rownum rn,
                        rid
                      FROM (SELECT
                              rowid rid
                            FROM emp
                            ORDER BY sal DESC)
                      WHERE rownum < 10)
                WHERE rn > 5);
```

### 修改编码

```shell
shutdown immediate;
startup mount;
ALTER SYSTEM ENABLE RESTRICTED SESSION;
ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;
ALTER SYSTEM SET AQ_TM_PROCESSES=0;
alter database open;
alter database character set INTERNAL_USE UTF8;
shutdown immediate;
startup;
exit;
```

### 备份还原

```shell
export ORACLE_SID=orcl
export ORACLE_HOME=/oracle/product/11gR1/db
export PATH=$PATH:.:/oracle/product/11gR1/db/bin

# 整个库备份还原
expdp system/manager DIRECTORY=dpdata1 DUMPFILE=full.dmp FULL=y;
impdb system/manager DIRECTORY=dump_dir DUMPFILE=full.dmp FULL=y;
```

### ORA错误

#### ORA-00845

```shell
mount -o size=2G -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm
```

## 三范式

* 列不可分
* 要有主键，不能存在部分依赖，确保表中的每列都和主键相关（多对多关系拆分成三张表，防止非主键列部分依赖主键）
* 非主键列必须直接依赖于主键，不能存在传递依赖，（避免查询路径过长而导致询问时间过长或者更新异常）

## 行转列

### 静态拼接行转列

```sql
SELECT DISTINCT
  PRODID             AS ID,
  sum(CASE WHEN color = 'r'
    THEN COUNTS END) AS red,
  sum(CASE WHEN color = 'b'
    THEN COUNTS END) AS blue,
  sum(CASE WHEN color = 'y'
    THEN COUNTS END) AS yellow
FROM
  PROD
GROUP BY PRODID;
```

## 优化

* 表建立索引
* 查询时最左索引原则（索引列条件靠近where）

------

*以上概念总结于传智播客JavaWeb课程*