---
layout: post
title: JVM精华
tags: Java基础 JVM
categories: Java
published: true
---

[TOC]

## Java优点

* 它摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想
* 它提供了一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题
* 它实现了热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而获得更高的性能
* 它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能

## Java技术体系

### 成员

* Java程序设计语言
* 各种硬件平台上的Java虚拟机
* Class文件格式
* Java API类库
* 来自商业机构和开源社区的第三方Java类库

#### JDK,JRE,JVM的作用及关系

**作用**

* JVM：保证Java语言跨平台
* JRE：Java程序的运行环境
* JDK：Java程序的开发环境

**关系**

> Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK  
> 把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE  

* JRE：JVM+类库
* JDK：JRE+工具

#### JVM跨平台原理图

![title](/static/img/Java基础第一课精华总结/Java语言跨平台原理图解.bmp "title")

* JVM在虚拟机曾买呢隐藏了低层技术的复杂性以及机器与操作系统的差异
* 为了达到给所有硬件提供一致的虚拟机平台的目的，牺牲了一些与硬件相关的性能特性
* 如果开发人员不了解虚拟机的一些技术特性和运行原理，就无法写出最适合虚拟机运行和自优化的

##### 编译运行

* 高版本的Java能运行低版本的Javac编译的程序
* 低版本的Java不能运行高版本的Javac编译的程序

## 自动内存管理机制

### 运行时数据区

![运行时数据区](/static/img/jvm/Runtime-Data-area.png "运行时数据区")

* 线程隔离
	- 程序计数器
	- Java虚拟机栈
	- 本地方法栈
* 线程共享
	- Java堆
	- 方法区
		+ 运行时常量池
* 直接内存

#### 程序计数器

> 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。  
> 在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。


* 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；
* 如果正在执行的是Native方法，这个计数器值则为空（Undefined）。

**异常**

* 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

#### Java虚拟机栈

> Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。  
> 虚拟机栈描述的是Java方法执行的内存模型：  
>> 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。  
>> 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  

**局部变量表数据**

> 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

* 基本数据类型
	- boolean、byte、char、short、int、float、long、double
		+ 64位长度的long和double类型的数据会占用2个局部变量空间
* 对象引用（reference类型）
	- 它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置
* returnAddress类型
	- 指向了一条字节码指令的地址

**异常**

* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
* 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常

#### 本地方法栈

> 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法  
> 虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一

**异常**

* 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常

#### Java堆

> 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。  
> Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配  
> 但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

*Tips：Java堆是垃圾收集器管理的主要区域*  
*Tips：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可*  

**异常**

* 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

#### 方法区

> 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

**方法区实现**

> HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。  
> 永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题）

*Tips：JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出*  
*Tips：JDK 1.8的HotSpot中，已经使用Metaspace取代了PermGen*  

**异常**

* 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

#### 运行时常量池

> 运行时常量池（Runtime Constant Pool）是方法区的一部分  
> 常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

*Tips：Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。*

**异常**

* 运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常

#### 直接内存

> 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域  

>  在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。  
>  这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

**异常**

* 本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制
* 在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

### HotSpot虚拟机对象探秘

HotSpot虚拟机在Java堆中对象分配、布局和访问

#### 对象的创建

对象（普通Java对象，不包括数组和Class对象等）的创建过程

* 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
* 在类加载检查通过后，接下来虚拟机将为新生对象分配内存
	- 分配方式
		+ 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）
		+ 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）
	- 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
		+ 使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞
		+ 使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表
	- 线程安全问题
		+ 一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
		+ 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）
* 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行
	- 保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值
* 接下来，虚拟机要对对象进行必要的设置
	- 如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息
	- 这些信息存放在对象的对象头（Object Header）中
* 执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来

#### 对象的内存布局

HotSpot虚拟机对象在内存中存储的布局可以分为3块区域

* 对象头（Header）
* 实例数据（Instance Data）
* 对齐填充（Padding）

##### 对象头

* 第一部分用于存储对象自身的运行时数据
	- 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
	- 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit
	- 官方称它为“Mark Word”
* 另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
	- 并不是所有的虚拟机实现都必须在对象数据上保留类型指针（使用句柄）
	- 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小

##### 实例数据

* 对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来
	- 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响

##### 对齐填充

* 对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用
	- 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

#### 对象的访问定位

Java程序需要通过栈上的reference数据来操作堆上的具体对象

> reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置  
> 所以对象访问方式也是取决于虚拟机实现而定的。  
> 目前主流的访问方式有使用句柄和直接指针两种。  

##### 句柄

![句柄](/static/img/jvm/handle.png "句柄")

**好处**

* 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改

##### 指针

![指针](/static/img/jvm/pointer.png "指针")

**好处**

* 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销


### OutOfMemoryError异常

#### Java堆溢出

> Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

```java
// VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
public class HeapOOM {
    static class OOMObject {}
    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
// java.lang.OutOfMemoryError: Java heap space
// Dumping heap to java_pid5124.hprof ...
// Heap dump file created [28375534 bytes in 0.096 secs]
// Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```

> 一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）  
> 
> 如果是**内存泄露**，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。  
> 
> 如果**不存在泄露**，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

#### 虚拟机栈和本地方法栈溢出

> 由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定

```java
/***
 * VM Args: -Xss128k
 * 1.使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。(当前示例)
 * 2.定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。
 */
public class JavaVMStackSOF {
    private int stackLength = 1;
    private void stackLeak() {
        stackLength++;
        stackLeak();// 这里申请栈空间
    }
    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length：" + oom.stackLength);
            throw e;
        }
    }
}
// stack length：990
// Exception in thread "main" java.lang.StackOverflowError
```

#### 方法区和运行时常量池溢出

##### 运行时常量池

> 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量  
> JDK 1.7开始逐步“去永久代”的事情，while循环会一直进行下去

```java
// VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        //使用List保持着常量池引用，避免Full GC回收常量池行为
        List<String> list = new ArrayList<String>();
        // 10MB的PermSize在integer范围内足够产生OOM了
        int i = 0;
        while (true) {
        	// String.intern()是一个Native方法
        	// 如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象
        	// 否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用
            list.add(String.valueOf(i++).intern());
        }
    }
}
// Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
//    at java.lang.String.intern(Native Method)
//    at RuntimeConstantPoolOOM1.main(RuntimeConstantPoolOOM1.java:11)
```

> 这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。  
> 产生差异的原因是：
>> 在JDK 1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。  
>> 
>> 而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。  
>> 
>> 对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过（换成其他字符串会返回true），字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。

```java
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        String str1 = new StringBuilder("计算机").append("软件").toString();
        System.out.println(str1.intern() == str1);
        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2.intern() == str2);
    }
}
```

##### 方法区

> 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出  
> JDK 8 中PermGen部分内存空间将全部移除，JVM的参数：PermSize 和 MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）  
> 取而代之的是Metaspace，默认情况下，大部分类元数据都在本地内存中分配，类元数据只受可用的本地内存限制，新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。

```java
// before 1.8：VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
// after 1.8：VM Args: -XX:MaxMetaspaceSize=10M
public class JavaMethodAreaOOM {
    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                    return proxy.invokeSuper(obj, args);
                }
            });
            enhancer.create();
        }
    }
    static class OOMObject {
        public void test(){}
    }
}
// before 1.8： Caused by: java.lang.OutOfMemoryError: PermGen space
// after 1.8： Exception in thread "main" java.lang.OutOfMemoryError: Metaspace
```

#### 本机直接内存溢出

> DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样  
> 手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。

```java
// VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
public class DirectMemoryOOM {
    private static final int _1MB = 1024 * 1024;
    public static void main(String[] args) throws Exception {
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }
}
// Exception in thread "main" java.lang.OutOfMemoryError
```

> 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

## 垃圾收集器与内存分配策略

> 当需要排查各种内存溢出、内存泄漏问题时  
> 当垃圾收集成为系统达到更高并发量的瓶颈时  
> 我们就需要对这些“自动化”的技术实施必要的监控和调节

* 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，方法结束或者线程结束时，内存自然就跟随着回收
* Java堆和方法区只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存

### 对象是否应该被回收

#### 引用

在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

* 强引用
	- 是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用
	- 是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
* 弱引用
	- 是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
* 虚引用
	- 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。

#### 引用计数法

> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的  
> 引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法  
> 但是主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题

#### 可达性分析法

> 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的

Java语言中，可作为GC Roots的对象包括下面几种

* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）引用的对象。

#### 回收前的两次标记

两次标记

1. 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
	* 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
2. finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。
	* 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。
	* finalize()方法只要重新与引用链上的任何一个对象建立关联，就可以避免被回收，但是只能避免一次，因为finalize()方法只会被系统自动调用一次

#### 回收方法区

> Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低  
> 在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

* 废弃常量
	- 没有任何String对象引用常量池中的常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个常量就会被系统清理出常量池
	- 常量池中的其他类（接口）、方法、字段的符号引用也与此类似
* 无用的类
	- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
	- 加载该类的ClassLoader已经被回收。
	- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
	- 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。
		+ 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。
		+ 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

### 垃圾收集算法

#### 标记-清除算法

> 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在《对象是否应该被回收》讲述对象标记判定时已经介绍过了

**缺点**

* 一个是效率问题，标记和清除两个过程的效率都不高
* 另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

![Mark-Clear](/static/img/jvm/Mark-Clear.png "Mark-Clear")

#### 复制算法

> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。  
> 这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效

**缺点**

* 代价是将内存缩小为了原来的一半，未免太高了一点
* 在对象存活率较高时就要进行较多的复制操作，效率将会变低

> 新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。  
> 
> 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。  
> 
> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，只有10%的内存会被“浪费”  
> 
> 当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion），这些对象将直接通过分配担保机制进入老年代

![copy](/static/img/jvm/copy.png "copy")

#### 标记-整理算法

> 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

![Mark-Finishing](/static/img/jvm/Mark-Finishing.png "Mark-Finishing")

#### 分代收集算法

> 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。  
>> 在**新生代**中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。  
>> 而**老年代**中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。  

### HotSpot的算法实现

#### 枚举根节点

> 从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。  
> 
> 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因  
> 
> HotSpot的实现中，是使用一组称为OopMap的数据结构来直接得知哪些地方存放着对象引用的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举


#### 安全点

> 可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。  
> 
> HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。  
> 
> 安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。  

---

> 另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：
> 
>> 抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）  
>
> 其中**抢先式中断**不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。  
> 
> 而**主动式中断**的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方

#### 安全区域

> 没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决  
> 
> **安全区域**是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。  
> 
> 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。

### 垃圾收集器

HotSpot虚拟机的垃圾收集器：

![7GC](/static/img/jvm/7GC.png "7GC")

* 如果两个收集器之间存在连线，就说明它们可以搭配使用。
* 虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。

#### Serial收集器

> 它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束  
> 采用单线程和复制算法

Serial/Serial Old收集器运行示意图：

![serial](/static/img/jvm/serial.png "serial")

Serial收集器是虚拟机运行在Client模式下的默认新生代收集器  
在用户的桌面应用场景中，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。  
它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。  

#### ParNew收集器

> ParNew收集器其实就是Serial收集器的多线程版本  
> 采用多线程和复制算法

ParNew/Serial Old收集器运行示意图：

![ParNew](/static/img/jvm/ParNew.png "ParNew")

是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作  

#### Parallel Scavenge收集器（“吞吐量优先”收集器）

> Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）  
> 采用多线程和复制算法  
> 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）  
> CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。
>> ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它

Parallel Scavenge/Parallel Old收集器运行示意图：

![Scavenge](/static/img/jvm/Scavenge.png "Scavenge")

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

* 控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数
* 设置吞吐量大小的-XX:GCTimeRatio参数

**GC自适应的调节策略（GC Ergonomics）**

> -XX:+UseAdaptiveSizePolicy是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量

#### Serial Old收集器

> 主要意义也是在于给Client模式下的虚拟机使用  
> 采用单线程和标记-整理算法  
> 如果在Server模式下，那么它主要还有两大用途：
>> 一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用  
>> 另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

Serial/Serial Old收集器运行示意图：

![serial](/static/img/jvm/serial.png "serial")

#### Parallel Old收集器

> Parallel Old是Parallel Scavenge收集器的老年代版本  
> 采用用多线程和标记-整理算法  
> 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器

Parallel Scavenge/Parallel Old收集器运行示意图：

![Scavenge](/static/img/jvm/Scavenge.png "Scavenge")

#### CMS收集器

> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器  
> 采用用多线程和标记-清除算法
> 第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作  

**步骤**

* 初始标记（CMS initial mark）
	- 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
* 并发标记（CMS concurrent mark）
	- 并发标记阶段就是进行GC RootsTracing的过程
* 重新标记（CMS remark）
	- 重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短
* 并发清除（CMS concurrent sweep）

> 初始标记、重新标记这两个步骤仍然需要“Stop The World”  
> 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的

Concurrent Mark Sweep收集器运行示意图：

![CMS](/static/img/jvm/CMS.png "CMS")

**缺点**

* CMS收集器对CPU资源非常敏感
	- 并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低
		+ CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大
* CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生
	- 由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”
	- 也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败
		+ 在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活
		+ 可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能
		+ 在JDK 1.6中，CMS收集器的启动阈值已经提升至92%
		+ 出现失败时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了
* 基于“标记—清除”算法实现意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC
	- CMS收集器提供了-XX:+UseCMSCompactAtFullCollection参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长
	- 另一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）

#### G1收集器

> G1是一款面向服务端应用的垃圾收集器  
> 降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒  
> HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器

**特点**

* 并行与并发
	- 使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行
* 分代收集
	- G1可以不需要其他收集器配合就能独立管理整个GC堆
	- 分代概念在G1中依然得以保留。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果
* 空间整合
	- G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC
* 可预测的停顿
	- 降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了

G1收集器运行示意图 ：

![G1](/static/img/jvm/G1.png "G1")

**可预测的停顿时间保证：**

> 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。
> 使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。  
> 
> G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
> G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。  
> 
> 这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

**跨Region和跨代引用问题：**

> 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。  
> 
> G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），
> 如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

**步骤**

* 初始标记（Initial Marking）
	- 初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象
	- 这阶段需要停顿线程，但耗时很短
* 并发标记（Concurrent Marking）
	- 并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象
	- 这阶段耗时较长，但可与用户程序并发执行。
* 最终标记（Final Marking）
	- 而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中
	- 这阶段需要停顿线程，但是可并行执行。
* 筛选回收（Live Data Counting and Evacuation）
	- 筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划
	- 从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率

**总结**

> 如果你现在采用的收集器没有出现问题，那就没有任何理由现在去选择G1  
> 如果你的应用追求低停顿，那G1现在已经可以作为一个可尝试的选择  
> 如果你的应用追求吞吐量，那G1并不会为你带来什么特别的好处

#### 垃圾收集器参数

|              参数              |                                                                        描述                                                                       |
|--------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收                                                     |
| UseParNewGC                    | 打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收                                                                                       |
| UseConcMarkSweepGC             | 打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS Mark Sweep）的收集器组合进行内存回收                         |
| UseParallelOldGC               | 打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收                                                                          |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1                                                                          |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配                                                                  |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄。每个对象在坚持过一次MinorGC之后，年龄就加1，当超过这个参数值时就进入老年代                                                |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄                                                                                                |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况                                          |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                                                                                                                  |
| GCTimeRatio                    | GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效                                                         |
| MaxGCPauseMillis               | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效                                                                                       |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效                                                           |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效                                                                  |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效                                                                |

### 内存分配与回收策略

自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存

> 对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置

#### 对象优先在Eden分配

> 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

**Minor GC和Full GC**

* 新生代GC（Minor GC）
	- 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
* 老年代GC（Major GC/Full GC）
	- 指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

```java
private static final int _1MB = 1024 * 1024;
// VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC
public static void main(String args[]) {
    byte[] allocation1, allocation2, allocation3, allocation4;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[2 * _1MB];
    allocation4 = new byte[4 * _1MB];//出现一次Minor GC
}
```

```
[GC [DefNew: 7301K->232K(9216K), 0.0039581 secs] 7301K->6376K(19456K), 0.0039897 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4821K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  56% used [0x00000000f9a00000, 0x00000000f9e7b670, 0x00000000fa200000)
  from space 1024K,  22% used [0x00000000fa300000, 0x00000000fa33a000, 0x00000000fa400000)
  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)
 tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3576K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  16% used [0x00000000fae00000, 0x00000000fb17f788, 0x00000000fb17f800, 0x00000000fc2c0000)
No shared spaces configured.
```

> 尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xms20M、-Xmx20M、-Xmn10M这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。  
> -XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果也可以清晰地看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量）
> 
> 分配allocation4对象的语句时会发生一次Minor GC，这次GC的结果是新生代6651KB变为148KB，而总内存占用量则几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。  
> 这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。  
> GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。

*注意事项：JDK1.8中指定虚拟机为Serial时，采用与1.6相同的垃圾回收器，并且1.8中的结果会与上面的结果不同，因为在allocation3分配时，Eden空间就无法满足分配后触发GC，1和2进入老年代，4直接在Eden空间分配*

```
[GC (Allocation Failure) [DefNew: 6399K->797K(9216K), 0.0043058 secs] 6399K->4893K(19456K), 0.0043560 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 7180K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  77% used [0x00000000fec00000, 0x00000000ff23bf18, 0x00000000ff400000)
  from space 1024K,  77% used [0x00000000ff500000, 0x00000000ff5c7418, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000)
 Metaspace       used 3452K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K
No shared spaces configured.
```

#### 大对象直接进入老年代

> 所谓的**大对象**是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）

*注意事项：经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。*

> 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制

*注意事项：PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合*

```java
private static final int _1MB = 1024 * 1024;

// VM参数:-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728 -XX:+UseSerialGC
public static void main(String args[]) {
    byte[] allocation;
    allocation = new byte[4 * _1MB];//直接分配在老年代中
}
```

```
Heap
 def new generation   total 9216K, used 1321K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  16% used [0x00000000f9a00000, 0x00000000f9b4a4b8, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3458K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  16% used [0x00000000fae00000, 0x00000000fb160970, 0x00000000fb160a00, 0x00000000fc2c0000)
No shared spaces configured.
```

> Eden空间几乎没有被使用，而老年代的10MB空间被使用了40%，也就是4MB的allocation对象直接就分配在老年代中，这是因为PretenureSizeThreshold被设置为3MB（就是3145728，这个参数不能像-Xmx之类的参数一样直接写3MB），因此超过3MB的对象都会直接在老年代进行分配

#### 长期存活的对象将进入老年代

> 虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1  
> 对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置

```java
private static final int _1MB = 1024 * 1024;
// VM参数:-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution -XX:+UseSerialGC
public static void main(String args[]) {
    byte[] allocation1, allocation2, allocation3;
    allocation1 = new byte[_1MB / 4];//什么时候进入老年代取决于XX:MaxTenuringThreshold设置
    allocation2 = new byte[4 * _1MB];
    allocation3 = new byte[4 * _1MB];// 第一次GC
    allocation3 = null;
    allocation3 = new byte[4 * _1MB];// 第二次GC
}
```

```
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:     499792 bytes,     499792 total
: 5397K->488K(9216K), 0.0035176 secs] 5397K->4584K(19456K), 0.0035437 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:        136 bytes,        136 total
: 4996K->0K(9216K), 0.0006436 secs] 9092K->4583K(19456K), 0.0006594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4234K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  51% used [0x00000000f9a00000, 0x00000000f9e22858, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200088, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4583K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  44% used [0x00000000fa400000, 0x00000000fa879f50, 0x00000000fa87a000, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3715K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  17% used [0x00000000fae00000, 0x00000000fb1a0f28, 0x00000000fb1a1000, 0x00000000fc2c0000)
No shared spaces configured.
```

> allocation1对象需要256KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1对象在第二次GC发生时进入老年代，新生代Survivor(from、to)已使用的内存GC后非常干净地变成0KB

MaxTenuringThreshold=15情况：

```
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:     496952 bytes,     496952 total
: 5397K->485K(9216K), 0.0044452 secs] 5397K->4581K(19456K), 0.0044792 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:        816 bytes,        816 total
- age   2:     496680 bytes,     497496 total
: 4993K->485K(9216K), 0.0009782 secs] 9089K->4581K(19456K), 0.0010121 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4719K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  51% used [0x00000000f9a00000, 0x00000000f9e22800, 0x00000000fa200000)
  from space 1024K,  47% used [0x00000000fa200000, 0x00000000fa279758, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3501K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  16% used [0x00000000fae00000, 0x00000000fb16c3d8, 0x00000000fb16c400, 0x00000000fc2c0000)
No shared spaces configured.
```

> allocation1对象则还留在新生代Survivor空间，这时新生代仍然有485KB被占用

*注意事项：JDK 8中MaxTenuringThreshold第一次GC后的新值为1，因为第一次GC后《动态对象年龄判定》Survivor空间对象超过50%已经可以进入老年代*

```
// 仅第一次GC
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:    1048080 bytes,    1048080 total
: 6844K->1023K(9216K), 0.0034564 secs] 6844K->5119K(19456K), 0.0035184 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 5365K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  53% used [0x00000000fec00000, 0x00000000ff03d8a0, 0x00000000ff400000)
  from space 1024K,  99% used [0x00000000ff500000, 0x00000000ff5ffe10, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)
 Metaspace       used 3210K, capacity 4568K, committed 4864K, reserved 1056768K
  class space    used 348K, capacity 392K, committed 512K, reserved 1048576K
```

```
// 包含第二次GC
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:    1048080 bytes,    1048080 total
: 6844K->1023K(9216K), 0.0044796 secs] 6844K->5119K(19456K), 0.0045626 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
: 5283K->0K(9216K), 0.0012891 secs] 9379K->5048K(19456K), 0.0013116 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4260K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0290e0, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 5048K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  49% used [0x00000000ff600000, 0x00000000ffaee170, 0x00000000ffaee200, 0x0000000100000000)
 Metaspace       used 3210K, capacity 4568K, committed 4864K, reserved 1056768K
  class space    used 348K, capacity 392K, committed 512K, reserved 1048576K
```

#### 动态对象年龄判定

> 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

```java
private static final int _1MB = 1024 * 1024;
// VM参数: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:+PrintTenuringDistribution -XX:+UseSerialGC
public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3, allocation4;
    allocation1 = new byte[_1MB / 4];
    //allocation1+allocation2大于survivor空间一半
    allocation2 = new byte[_1MB / 4];
    allocation3 = new byte[4 * _1MB];
    allocation4 = new byte[4 * _1MB];
    allocation4 = null;
    allocation4 = new byte[4 * _1MB];
}
```

```
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:     762304 bytes,     762304 total
: 5765K->744K(9216K), 0.0046013 secs] 5765K->4840K(19456K), 0.0046325 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:        904 bytes,        904 total
: 5252K->0K(9216K), 0.0009896 secs] 9348K->4841K(19456K), 0.0010106 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4234K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  51% used [0x00000000f9a00000, 0x00000000f9e22798, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200388, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4840K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  47% used [0x00000000fa400000, 0x00000000fa8ba0c0, 0x00000000fa8ba200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3717K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  17% used [0x00000000fae00000, 0x00000000fb1a14e0, 0x00000000fb1a1600, 0x00000000fc2c0000)
No shared spaces configured.
```

> 运行结果中Survivor的空间占用仍然为0%，而老年代比预期增加了7%，也就是说，allocation1、allocation2对象都直接进入了老年代，而没有等到15岁的临界年龄。  
> 因为这两个对象加起来已经到达了512KB，并且它们是同年的，满足同年对象达到Survivor空间的一半规则。  
> 我们只要注释掉其中一个对象new操作，就会发现另外一个就不会晋升到老年代中去了

#### 空间分配担保

> 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的  
> 如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败  
>> 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小  
>>> 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的  
>>> 如果小于，那这时也要改为进行一次Full GC  
>>
>> 如果不允许冒险，那这时也要改为进行一次Full GC  
>
>JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC

```java
private static final int _1MB = 1024 * 1024;
// VM参数:-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure -XX:+UseSerialGC
public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[2 * _1MB];
    allocation1 = null;
    allocation4 = new byte[2 * _1MB];
    allocation5 = new byte[2 * _1MB];
    allocation6 = new byte[2 * _1MB];
    allocation4 = null;
    allocation5 = null;
    allocation6 = null;
    allocation7 = new byte[2 * _1MB];
}
```

以HandlePromotionFailure=false参数来运行的结果：

```
[GC[DefNew：6651K-＞148K（9216K），0.0078936 secs]6651K-＞4244K（19456K），0.0079192 secs][Times：user=0.00 sys=0.02，real=0.02 secs]
[GC[DefNew：6378K-＞6378K（9216K），0.0000206secs][Tenured：4096K-＞4244K（10240K），0.0042901 secs]10474K-＞4244K（19456K），[Perm：2104K-＞2104K（12288K）]，0.0043613 secs][Times：user=0.00 sys=0.00，real=0.00 secs]
```

以HandlePromotionFailure=true参数来运行的结果（或者6u24以后的JDK）：

```
[GC [DefNew: 7301K->232K(9216K), 0.0040194 secs] 7301K->4328K(19456K), 0.0040549 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[GC [DefNew: 6880K->231K(9216K), 0.0005393 secs] 10976K->4328K(19456K), 0.0005566 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 2417K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  26% used [0x00000000f9a00000, 0x00000000f9c22500, 0x00000000fa200000)
  from space 1024K,  22% used [0x00000000fa200000, 0x00000000fa239ff8, 0x00000000fa300000)
  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
 tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800020, 0x00000000fa800200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 3692K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  17% used [0x00000000fae00000, 0x00000000fb19b1b8, 0x00000000fb19b200, 0x00000000fc2c0000)
No shared spaces configured.
```

## 虚拟机性能监控与故障处理工具

### JDK的命令行工具

|  名称  |                                                  主要作用                                                  |
|--------|------------------------------------------------------------------------------------------------------------|
| jps    | JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程                                              |
| jstat  | JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据                                       |
| jinfo  | Configuration Info for Java，显示虚拟机配置信息                                                            |
| jmap   | Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）                                              |
| jhat   | JVM Heap Dump Brower,用于分析heap dump文件，它会建立一个HTTP？HTML服务器，让用户可以在浏览器上查看分析结果 |
| jstack | Stack Trace for Java。显示虚拟机的线程快照                                                                 |

#### jps：虚拟机进程状况工具

> 可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）

jps命令格式：

```shell
jps [options] [hostid]
```

| 属性 |                        作用                        |
|------|----------------------------------------------------|
| -p   | 只输出LVMID，省略主类的名称                        |
| -m   | 输出虚拟机进程启动时传递给主类main()函数的参数     |
| -l   | 输出主类的全名，如果进程执行的是jar包，输出jar路径 |
| -v   | 输出虚拟机进程启动时jvm参数                        |

```shell
jps -q
jps -lvm
```

#### jstat：虚拟机统计信息监视工具

> 用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程[1]虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据

jstat命令格式：

```shell
jstat [ option vmid [interval[s|ms] [count]] ]

如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是

[protocol:][//]lvmid[@hostname[:port]/servername]

需要远程主机提供RMI支持，Sun提供的jstatd工具可以很方便地建立远程RMI服务器。
```

|                  选项                  |                                             作用                                             |
|----------------------------------------|----------------------------------------------------------------------------------------------|
| -class                                 | 监视装载类、卸载类、总空间以及类装载所耗费的时间                                             |
| -gc                                    | 监视java堆状况，包括eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计信息 |
| -gccapacity                            | 监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到最大、最小空间                      |
| -gcutil                                | 监视内容与-gc基本相同，但输出主要关注已使用控件占总空间的百分比                              |
| -gccause                               | 与-gcutil功能一样，但是会额外输出导致上一次gc产生的原因                                      |
| -gcnew                                 | 监视新生代GC情况                                                                             |
| -gcnewcapacity                         | 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间                                 |
| -gcold                                 | 监视老年代GC情况                                                                             |
| -gcoldcapacity                         | 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间                                 |
| -gcpermcapacity/-gcmetacapacity(JDK 8) | 输出永久代使用到的最大、最小空间                                                             |
| -compiler                              | 输出JIT编译过的方法、耗时等信息                                                              |
| -printcompilation                      | 输出已经被JIT编译过的方法                                                                    |

```shell
# 参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次
jstat -gc 2764 250 20
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
0.0   87040.0  0.0   87040.0 521216.0 382976.0 1061888.0   338933.3  40448.0 39473.2 4608.0 4396.0    514   15.213   0      0.000   15.213
```

* S0C:第一个幸存区的大小
* S1C:第二个幸存区的大小
* S0U:第一个幸存区的使用大小
* S1U:第二个幸存区的使用大小
* EC:伊甸园区的大小
* EU:伊甸园区的使用大小
* OC:老年代大小
* OU:老年代使用大小
* MC:方法区大小
* MU:方法区使用大小
* CCSC:压缩类空间大小
* CCSU:压缩类空间使用大小
* YGC:年轻代垃圾回收次数
* YGCT:年轻代垃圾回收消耗时间
* FGC:老年代垃圾回收次数
* FGCT:老年代垃圾回收消耗时间
* GCT:垃圾回收消耗总时间

* NGCMN:年轻代(young)中初始化(最小)的大小 (字节)
* NGCMX:年轻代(young)的最大容量 (字节)
* NGC:年轻代(young)中当前的容量 (字节)
* OGCMN:old代中初始化(最小)的大小 (字节)
* OGCMX:old代的最大容量 (字节)
* OGC:old代当前新生成的容量 (字节)
* PGCMN:perm代中初始化(最小)的大小 (字节)
* PGCMX:perm代的最大容量 (字节)
* PGC:perm代当前新生成的容量 (字节)
* MCMN:最小元数据容量
* MCMX:最大元数据容量
* MC:当前元数据空间大小
* CCSMN:最小压缩类空间大小
* CCSMX:最大压缩类空间大小
* CCSC:当前压缩类空间大小
* LGGC:最近一次GC的原因

```shell
## 显示百分比
jstat -gcutil 2764
```

#### jinfo：Java配置信息工具

> 实时地查看和调整虚拟机各项参数

jinfo命令格式：

```shell
jinfo [option] pid
可以使用-flag[+|-]name或者-flag name=value修改一部分运行期可写的虚拟机参数值
```

```shell
jinfo 11456
jinfo -sysprops 11456
jinfo -flag ConcGCThreads 11456
```

#### jmap：Java内存映像工具

> jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）  
> -XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件  
> -XX:+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件  
> Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件  
> jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等

jmap命令格式：

```shell
jmap [option] vmid
```

|        选项        |                                                     作用                                                    |
|--------------------|-------------------------------------------------------------------------------------------------------------|
| -dump              | 生成java堆转储快照。格式为： -dump:[live,]format=b,file=<filename>,其中live子参数说明是否只dump出存活的对象 |
| -finalizerinfo     | 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效                         |
| -heap              | 显示java堆详细信息，如使用哪种收集器、参数配置、分代情况等，在Linux/Solaris平台下有效                       |
| -jisto             | 显示堆中对象统计信息，包含类、实例对象、合集容量                                                            |
| -permstat/-clstats | 以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效                                      |
| -F                 | 当虚拟机进程对-dump选项没有相应时。可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效              |

```shell
jmap -dump:format=b,file=eclipse.bin 21207
```

#### jhat：虚拟机堆转储快照分析工具

> jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照  
> jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具都能实现比jhat更强大更专业的分析功能

```shell
jhat eclipse.bin
```

#### jstack：Java堆栈跟踪工具

> jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。  
> 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因  

jstack命令格式：

```
jstack [option] vmid
```

| 选项 |                     作用                     |
|------|----------------------------------------------|
| -F   | 当正常输出的请求不被响应时，强制输出线程堆栈 |
| -l   | 除堆栈外，显示关于锁的附加信息               |
| -m   | 如果调用到本地方法的话，可以显示c/c++的堆栈  |

> JDK 1.5中，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象

```jsp
<%@ page import="java.util.Map" %>
<html>
<head>
    <title>服务器线程信息</title>
</head>
<body>
<pre>
		<%
            for (Map.Entry<Thread, StackTraceElement[]> stackTrace : Thread.getAllStackTraces().entrySet()) {
                Thread thread = (Thread) stackTrace.getKey();
                StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue();
                if (thread.equals(Thread.currentThread())) {
                    continue;
                }
                out.print("\n线程:" + thread.getName() + "\n");
                for (StackTraceElement element : stack) {
                    out.print("\t" + element + "\n");
                }
            }
        %>
</pre>
</body>
</html>
```

----------

*深入理解Java虚拟机，JVM高级特性与最佳实践*