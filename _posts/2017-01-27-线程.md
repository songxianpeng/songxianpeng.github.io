---  
layout: post  
title: 线程  
tags: Thread  
categories: Java  
published: true  
---  

## 线程

* 进程：
	- 正在运行的程序，是系统进行资源分配和调用的独立（基本）单位。
	- 每一个进程都有它自己的内存空间和系统资源。
* 线程：
	- 是进程中的单个顺序控制流，是一条执行路径，程序使用CPU的基本单位
	- 一个进程如果只有一条执行路径，则称为单线程程序。
	- 一个进程如果有多条执行路径，则称为多线程程序。

### 对于单核计算机来讲，游戏进程和音乐进程是同时运行吗

不是。

> 因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。  
> 多进程的作用不是提高执行速度，而是提高CPU的使用率。


### 多进程有什么意义

能在同一个`时间段`内执行多个任务。提高CPU的使用率。

### 多线程有什么意义

多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。(程序抢占CPU时间片几率更大)  
而多线程却给了我们一个错觉：让我们认为多个线程是并发执行的。其实不是。  
因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。

### 什么是并发

大家注意两个词汇的区别：*并行和并发*。

前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。  
后者是物理上同时发生，指在某一个时间点同时运行多个程序。  
那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。

### JVM虚拟机的启动是单线程的还是多线程的？

JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。

## 多线程的实现方案

### 继承Thread类

#### 步骤

 1. 自定义类MyThread继承Thread类。
 2. MyThread类里面重写run()
 3. 创建对象
 4. 启动线程

```java
public class MyThread extends Thread {
	@Override
	public void run() {
		System.out.println("thread running");
	}
}
```

#### 线程能不能多次启动

```java
// MyThread my = new MyThread();
// my.start();
// // IllegalThreadStateException:非法的线程状态异常
// // 为什么呢?因为这个相当于是my线程被调用了两次。而不是两个线程启动。
// my.start();

// 创建两个线程对象
MyThread my1 = new MyThread();
MyThread my2 = new MyThread();

my1.start();
my2.start();
```

### 实现Runnable接口

#### 步骤

 1. 自定义类MyRunnable实现Runnable接口
 2. 重写run()方法
 3. 创建MyRunnable类的对象
 4. 创建Thread类的对象，并把C步骤的对象作为构造参数传递

```java
public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int x = 0; x < 100; x++) {
			// 由于实现接口的方式就不能直接使用Thread类的方法了,但是可以间接的使用
			System.out.println(Thread.currentThread().getName() + ":" + x);
		}
	}

}


MyRunnable my = new MyRunnable();

// 创建Thread类的对象，并把C步骤的对象作为构造参数传递
// Thread(Runnable target)
// Thread t1 = new Thread(my);
// Thread t2 = new Thread(my);
// t1.setName("林青霞");
// t2.setName("刘意");

// Thread(Runnable target, String name)
Thread t1 = new Thread(my, "林青霞");
Thread t2 = new Thread(my, "刘意");

t1.start();
t2.start()
```

#### 如何获取和设置线程名称

通过Thread.currentThread()获取当前线程后获取或设置线程名

#### 实现接口方式的好处

* 可以避免由于Java单继承带来的局限性。
* 适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。

### 多线程两种方式比较及区别

![多线程两种方式的图解比较及区别](/static/img/线程/多线程两种方式的图解比较及区别.jpg "多线程两种方式的图解比较及区别")

查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run方法，如果Thread类的run方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run方法。

```java
// Thread.java
private Runnable target;
public void run() {
	if (target != null) {
	    target.run();
	}
}
```

**如果在Thread子类覆盖的run方法中编写了运行代码，也为Thread子类对象传递了一个Runnable对象，那么，线程运行时的执行代码是子类的run方法的代码？还是Runnable对象的run方法的代码？**

子类的


### 实现Callable接口或者Runable接口（和线程池结合）

* 好处：
	- 可以有返回值
	- 可以抛出异常
* 弊端：
	- 代码比较复杂，所以一般不用

## 线程调度

* 分时调度模型
	- 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
* 抢占式调度模型
	- 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 

> Java使用的是抢占式调度模型。

```java
// 设置getPriority()和获取setPriority()线程优先级 默认是5 范围是1-10
// 线程优先级高仅仅表示线程获取的 CPU时间片的几率高
// 但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。
Thread thread = Thread.currentThread();
System.out.println(thread.getPriority());// 5
```

## 线程操作

* 线程休眠
	- public static void sleep(long millis)
* 线程加入(等待某线程执行结束后才继续执行)
	- public final void join()

```java
ThreadJoin tj1 = new ThreadJoin();
ThreadJoin tj2 = new ThreadJoin();
ThreadJoin tj3 = new ThreadJoin();

tj1.setName("李渊");
tj2.setName("李世民");
tj3.setName("李元霸");

tj1.start();
try {
	tj1.join();//tj1执行结束后继续执行下面的start()语句
} catch (InterruptedException e) {
	e.printStackTrace();
}

tj2.start();
tj3.start();
```

* 线程礼让(暂停当前正在执行的线程对象，并执行其他线程，让多个线程的执行更和谐，但是不能靠它保证一人一次。)
	- public static void yield() 
* 后台线程(守护线程，主进程结束后守护进程也结束)
	- public final void setDaemon(boolean on)
* 中断线程
	- public final void stop() 强制中断
	- public void interrupt() 中断线程。 把线程的状态终止，并抛出一个InterruptedException。
* 获取线程名
```java
Thread myThread = Thread.currentThread();
String name = myThread.getName();//通过setName()方法设置线程名
System.out.println(name);//main
```

### sleep()和wait()的区别

* sleep() 必须指时间;不释放锁。
* wait() 可以不指定时间，也可以指定时间;释放锁。

### 线程生命周期

新建 -- 就绪 -- 运行 -- 死亡  
新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡

![线程生命周期](/static/img/线程/线程生命周期.jpg "线程生命周期")

## 线程安全问题

### 判断是否有问题

1. 是否是多线程环境
2. 是否有共享数据
3. 是否有多条语句操作共享数据

### 解决多线程安全问题

让程序没有安全问题的环境.把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

#### 同步代码块

> synchronized(对象){需要同步的代码;}

#### 同步方法

把同步关键字加到方法上  
这里的锁对象是this

##### 静态同步方法

这里的锁对象是当前类的字节码文件对象

```java
class Outputer{
	public void output1(String name){
		synchronized (Outputer.class){
		}
	}

	public synchronized void output2(String name){
	}

	public static synchronized void output3(String name){
	}
}
// 1和3同步
// 2和3不同步，因为2锁定的是this对象，而3锁定的是当前类的字节码对象
```

#### 同步方法选择

如果锁对象是this，就可以考虑使用同步方法。  
否则能使用同步代码块的尽量使用同步代码块。

#### 同步弊端

* 当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。
* 如果出现了同步嵌套，就容易产生死锁问题

#### Jdk1.5 使用Lock锁

##### Lock锁

Lock比传统线程模型中的synchronized方式更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。

```java
// 定义票
private int tickets = 100;

// 定义锁对象
private Lock lock = new ReentrantLock();//ReentrantLock是Lock的实现类

@Override
public void run() {
    while (true) {
        try {// try finally防止中间代码异常锁不被释放
            // 加锁
            lock.lock();
            if (tickets > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()
                        + "正在出售第" + (tickets--) + "张票");
            }
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```

##### 读写锁

分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，写锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！

```java
private Map<String, Object> cache = new HashMap<String, Object>();
private ReadWriteLock rwl = new ReentrantReadWriteLock();
public  Object getData(String key){
rwl.readLock().lock();
Object value = null;
try{
	value = cache.get(key);
	if(value == null){
		rwl.readLock().unlock();
		rwl.writeLock().lock();
		try{
			if(value==null){//这里的判断防止别的线程在第一个write线程后恢复获取写锁重复写数据
					value = "aaaa";//实际失去queryDB();
				}
			}finally{
				rwl.writeLock().unlock();
			}
			rwl.readLock().lock();
		}
	}finally{
		rwl.readLock().unlock();
	}
	return value;
}
```

##### Condition

在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。对于大多数应用程序，这带来的实际影响很小，因为 Condition 应该总是在一个循环中被等待，并测试正被等待的状态声明。某个实现可以随意移除可能的虚假唤醒，但建议应用程序程序员总是假定这些虚假唤醒可能发生，因此总是在一个循环中等待。  
一个锁内部可以有多个Condition，即有多路等待和通知

```java
//condition条件唤醒实现阻塞队列
class BoundedBuffer {
	final Lock lock = new ReentrantLock();
	final Condition notFull = lock.newCondition(); 
	final Condition notEmpty = lock.newCondition(); 

	final Object[] items = new Object[100];
	int putptr, takeptr, count;

	public void put(Object x) throws InterruptedException {
		lock.lock();
		try {
			while (count == items.length){
				notFull.await();
			}
			items[putptr] = x;
			if (++putptr == items.length) {
				putptr = 0;
			}
			++count;
			notEmpty.signal();
		} finally {
			lock.unlock();
		}
	}

	public Object take() throws InterruptedException {
		lock.lock();
		try {
			while (count == 0){
				notEmpty.await();
			}
			Object x = items[takeptr];
			if (++takeptr == items.length) {
				takeptr = 0;
			}
			--count;
			notFull.signal();
			return x;
		} finally {
			lock.unlock();
		}
	}
}
```

##### Semaphore

Semaphore可以维护当前访问自身的线程个数，并提供了同步机制。使用Semaphore可以控制同时访问资源的线程个数，例如，实现一个文件允许的并发访问数。

```java
public static void main(String[] args) {
	ExecutorService service = Executors.newCachedThreadPool();
	final  Semaphore sp = new Semaphore(3);
	for(int i=0;i<10;i++){
		Runnable runnable = new Runnable(){
			public void run(){
				try {
					sp.acquire();
				} catch (InterruptedException e1) {
					e1.printStackTrace();
				}
				System.out.println("线程" + Thread.currentThread().getName() + 
					"进入，当前已有" + (3-sp.availablePermits()) + "个并发");
				try {
					Thread.sleep((long)(Math.random()*3000));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println("线程" + Thread.currentThread().getName() + 
					"即将离开");					
				sp.release();
				//下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元
				System.out.println("线程" + Thread.currentThread().getName() + 
					"已离开，当前已有" + (3-sp.availablePermits()) + "个并发");					
			}
		};
		service.execute(runnable);
	}
	service.shutdown();
}
```

##### 其他线程同步工具类

* CyclicBarrier
	- 表示大家彼此等待，大家集合好后才开始出发，分散活动后又在指定地点集合碰面
* CountDownLatch
	- 犹如倒计时计数器，调用CountDownLatch对象的countDown方法就将计数器减1，当计数到达0时，则所有等待者或单个等待者开始执行
* Exchanger
	- 用于实现两个线程之间的数据交换，每个线程在完成一定的事务后想与对方交换数据，第一个先拿出数据的线程将一直等待第二个线程拿着数据到来时，才能彼此交换数据。


## 死锁

是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象

## 线程通信

### 唤醒机制

* wait():等待 
	- 将来醒过来的时候，是从wait()方法向下执行
* notify():唤醒单个线程 立即释放锁。
	- 唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。
* notifyAll():唤醒所有线程

```java
public static void main(String[] args) {
	final Business business = new Business();
	new Thread(
		new Runnable() {
			
			@Override
			public void run() {
				
				for(int i=1;i<=50;i++){
					business.sub(i);
				}
				
			}
		}
		).start();
	
	for(int i=1;i<=50;i++){
		business.main(i);
	}
}
```

```java
// 锁和同步机制放在锁对象身上，不用每个调用线程中去写同步代码
class Business {
	private boolean bShouldSub = true;
	public synchronized void sub(int i){
		while(!bShouldSub){// JDK中有阐述使用while防止伪唤醒，即被唤醒以后还是检查是否满足条件
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		for(int j=1;j<=10;j++){
			System.out.println("sub thread sequence of " + j + ",loop of " + i);
		}
		bShouldSub = false;
		this.notify();
	}
	
	public synchronized void main(int i){
		while(bShouldSub){
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		for(int j=1;j<=100;j++){
			System.out.println("main thread sequence of " + j + ",loop of " + i);
		}
		bShouldSub = true;
		this.notify();
	}
}

```

### 线程的状态转换

![线程的状态转换](/static/img/线程/线程的状态转换.jpg "线程的状态转换")

**为什么wait(),notify(),notifyAll()等方法都定义在Object类中**

* 这些方法存在与同步中。
* 使用这些方法时必须要标识所属的同步的锁。
* 锁可以是任意对象，所以任意对象调用的方法一定定义Object类中。

## ThreadLocal

### 作用和目的

用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。

### 原理分析

```java
ThreadLocal{
	HashMap hashMap = new HashMap();
	
    void set(Object obj){
		hashMap.put(Thread.currentThread(),obj);
	}
	object get(){
		return hashMap.get(Thread.currentThread());
	}
}
```

### 特点

一个ThreadLocal代表一个变量，故其中里只能放一个数据，你有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象。如果有一个百个变量要线程共享呢？那请先定义一个对象来装这一百个变量，然后在ThreadLocal中存储这一个对象。

```java
private static ThreadLocal<Integer> x = new ThreadLocal<Integer>();
public static void main(String[] args) {
	for(int i=0;i<2;i++){
		new Thread(new Runnable(){
			@Override
			public void run() {
				int data = new Random().nextInt();
				System.out.println(Thread.currentThread().getName() 
					+ " has put data :" + data);
				x.set(data);
				new A().get();
				new B().get();
			}
		}).start();
	}
}
static class A{
	public void get(){
		int data = x.get();
		System.out.println("A from " + Thread.currentThread().getName() 
			+ " get data :" + data);
	}
}

static class B{
	public void get(){
		int data = x.get();			
		System.out.println("B from " + Thread.currentThread().getName() 
			+ " get data :" + data);
	}
}
// Thread-1 has put data :2094430671
// Thread-0 has put data :-2114425688
// A from Thread-1 get data :2094430671
// A from Thread-0 get data :-2114425688
// B from Thread-1 get data :2094430671
// B from Thread-0 get data :-2114425688
```

**封装写法**

```java
class MyThreadScopeData{
	private MyThreadScopeData(){}
	public static MyThreadScopeData getThreadInstance(){
		MyThreadScopeData instance = map.get();
		if(instance == null){
			instance = new MyThreadScopeData();
			map.set(instance);
		}
		return instance;
	}
	private static ThreadLocal<MyThreadScopeData> map = new ThreadLocal<MyThreadScopeData>();
	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
```

```java
public static void main(String[] args) {
	for(int i=0;i<2;i++){
		new Thread(new Runnable(){
			@Override
			public void run() {
				int data = new Random().nextInt();
				System.out.println(Thread.currentThread().getName() 
					+ " has put data :" + data);
				MyThreadScopeData.getThreadInstance().setName("name" + data);
				MyThreadScopeData.getThreadInstance().setAge(data);
				new A().get();
				new B().get();
			}
		}).start();
	}
}
static class A{
	public void get(){
		MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();
		System.out.println("A from " + Thread.currentThread().getName() 
			+ " getMyData: " + myData.getName() + "," +
			myData.getAge());
	}
}

static class B{
	public void get(){
		MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();
		System.out.println("B from " + Thread.currentThread().getName() 
			+ " getMyData: " + myData.getName() + "," +
			myData.getAge());
	}
}

// Thread-0 has put data :1764488084
// Thread-1 has put data :-1977536471
// A from Thread-1 getMyData: name-1977536471,-1977536471
// A from Thread-0 getMyData: name1764488084,1764488084
// B from Thread-1 getMyData: name-1977536471,-1977536471
// B from Thread-0 getMyData: name1764488084,1764488084
```

## 多个线程访问共享对象和数据的方式

* 将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现针对该数据进行的各个操作的互斥和通信。

```java
public static void main(String[] args) {
	ShareData data = new ShareData();
	new Thread(new MyRunnable1(data)).start();
	new Thread(new MyRunnable2(data)).start();
}
```

```java
class MyRunnable1 implements Runnable{
	private ShareData data;
	public MyRunnable1(ShareData data){
		this.data = data;
	}
	int count = 10;
	@Override
	public void run() {
		while(count-->0){
			data.increment();
		}
	}
}
```

```java
class MyRunnable2 implements Runnable{
	private ShareData data;
	public MyRunnable2(ShareData data){
		this.data = data;
	}
	int count = 10;
	@Override
	public void run() {
		while(count-->0){
			data.decrement();
		}
	}
}
```

```java
class ShareData {
	private int j = 0;
	public synchronized void increment(){
		j++;
		System.out.println("j++:"+j);
	}
	public synchronized void decrement(){
		j--;
		System.out.println("j--:"+j);
	}
}
```

* 将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。

```java
public static void main(String[] args) {
	final ShareData data = new ShareData();
	new Thread(new Runnable(){
		@Override
		public void run() {
			int count = 10;
			while(count-->0){
				data.increment();
			}
		}
	}).start();
	new Thread(new Runnable(){
		int count = 10;
		@Override
		public void run() {
			while(count-->0){
				data.decrement();
			}
		}
	}).start();
}
```

```java
class ShareData{
	private int j = 0;
	public synchronized void increment(){
		j++;
		System.out.println("j++:"+j);
	}
	public synchronized void decrement(){
		j--;
		System.out.println("j--:"+j);
	}
}
```

* 上面两种方式的组合：将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类。

```java
public class Test {
	public static void main(String[] args) {
		Test test = new Test();
		new Thread(test.new MyRunnable1()).start();
		new Thread(test.new MyRunnable2()).start();
	}

	private int j = 0;
	public synchronized void increment(){
		j++;
		System.out.println("j++:"+j);
	}
	
	public synchronized void decrement(){
		j--;
		System.out.println("j--:"+j);
	}

	class MyRunnable1 implements Runnable{
		int count = 10;
		@Override
		public void run() {
			while(count-->0){
				increment();
			}

		}
	}

	class MyRunnable2 implements Runnable{
		int count = 10;
		@Override
		public void run() {
			while(count-->0){
				decrement();
			}
		}
	}
}

```

## 线程组

Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。  
默认情况下，所有的线程都属于主线程组。

### 设置线程分组

> Thread(ThreadGroup group, Runnable target, String name)

```java
// ThreadGroup(String name)
ThreadGroup tg = new ThreadGroup("这是一个新的组");

MyRunnable my = new MyRunnable();
// Thread(ThreadGroup group, Runnable target, String name)
Thread t1 = new Thread(tg, my, "林青霞");
Thread t2 = new Thread(tg, my, "刘意");

System.out.println(t1.getThreadGroup().getName());
System.out.println(t2.getThreadGroup().getName());

//通过组名称设置后台线程，表示该组的线程都是后台线程
tg.setDaemon(true);

// 通过结果我们知道了：线程默认情况下属于main线程组
// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组
System.out.println(Thread.currentThread().getThreadGroup().getName());
```

## 线程池

程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。

* 线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
* 在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池
	
### Jdk1.5 Executors工厂类来产生线程池

* public static ExecutorService newCachedThreadPool() 创建一个具有缓存功能的线程池
* public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用的，具有固定线程数的线程池
* public static ExecutorService newSingleThreadExecutor() 创建一个只有单线程的线程池，相当于上个方法的参数是1

```java

//Callable:是带泛型的接口。
//这里指定的泛型其实是call()方法的返回值类型。
public class MyCallable implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
    	int sum = 0;
		for (int x = 0; x < 100; x++) {
			sum += x;
		}
		return sum;
	}
}

public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for (int x = 0; x < 100; x++) {
			System.out.println(Thread.currentThread().getName() + ":" + x);
		}
	}
}

// 创建一个线程池对象，控制要创建几个线程对象。
// public static ExecutorService newFixedThreadPool(int nThreads)
// ExecutorService threadPool = Executors.newCachedThreadPool();创建缓存线程池。线程数可随需求变化
// ExecutorService threadPool = Executors.newSingleThreadExecutor();//创建单一线程池 线程死掉后会重启一个替代线程，保证至少有一个线程
ExecutorService pool = Executors.newFixedThreadPool(2);// 创建固定大小的线程池

// 可以执行Runnable对象或者Callable对象代表的线程
pool.submit(new MyRunnable());
pool.submit(new MyRunnable());

Future<Integer> result = pool.submit(new MyCallable());

Integer i = result.get();

//结束线程池
pool.shutdown();
```

### 线程池启动定时器

支持间隔重复任务的定时方式，不直接支持绝对定时方式，需要转换成相对时间方式。

```java
public class test {

	public static void main(String[] args) {
		//ExecutorService service = Executors.newFixedThreadPool(3);
		ExecutorService service = Executors.newCachedThreadPool();
		for(int i=1;i<=2;i++){
			final int sequence = i;
			//仔细品味runnable对象放到循环里面和外面的区别，为了让每个对象有自己独立的编号			
			service.execute(new Runnable(){
				public void run() {
					try{Thread.sleep(200);}catch(Exception e){}
					for(int j=1;j<=3;j++){
						System.out.println(Thread.currentThread().getName() + " is serving " 
								+ sequence + " task:" + "loop of " + j);
					}
				}
			});
		}
		/*
		用下面这句代码来说明上面的代码是在提交任务，并且所有的任务都已经提交了，但任务是什么时候执行的，则是由线程池调度的！
		*/
		System.out.println("all task have committed!");	
		//注意与service.shutdownNow()的区别。
		service.shutdown();
		
		ScheduledExecutorService scheduledService = Executors.newScheduledThreadPool(1);// 按时间间隔定时调用
		scheduledService.scheduleAtFixedRate(
				new Runnable(){
					public void run() {
						System.out.println("bomb!!!");
					}}, 
				5, 
				1,
				TimeUnit.SECONDS);
	}
}
// all task have committed!
// pool-1-thread-2 is serving 2 task:loop of 1
// pool-1-thread-1 is serving 1 task:loop of 1
// pool-1-thread-2 is serving 2 task:loop of 2
// pool-1-thread-1 is serving 1 task:loop of 2
// pool-1-thread-2 is serving 2 task:loop of 3
// pool-1-thread-1 is serving 1 task:loop of 3
// bomb!!!
// bomb!!!
// bomb!!!
// ...
```

### Callable&Future

* Future取得的结果类型和Callable返回的结果类型必须一致，这是通过泛型来实现的。
* Callable要采用ExecutorSevice的submit方法提交，返回的future对象可以取消任务。
* CompletionService用于提交一组Callable任务，其take方法返回已完成的一个Callable任务对应的Future对象。

```java
public static void main(String[] args) {
	// Future获取结果
	ExecutorService threadPool =  Executors.newSingleThreadExecutor();
	Future<String> future =
	threadPool.submit(
		new Callable<String>() {
			public String call() throws Exception {
				Thread.sleep(2000);
				return "hello";
			};
		}
		);
	System.out.println("等待结果");
	try {
		System.out.println("拿到结果：" + future.get());
	} catch (InterruptedException e) {
		e.printStackTrace();
	} catch (Exception e) {
		e.printStackTrace();
	}
	// 批量获取结果
	ExecutorService threadPool2 =  Executors.newFixedThreadPool(10);
	CompletionService<Integer> completionService = new ExecutorCompletionService<Integer>(threadPool2);
	for(int i=1;i<=10;i++){
		final int seq = i;
		completionService.submit(new Callable<Integer>() {
			@Override
			public Integer call() throws Exception {
				Thread.sleep(new Random().nextInt(5000));
				return seq;
			}
		});
	}
	for(int i=0;i<10;i++){
		try {
			System.out.println(
				completionService.take().get());
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
	}
}
// 等待结果
// 拿到结果：hello
// 8
// 2
// 5
// 4
// 10
// 1
// 6
// 7
// 9
// 3

```


## 定时器

### Timer

```java
public class TimerDemo {
	public static void main(String[] args) {
		// 创建定时器对象
		Timer t = new Timer();
		// 3秒后执行爆炸任务第一次，如果不成功，每隔2秒再继续炸
		t.schedule(new MyTask(t), 3000, 2000);
	}
}

// 做一个任务
class MyTask extends TimerTask {

	private Timer t;
	
	public MyTask(){}
	
	public MyTask(Timer t){
		this.t = t;
	}
	
	@Override
	public void run() {
		System.out.println("beng,爆炸了");
		t.cancel();// 爆炸成功结束任务
	}

}
```

## 阻塞队列

阻塞队列与Semaphore有些相似，但也不同，阻塞队列是一方存放数据，另一方释放数据，Semaphore通常则是由同一方设置和释放信号量。

* ArrayBlockingQueue
	- 只有put方法和take方法才具有阻塞功能
* SynchronousQueue
	- 只有有线程take时才能put，否则阻塞

```java
public static void main(String[] args) {
	final BlockingQueue queue = new ArrayBlockingQueue(3);//设置上限三个，满了以后put阻塞
	for(int i=0;i<2;i++){
		new Thread(){
			public void run(){
				while(true){
					try {
						Thread.sleep((long)(Math.random()*1000));
						System.out.println(Thread.currentThread().getName() + "准备放数据!");							
						queue.put(1);
						System.out.println(Thread.currentThread().getName() + "已经放了数据，" + 							
							"队列目前有" + queue.size() + "个数据");
					} catch (InterruptedException e) {
						e.printStackTrace();
					}

				}
			}
			
		}.start();
	}
	
	new Thread(){
		public void run(){
			while(true){
				try {
					//将此处的睡眠时间分别改为100和1000，观察运行结果
					Thread.sleep(1000);
					System.out.println(Thread.currentThread().getName() + "准备取数据!");
					queue.take();
					System.out.println(Thread.currentThread().getName() + "已经取走数据，" + 							
						"队列目前有" + queue.size() + "个数据");					
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		
	}.start();			
}

// Thread-0准备放数据!
// Thread-0已经放了数据，队列目前有1个数据
// Thread-1准备放数据!
// Thread-1已经放了数据，队列目前有2个数据
// Thread-1准备放数据!
// Thread-1已经放了数据，队列目前有3个数据
// Thread-2准备取数据!
// Thread-2已经取走数据，队列目前有2个数据
// Thread-0准备放数据!
// Thread-0已经放了数据，队列目前有3个数据
// Thread-1准备放数据!
// Thread-0准备放数据!
// Thread-2准备取数据!
// Thread-2已经取走数据，队列目前有2个数据
// Thread-1已经放了数据，队列目前有3个数据
// ....
```

两个具有1个空间的队列可以实现同步通知的功能

----------

*以上概念总结于传智播客Java基础课程*