---  
layout: post  
title: Spring  
tags: Spring  
categories: JavaEE  
published: true  
---  

[TOC]

Spring是一个开源的轻量级一站式（对三层都提供了解决技术）框架，核心IOC和AOP

功能：简化开发。创建Spring的主要目的是用来替代更加重量级的企业级Java技术，尤其是EJB。相对于EJB来说，Spring提供了更加轻量级和简单的编程模型。它增强了简单老式Java对象（Plain Old Java object，POJO）的功能，使其具备了之前只有EJB和其他企业级Java规范才具有的功能。桥梁作用，整合其他框架

为了降低Java开发的复杂性，Spring采取了以下4种关键策略：

* 基于POJO的轻量级和最小侵入性编程
* 通过依赖注入和面向接口实现松耦合
* 基于切面和惯例进行声明式编程
* 通过切面和模板减少样板式代码

## Spring模块

![spring-overview.png](/static/img/spring/spring-overview.png "spring-overview.png")

核心依赖四个jar包：

* core
* beans
* expression
* context

* Spring核心容器
    - 容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Spring bean工厂，它为Spring提供了DI的功能。基于bean工厂，多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。
    - 除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度。
    - 所有的Spring模块都构建于核心容器之上。
* Spring的AOP模块
    - 在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。
* 数据访问与集成
    - Spring的JDBC和DAO（Data Access Object）模块抽象了样板式代码，使数据库代码变得简单明了，还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，再也不需要解释那些隐晦专有的SQL错误信息了！
    - Spring没有尝试去创建自己的ORM解决方案，而是对许多流行的ORM框架进行了集成，包括Hibernate、Java Persisternce API、Java Data Object和iBATIS SQL Maps。Spring的事务管理支持所有的ORM框架以及JDBC。
    - 本模块同样包含了在JMS（Java Message Service）之上构建的Spring抽象层，它会使用消息以异步的方式与其他应用集成。从Spring 3.0开始，本模块还包含对象到XML映射的特性，它最初是Spring Web Service项目的一部分。
    - 本模块会使用Spring AOP模块为Spring应用中的对象提供事务管理服务。
* Web与远程调用
    - 虽然Spring能够与多种流行的MVC框架进行集成，但它的Web和远程调用模块自带了一个强大的MVC框架，有助于在Web层提升应用的松耦合水平。
    - 该模块还提供了多种构建与其他应用交互的远程调用方案。Spring远程调用功能集成了RMI（Remote Method Invocation）、Hessian、Burlap、JAX-WS，同时Spring还自带了一个远程调用框架：HTTP invoker。Spring还提供了暴露和使用REST API的良好支持。
* Instrumentation
    - Spring的Instrumentation模块提供了为JVM添加代理（agent）的功能。
* 测试
    - Spring提供了测试模块以致力于Spring应用的测试。通过该模块，你会发现Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现。对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。

## Spring Portfolio

整个Spring Portfolio包括多个构建于核心Spring框架之上的框架和类库。概括地讲，整个Spring Portfolio几乎为每一个领域的Java开发都提供了Spring编程模型。

* Spring Web Flow
    - Spring Web Flow建立于Spring MVC框架之上，它为基于流程的会话式Web应用（可以想一下购物车或者向导功能）提供了支持。
* Spring Web Service
    - 虽然核心的Spring框架提供了将Spring bean以声明的方式发布为Web Service的功能，但是这些服务是基于一个具有争议性的架构（拙劣的契约后置模型）之上而构建的。这些服务的契约由bean的接口来决定。 Spring Web Service提供了契约优先的Web Service模型，服务的实现都是为了满足服务的契约而编写的。
* Spring Security
    - 安全对于许多应用都是一个非常关键的切面。利用Spring AOP，Spring Security为Spring应用提供了声明式的安全机制。
* Spring Integration
    - 许多企业级应用都需要与其他应用进行交互。Spring Integration提供了多种通用应用集成模式的Spring声明式风格实现。
* Spring Batch
    - 当需要对数据进行大量操作时，没有任何技术可以比批处理更胜任这种场景。如果需要开发一个批处理应用，你可以通过Spring Batch，使用Spring强大的面向POJO的编程模型。
* Spring Data
    - Spring Data使得在Spring中使用任何数据库都变得非常容易。为NoSQL数据库提供了使用数据的新方法，这些方法会比传统的关系型数据库更为合适。
    - 不管你使用文档数据库，如MongoDB，图数据库，如Neo4j，还是传统的关系型数据库，Spring Data都为持久化提供了一种简单的编程模型。这包括为多种数据库类型提供了一种自动化的Repository机制，它负责为你创建Repository的实现。
* Spring Social
    - 这是Spring的一个社交网络扩展模块。它能够帮助你通过REST API连接Spring应用
* Spring Mobile
    - Spring Mobile是Spring MVC新的扩展模块，用于支持移动Web应用开发。
* Spring for Android
    - 与Spring Mobile相关的是Spring Android项目。这个新项目，旨在通过Spring框架为开发基于Android设备的本地应用提供某些简单的支持。最初，这个项目提供了Spring RestTemplate的一个可以用于Android应用之中的版本。它还能与Spring Social协作，使得原生应用可以通过REST API进行社交网络的连接。
* Spring Boot
    - Spring Boot是一个崭新的令人兴奋的项目，它以Spring的视角，致力于简化Spring本身。
    - Spring Boot大量依赖于自动配置技术，它能够消除大部分（在很多场景中，甚至是全部）Spring配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都能减少Spring工程构建文件的大小。

## 容器

在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。

容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。

Spring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。

* bean工厂（由org.springframework. beans. factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。
* 应用上下文（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。

虽然可以在bean工厂和应用上下文之间任选一种，但bean工厂对大多数应用来说往往太低级了，因此，应用上下文要比bean工厂更受欢迎。

### 应用上下文

Spring自带了多种类型的应用上下文。

* AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。
* AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载Spring Web应用上下文。
* ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。
* FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。
* XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。

### bean的生命周期

bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制

![bean-life-cycle](/static/img/spring/bean-life-cycle.png "bean-life-cycle")

1. Spring对bean进行实例化
2. Spring将值和bean的引用注入到bean对应的属性中
3. 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法
4. 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来
6. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法
7. 如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用
8. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法
9. 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁
10. 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用

## IOC

使用new实例创建对象耦合度太高，使用工厂模式仅与工厂耦合，将创建对象的工作交给spring工厂完成

创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。

### 优势

* 创建应用对象之间关联关系的传统方法（通过构造器或者查找）通常会导致结构复杂的代码，这些代码很难被复用也很难进行单元测试。如果情况不严重的话，这些对象所做的事情只是超出了它应该做的范围；而最坏的情况则是，这些对象彼此之间高度耦合，难以复用和测试。  
* 在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。

DI所带来的最大收益——松耦合。

耦合具有两面性

* 一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且典型地表现出“打地鼠”式的bug特性（修复一个bug，将会出现一个或者更多新的bug）。
* 另一方面，一定程度的耦合又是必须的——完全没有耦合的代码什么也做不了。

对依赖进行替换的一个最常用方法就是在测试的时候使用mock实现。


### 原理

* XML配置文件
* dom4j解析
* 工厂设计模式
* 反射

### bean的实例化方式

* 使用类无参构造方法创建
* 使用静态工厂创建
* 使用实例工厂创建

```xml
<!--通过无参构造-->
<bean id="myBean" class="com.xpress.model.MyBean"/>
<!--通过静态工厂-->
<bean id="myBean" class="com.xpress.factory.StaticBeanFactory" factory-method="getBean"/>
<!--通过实例工厂-->
<bean id="factory" class="com.xpress.factory.BeanFactory"/>
<bean id="myBean" factory-bean="factory" factory-method="getBean"/>
```

### 配置可选方案

三种主要的装配机制：

* 在XML中进行显式配置。
* 在Java中进行显式配置。
* 隐式的bean发现机制和自动装配。

建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置bean的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。

#### XML配置方式

使用XML文件进行配置的，所以选择ClassPathXmlApplicationContext

##### 配置文件加载

###### 手动加载

```java
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
MyBean myBean = (MyBean) applicationContext.getBean("myBean");
```

###### Web项目容器加载

实现思想：把加载配置文件和创建对象过程，在服务器启动的时候完成

实现原理：

* ServletContext对象
* 监听器

1. 在服务器启动的时候，每个项目会创建一个ServletContext对象
2. 在ServletContext对象创建的时候，使用监听器监听到ServletContext对象的创建，此时加载配置文件并创建对象
3. 把创建出来的对象放到ServletContext域中（setAttribute()方法）
3. 获取对象时，在ServletContext域中取出（getAttribute()方法）

引入spring-web.jar

```xml
<!-- 配置监听器 -->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
<!-- 配置文件位置 -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
```

##### 配置文件

缺点：

* 并没有JavaConfig那样强大，在JavaConfig配置方式中，你可以通过任何可以想象到的方法来创建bean实例。
* Spring的XML配置并不能从编译期的类型检查中受益。

* 配置文件：官方建议applicationContext.xml

dtd

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
        "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
<beans>
    <!-- bean definitions here -->
    <!-- 引入其他配置 -->
    <import resource="cd-config.xml"/>
    <!-- 引入配置类或者启动组件扫描 -->
    <bean class="soundsystem.CDConfig"/>
</beans>
```

schema

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- bean definitions here -->
</beans>
```

##### bean标签

###### 常用属性

* id：名称，不能包含特殊符号
* class：对象全路径
* name：同id，可以包含特殊符号（兼容struts1，已废弃）
* scope：作用域
    - singleton：单例的（默认）
    - prototype：多例的
    - 需要在web.xml中配置org.springframework.web.context.request.RequestContextListener支持
        + request：创建一个bean对象并存入request中，随request废弃而废弃
        + session：创建一个bean对象并存入session中，随session废弃而废弃
        + globalSession：应用在Portlet环境放到globalSession中，非Portlet环境相当于session，生命周期在portlet Session的生命周期范围
* lazy-init：懒加载，第一次获取bean时才初始化，singleton时默认容器启动就初始化bean
    - 在beans标签可以设置默认懒加载default-lazy-init="true"
* init-method：初始化方法，创建实例后调用
* destroy-method：销毁方法，在context正常关闭时调用
* autowire：配置当前bean的属性按何种方式自动装配
    - no：默认值，手动装配
    - byType：根据属性类型匹配，发现多个抛异常，没找到为null
    - byName：根据属性名称匹配，没找到为null
    - constructor：同byType，如果在容器中没有找到与构造器参数类型一致的bean，则抛异常
    - autodetect：通过bean的内省机制决定使用constructor还是byType方式，如果发现默认构造器，使用byType方式
    - 在beans标签可以设置默认装配方式default-autowire="byName"

##### 属性注入

作为一个通用的规则，我倾向于对强依赖使用构造器注入，而对可选性的依赖使用属性注入。

注入方式

* set方法注入（spring支持）
* 有参构造注入（spring支持）
* 接口注入（实现指定结口的方法）

**set方法注入**

需要注入的属性必须有相应的set方法

```xml
<bean id="myBean" class="com.xpress.model.MyBean">
    <property name="name" value="xpress"/>
</bean>
<!-- 声明service -->
<bean id="myService" class="com.xpress.service.MyService"/>
<bean id="myAction" class="com.xpress.action.MyAction">
    <!-- 注入service -->
    <property name="myService" ref="myService"/>
</bean>
```

**复杂类型注入**

* 数组
* list集合
* map集合
* properties集合

```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

util命名空间：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xmlns:util="http://www.springframework.org/schema/util"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/util 
    http://www.springframework.org/schema/util/spring-util.xsd">

  <bean id="compactDisc"
        class="soundsystem.properties.BlankDisc"
        p:title="Sgt. Pepper's Lonely Hearts Club Band"
        p:artist="The Beatles"
        p:tracks-ref="trackList" />

  <util:list id="trackList">  
    <value>Sgt. Pepper's Lonely Hearts Club Band</value>
    <value>With a Little Help from My Friends</value>
    <value>Lucy in the Sky with Diamonds</value>
  </util:list>
</beans>

```

Spring util-命名空间中的元素：

|       元 素        |                       描 述                        |
|--------------------|----------------------------------------------------|
| util:constant      | 引用某个类型的public static域，并将其暴露为bean    |
| util:list          | 创建一个java.util.List类型的bean，其中包含值或引用 |
| util:map           | 创建一个java.util.Map类型的bean，其中包含值或引用  |
| util:properties    | 创建一个java.util.Properties类型的bean             |
| util:property-path | 引用一个bean的属性（或内嵌属性），并将其暴露为bean |
| util:set           | 创建一个java.util.Set类型的bean，其中包含值或引用  |


**有参构造注入**

constructor-arg：

```xml
 <bean id="myBean" class="com.xpress.model.MyBean">
    <!-- index可以省略 -->
    <constructor-arg index="0" name="name" value="xpress"/>
    <constructor-arg name="userDao" ref="userDao"/>
</bean>
```

c命名空间：

```java
@Autowired
public CDPlayer(CompactDisc cd) {
    this.cd = this.cd;
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:c="http://www.springframework.org/schema/c"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="compactDisc" class="soundsystem.SgtPeppers" />
  <!-- 装配引用 -->
  <bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
  <!-- 使用索引而不是变量名 -->
  <bean id="cdPlayer1" class="soundsystem.CDPlayer" c:_0-ref="compactDisc"/>
  <!-- 只有一个省略数字 -->
  <bean id="cdPlayer2" class="soundsystem.CDPlayer" c:_-ref="compactDisc"/>

  <!-- 装配值 -->
  <bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band"  c:_1="The Beatles" />
  <bean id="cdPlayer" class="soundsystem.CDPlayer" c:_0="compactDisc" />
</beans>
```

![c-namespace](/static/img/spring/c-namespace.png "c-namespace")

**名称空间p注入**

p-命名空间中属性所遵循的命名约定与c-命名空间中的属性类似。

```xml
<!-- 引入名称空间p -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<bean id="myBean" class="com.xpress.model.MyBean" p:name="xpress"/>
<bean id="cdPlayer" class="soundsystem.properties.CDPlayer" p:compactDisc-ref="compactDisc" />
```

![p-namespace](/static/img/spring/p-namespace.png "p-namespace")

#### 注解方式

Spring从两个角度来实现自动化装配：

* 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。
* 自动装配（autowiring）：Spring自动满足bean之间的依赖。

对于基于Java的配置，Spring提供了AnnotationConfigApplicationContext

##### 开启注解

引入context包schema，并打开注解扫描

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--开启类，方法，属性上的注解扫描，完全使用注解-->
    <context:component-scan base-package="com.xpress.service,com.xpress.dao,com.xpress.model"/>
    <!--只开启属性上的注解扫描，仍然需要在配置文件中声明bean-->
    <!--<context:annotation-config/>-->
</beans>
```

如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。Spring将会扫描这个包以及这个包下的所有子包，查找带有注解的类，并且会在Spring中自动为其创建一个bean。

```java
@Configuration
@ComponentScan// 以配置类所在的包作为基础包（base package）来扫描组件
// @ComponentScan(basePackageClasses = {CDPlayer.class,SgtPeppers.class}) // 这些类所在的包将会作为组件扫描的基础包
// @ComponentScan(basePackages={"soundsystem","video"}) // 更加清晰地表明你所设置的是基础包
public class CDPlayerConfig { 
}
```

annotation-config配置隐式注册了多个对注解进行解析的处理器

* spring-beans:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor 处理@Autowired注解
* spring-beans:org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor 处理@Resource
* spring-context:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor 处理持久化相关注解
* spring-tx:org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor 处理@Required注解

##### 创建对象

目前提供的4个注解功能都是一样的，spring为了以后对注解功能进行拓展

* @Component 泛指组件
* @Controller WEB层
* @Service 业务层
* @Repository 持久层

```java
@Component(value = "myBean")// <bean id="myBean"
@Scope(value = "singleton")// 指定单例，不指定默认单例
public class MyBean {
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    // 注解指定init-method，在注入属性后执行
    @PostConstruct
    public void init(){}
    @PreDestroy
    public void destroy() {}
}
```

##### 注入属性

注解可以用于属性上和属性的set方法上

* @Autowired
    - 默认按类型进行装配，设置@Qualifier指定按名称装配
    - 默认要求必须存在，设置required属性为false允许null
    - 可以用在set方法上、属性上、构造器上和其他方法上
* @Resource(name = "userDao")
    - 默认按名称进行装配，找不到匹配名称才使用类型装配
    - name属性可以指定名称，指定名称后匹配不到将不会按类型装配
* @Inject

```java
@Service("userService")
public class UserService {
    @Resource(name = "userDao")
    private UserDao userDao;
    @Autowired
    @Qualifier("userDao")// 指定按名称进行装配
    private UserDao userDao;
}
```

```java
@Component
public class CDPlayer implements MediaPlayer {
  private CompactDisc cd;
  @Autowired // 能够用在构造器上
  public CDPlayer(CompactDisc cd) {
    this.cd = cd;
  }
  public void play() {
    cd.play();
  }
}
```

#### JavaConfig

在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。

它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样都使用相同的语言进行表述，但JavaConfig是配置代码。这意味着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码之中。

* 默认情况下，bean的ID与带有@Bean注解的方法名是一样的，也可以通过name属性指定一个不同的名字
* 方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。

```java
@Configuration
@Import({CDPlayerConfig.class,CDConfig.class})// 引入其他配置
@ImportResource("classpath:cd-config.xml")// 引入xml配置
public class CDPlayerConfig {
    @Bean//(name = "compactDisc")
    public CompactDisc compactDisc() {
        return new SgtPeppers();
    }
    // 自动装配合适的compactDisc
    // 你可以将配置分散到多个配置类、XML文件以及自动扫描和装配bean之中，只要功能完整健全即可。
    @Bean
    // @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE //控制实例为单例还是多例
    public CDPlayer cdPlayer(CompactDisc compactDisc) {
        return new CDPlayer(compactDisc);
    }
}
```

```java
@ContextConfiguration(classes=CDPlayerConfig.class)
public class CDPlayerTest {
    @Autowired
    private MediaPlayer player;
}
```

### profile

#### JavaConfig

在Spring 3.1中，只能在类级别上使用@Profile注解。从Spring 3.2开始，你也可以在方法级别上使用@Profile注解，与@Bean注解一同使用。

```java
@Configuration
public class DataSourceConfig {
    @Bean
    @Profile("dev")
    public DataSource embeddedDataSource() {
      return new EmbeddedDatabaseBuilder()
          .setType(EmbeddedDatabaseType.H2)
          .addScript("classpath:schema.sql")
          .addScript("classpath:test-data.sql")
          .build();
    }
    @Bean
    @Profile("prod")
    public DataSource jndiDataSource() {
      JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();
      jndiObjectFactoryBean.setJndiName("jdbc/myDS");
      jndiObjectFactoryBean.setResourceRef(true);
      jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);
      return (DataSource) jndiObjectFactoryBean.getObject();
  }

}
```

尽管每个DataSource bean都被声明在一个profile中，并且只有当规定的profile激活时，相应的bean才会被创建，但是可能会有其他的bean并没有声明在一个给定的profile范围内。  
没有指定profile的bean始终都会被创建，与激活哪个profile没有关系。

#### XML

* 可以通过`<beans>`元素的profile属性，在XML中配置profile bean。
* 还可以在根`<beans>`元素中嵌套定义`<beans>`元素，而不是为每个环境都创建一个profile XML文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xmlns:jee="http://www.springframework.org/schema/jee" xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="
    http://www.springframework.org/schema/jee
    http://www.springframework.org/schema/jee/spring-jee.xsd
    http://www.springframework.org/schema/jdbc
    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd" profile="dev">
</beans>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xmlns:jee="http://www.springframework.org/schema/jee" xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="
    http://www.springframework.org/schema/jee
    http://www.springframework.org/schema/jee/spring-jee.xsd
    http://www.springframework.org/schema/jdbc
    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">
  <beans profile="dev">
    <jdbc:embedded-database id="dataSource" type="H2">
      <jdbc:script location="classpath:schema.sql" />
      <jdbc:script location="classpath:test-data.sql" />
    </jdbc:embedded-database>
  </beans>
  <beans profile="prod">
    <jee:jndi-lookup id="dataSource"
      lazy-init="true"
      jndi-name="jdbc/myDatabase"
      resource-ref="true"
      proxy-interface="javax.sql.DataSource" />
  </beans>
</beans>
```

#### 激活profile

Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：

* spring.profiles.active
* spring.profiles.default

如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active属性的话，那Spring将会查找spring.profiles.default的值。如果均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。

有多种方式来设置这两个属性：

* 作为DispatcherServlet的初始化参数；
* 作为Web应用的上下文参数；
* 作为JNDI条目；
* 作为环境变量；
* 作为JVM的系统属性；
* 在集成测试类上，使用@ActiveProfiles注解设置。

*Tips：一种方式是使用DispatcherServlet的参数将spring.profiles.default设置为开发环境的profile，当应用程序部署到QA、生产或其他环境之中时，负责部署的人根据情况使用系统属性、环境变量或JNDI设置spring.profiles.active即可。*

**web.xml**

```xml
<!-- 为上下文设值默认的profile -->
<context-param>
    <param-name>spring.profiles.default</param-name>
    <param-value>dev</param-value>
</context-param>

<servlet>
    <servlet-name>spring-webmvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <!--为 Servlet设值默认profile -->
        <param-name>spring.profiles.default</param-name>
        <param-value>dev</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
```

**测试**

```java

public class DataSourceConfigTest {
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(classes = DataSourceConfig.class)
    @ActiveProfiles("prod")// 指定运行测试时要激活哪个profile
    public static class ProductionDataSourceTest {
        @Autowired
        private DataSource dataSource;
        @Test
        public void shouldBeEmbeddedDatasource() {
            // should be null, because there isn't a datasource configured in JNDI
            assertNull(dataSource);
        }
    }

    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration("classpath:datasource-config.xml")
    @ActiveProfiles("dev")
    public static class DevDataSourceTest_XMLConfig {
        @Autowired
        private DataSource dataSource;
        @Test
        public void shouldBeEmbeddedDatasource() {
            assertNotNull(dataSource);
            JdbcTemplate jdbc = new JdbcTemplate(dataSource);
            List<String> results = jdbc.query("select id, name from Things", new RowMapper<String>() {
                @Override
                public String mapRow(ResultSet rs, int rowNum) throws SQLException {
                    return rs.getLong("id") + ":" + rs.getString("name");
                }
            });
            assertEquals(1, results.size());
            assertEquals("1:A", results.get(0));
        }
    }
}
```

### 条件化的bean

Spring 4引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。

```java
@Configuration
public class MagicConfig {
    @Bean
    @Conditional(MagicExistsCondition.class)
    public MagicBean magicBean() {
        return new MagicBean();
    }
}
```

```java
public class MagicExistsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Environment env = context.getEnvironment();
        return env.containsProperty("magic");
    }
}
```

matches()方法会得到ConditionContext和AnnotatedTypeMetadata对象用来做出决策。

通过ConditionContext，可以做到如下几点：

* 借助getRegistry()返回的BeanDefinitionRegistry检查bean定义
* 借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性
* 借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么
* 读取并探查getResourceLoader()返回的ResourceLoader所加载的资源
* 借助getClassLoader()返回的ClassLoader加载并检查类是否存在

通过AnnotatedTypeMetadata，可以做到如下几点：

* 借助isAnnotated()方法，能够判断带有@Bean注解的方法是不是还有其他特定的注解
* 借助其他的那些方法，能够检查@Bean注解的方法上其他注解的属性

### 处理自动装配的歧义性

可以将可选bean中的某一个设为首选（primary）的bean，或者使用限定符（qualifier）来帮助Spring将可选的bean的范围缩小到只有一个bean。

#### 标示首选的bean

Spring将会使用首选的bean，而不是其他可选的bean。

```java
@Component
@Primary
public IceCream implements Dessert{}
```

```java
@Bean
@Primary
public Dessert iceCream{
    return new IceCream();
}
```

```xml
<bean id="iceCream" class="com.dessert.IceCream" primary="true"/>
```

#### 限定自动装配的bean

@Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用  
可以为bean设置自己的限定符，而不是依赖于将bean ID作为限定符。在这里所需要做的就是在bean声明上添加@Qualifier注解。它可以与@Component组合使用

```java
@Component
@Qualifier("dessert")
public IceCream implements Dessert{}
```

```java
@Autowired
@Qualifier("dessert")
public void setDessert(Dessert dessert){
    this.dessert = dessert;
}
```

### bean的作用域

Spring定义了多种作用域：

* 单例（Singleton）：在整个应用中，只创建bean的一个实例
* 原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例
* 会话（Session）：在Web应用中，为每个会话创建一个bean实例
* 请求（Rquest）：在Web应用中，为每个请求创建一个bean实例

如果选择其他的作用域，要使用@Scope注解，它可以与@Component或@Bean一起使用。

```java
@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.INTERFACES)
public class Notepad {
    // the details of this class are inconsequential to this example
}
```

proxyMode:

* proxyMode属性被设置成了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean。
* 一个具体的类的话，Spring就没有办法创建基于接口的代理了，它使用CGLib来生成基于类的代理，必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理

*XML的作用域参看上文XML配置中bean标签部分*

### 运行时值注入

Spring提供了两种在运行时求值的方式：

* 属性占位符（Property placeholder）。
* Spring表达式语言（SpEL）。

#### 注入外部的值

处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。

##### Environment

```java
@Configuration
@PropertySource("classpath:/com/soundsystem/app.properties")
public class EnvironmentConfig {
    @Autowired
    Environment env;
    @Bean
    public BlankDisc blankDisc() {
        return new BlankDisc(
                env.getProperty("disc.title"),
                env.getProperty("disc.artist"));
    }
}

```

##### 占位符

**开启**

```xml
<context:property-placeholder location="com/soundsystem/app.properties" />
```

```java
@Configuration
public class EnvConfig {
    @Bean
    public PropertyPlaceholderConfigurer propertyPlaceholderConfigurer() {
        PropertyPlaceholderConfigurer propertyPlaceholderConfigurer = new PropertyPlaceholderConfigurer();
        propertyPlaceholderConfigurer.setLocation(new ClassPathResource("/com/soundsystem/app.properties"));
        return propertyPlaceholderConfigurer;
    }
}
```

**使用**

```xml
<bean class="com.soundsystem.BlankDisc" c:_0 = "${disc.title}" c:_1 = "${disc.artist}"/>
```

```java
public BlankDisc(@Value("${disc.title}") String title,
                 @Value("${disc.artist}") String artist) {
    this.title = title;
    this.artist = artist;
}
```

#### 使用Spring表达式语言进行装配

Spring 3引入了Spring表达式语言（Spring Expression Language，SpEL），SpEL拥有很多特性，包括：

* 使用bean的ID来引用bean
* 调用方法和访问对象的属性
* 对值进行算术、关系和逻辑运算
* 正则表达式匹配
* 集合操作

SpEL可以在@Value注解和xml配置中使用

**SpEL通过ID引用其他的bean。**

```
#{artistSelect.selectArtist()?.toUpperCase()}
```

使用了“?.”运算符。这个运算符能够在访问它右边的内容之前，确保它所对应的元素不是null。所以，如果selectArtist()的返回值是null的话，那么SpEL将不会调用toUpperCase()方法。表达式的返回值会是null。

**要在SpEL中访问类作用域的方法和常量的话，要依赖T()这个关键的运算符。例**

```
T(java.lang.Math).PI
```

**运算符**

| 运算符类型 |                       运　算　符                       |
|------------|--------------------------------------------------------|
| 算术运算   | +、-、 * 、/、%、^                                     |
| 比较运算   | < 、 > 、 == 、 <= 、 >= 、 lt 、 gt 、 eq 、 le 、 ge |
| 逻辑运算   | and 、 or 、 not 、`│`                                   |
| 条件运算   | ?: (ternary) 、 ?: (Elvis)                             |
| 正则表达式 | matches                                                |

```
#{2 * T(java.lang.Math).PI * circle.radius ^ 2}
#{scoreRecord.score > 1000 ? "Winner" : "Loser"}
// 三元运算符的一个常见场景就是检查null值，并用一个默认值来替代null。
#{disk.title ?: 'Rattle and Hum'}
#{user.email mathces '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'}
```

**计算集合**

SpEL还提供了查询运算符（.?[]），它会用来对集合进行过滤，得到集合的一个子集

```
#{jukebox.songs.?[artist eq 'Joe']}
```

SpEL还提供了另外两个查询运算符：“.^[]”和“.$[]”，它们分别用来在集合中查询第一个匹配项和最后一个匹配项

```
#{jukebox.songs.^[artist eq 'Joe']}
```

SpEL还提供了投影运算符（.![]），它会从集合的每个成员中选择特定的属性放到另外一个集合中

```
#{jukebox.songs.![title]}
```

投影操作可以与其他任意的SpEL运算符一起使用

```
#{jukebox.songs.?[artist eq 'Joe'].![title]}
```


## IOC和DI

* IOC：控制反转，把对象创建交给spring配置
* DI：依赖注入，向对象属性中设置值
* 关系：DI不能单独存在，要在IOC基础上完成

## AOP

面向切面编程，采取横向抽取机制，取代了传统纵向继承体系和委托重复性代码（性能监视、事务处理、安全检查、缓存）

### 实现原理

* 针对有接口的情况，使用jdk的动态代理产生接口代理对象
* 针对没有接口的情况，使用cglib产生子类代理对象

直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。

Spring基于动态代理，所以Spring只支持方法连接点。这与一些其他的AOP框架是不同的，例如AspectJ和JBoss，除了方法切点，它们还提供了字段和构造器接入点。
Spring缺少对字段连接点的支持，无法让创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，就无法在bean创建时应用通知。
但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么可以利用Aspect来补充Spring AOP的功能。

### 操作术语

* Joinpoint:连接点，被拦截到的点，在spring中，指的是方法，spring只支持方法类型的拦截点
* Pointcut：切入点，要对哪些连接点进行拦截的定义
* Advice：通知/增强，拦截到连接点所要做的事
    - 前置通知：在方法之前执行
    - 后置通知：在方法之后执行
    - 异常通知：方法出现异常执行
    - 最终通知：后置之后执行
    - 环绕通知：在方法之前和之后执行
* Aspect：切面，是切入点和通知的结合的过程
* Introduction：引介，在运行期动态的添加的方法和Field
* Target：目标对象，代理的目标对象
* Weaving：织入，把增强应用到目标的过程
* Proxy：代理，结果代理类

### 定义切面

Spring借助AspectJ的切点表达式语言来定义Spring切面：

| AspectJ指示器 |                                           描　　述                                           |
|---------------|----------------------------------------------------------------------------------------------|
| arg()         | 限制连接点匹配参数为指定类型的执行方法                                                       |
| @args()       | 限制连接点匹配参数由指定注解标注的执行方法                                                   |
| execution()   | 用于匹配是连接点的执行方法                                                                   |
| this()        | 限制连接点匹配AOP代理的bean引用为指定类型的类                                                |
| target        | 限制连接点匹配目标对象为指定类型的类                                                         |
| @target()     | 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解                           |
| within()      | 限制连接点匹配指定的类型                                                                     |
| @within()     | 限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里） |
| @annotation   | 限定匹配带有指定注解的连接点                                                                 |

![aspectj-perform](/static/img/spring/aspectj-perform.png "aspectj-perform")

![aspectj-within](/static/img/spring/aspectj-within.png "aspectj-within")

使用了“&&”操作符形成与（and）关系，可以使用“`||`”操作符来标识或（or）关系，而使用“!”操作符来标识非（not）操作。  
因为“&”在XML中有特殊含义，所以在Spring的XML配置里面描述切点时，可以使用and来代替“&&”。同样，or和not可以分别用来代替“`||`”和“!”。

Spring还引入了一个新的bean()指示器，它允许我们在切点表达式中使用bean的ID来标识bean。

```
execution(* com.xpress.service.*.do(..) and !bean(excludeBeanId))
```

#### execution常用写法

> execution(<访问修饰符>?<返回类型><方法名>(<参数>)<异常>)

* 匹配所有public方法：execution(public * *(..))
* 匹配指定包下所有类方法,不包含子包：execution(* com.xpress.dao.*(..))
* 匹配指定包下所有类方法,包含子包：execution(* com.xpress.dao..*(..))
* 匹配指定类的所有方法：execution(* com.xpress.dao.UserService.*(..))
* 匹配实现特定接口所有类方法：execution(* com.xpress.dao.UserService+.*(..))
* 匹配所有save开头方法：execution(* save*(..))
* 匹配所有方法：execution(* *.*(..))
* 匹配返回值：execution(java.lang.String *.*(..)) or execution(!void *.*(..))
* 匹配参数：execution(* *.*(java.lang.String,..))


### AOP操作

Spring 2.0以后AOP使用AspectJ实现，AspectJ是一个切面框架，它有一个专门的编译器生成遵循java字节编码规范的class文件

* 基于AspectJ的xml方式
* 基于AspectJ的注解方式

#### 基于AspectJ的xml方式

##### 配置

Spring的AOP配置元素能够以非侵入性的方式声明切面：

|      AOP配置元素 用       |                                   途                                   |
|---------------------------|------------------------------------------------------------------------|
| `<aop:advisor>`           | 定义AOP通知器                                                          |
| `<aop:after>`             | 定义AOP后置通知（不管被通知的方法是否执行成功）                        |
| `<aop:after-returning>`   | 定义AOP返回通知                                                        |
| `<aop:after-throwing>`    | 定义AOP异常通知                                                        |
| `<aop:around>`            | 定义AOP环绕通知                                                        |
| `<aop:aspect>`            | 定义一个切面                                                           |
| `<aop:aspectj-autoproxy>` | 启用@AspectJ注解驱动的切面                                             |
| `<aop:before>`            | 定义一个AOP前置通知                                                    |
| `<aop:config>`            | 顶层的AOP配置元素。大多数的`<aop:*>`元素必须包含在`<aop:config>`元素内 |


引入aop schema

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"> <!-- bean definitions here -->
<!-- 定义advice，实现标记接口org.aopalliance.aop.Advice -->
<bean name="myAdvice" class="com.xpress.advice.MyAdvice"/>
<aop:config>
    <!-- 配置切入点 -->
    <aop:pointcut id="myPointcut"
                  expression="execution(* com.xpress.dao..*(..)) or execution(* com.xpress.dao..*(..))"/>
    <!-- 配置切面 -->
    <aop:aspect ref="myAdvice">
        <!-- 指定切入点和增强的方法 -->
        <aop:before method="before" pointcut-ref="myPointcut"/>
        <!-- 返回之后执行，是否有异常都执行 -->
        <aop:after method="after" pointcut-ref="myPointcut"/>
        <!-- 返回之后执行 -->
        <aop:after-returning method="afterReturn" pointcut-ref="myPointcut"/>
        <!-- 环绕执行 -->
        <aop:around method="around" pointcut-ref="myPointcut"/>
        <!-- 抛出异常后执行 -->
        <aop:after-throwing method="afterThrowing" pointcut-ref="myPointcut"/>
    </aop:aspect>
    <!-- 参数处理 -->
    <bean id="trackCounter" class="com.xpress.aspect.TrackCounter"/>
    <aop:aspect ref="trackCounter">
        <aop:pointcut id="trackPlayed" expression="execution(* com.xpress.CompactDisc.playTrack(list) and args(trackNumber))"/>
        <!-- 指定切入点和增强的方法 -->
        <aop:after method="countTrack" pointcut-ref="trackPlayed"/>
    </aop:aspect>
    <!-- 加入新功能 -->
    <aop:aspect>
        <aop:declare-parents types-matching="com.xpress.Performance+" implement-interface="com.xpress.Encoreable"
            default-impl="com.xpress.aspect.DefaultEncoreableImpl" />
        <!-- default-impl替代 -->
        <!-- delegate-ref="beanId" -->
    </aop:aspect>
</aop:config>
</beans>
```

![xml-aop](/static/img/spring/xml-aop.png "xml-aop")

##### 执行顺序

1. before方法
2. around的target方法前部分
3. target方法
4. around的target方法后部分
5. after-return方法
6. after方法

#### 基于AspectJ的注解方式

* @Before
* @AfterReturning
* @Around
* @AfterThrowing
* @After

开启AspectJ注解

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!-- 开启注解 -->
    <aop:aspectj-autoproxy/>
    <!-- 声明target -->
    <bean id="userDao" class="com.xpress.dao.UserDao"/>
    <!-- 声明切面 -->
    <bean id="myAdvice" class="com.xpress.advice.MyAdvice"/>
</beans>
```

```java
@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class MyAdviceConfig {
    @Bean
    public MyAdvice myAdvice(){
        return new MyAdvice();
    }
}
```
编写切面

```java
@Aspect
public class MyAdvice {
    @Before("execution(* com.xpress.dao..*(..)) || execution(* com.xpress.service..*(..))")
    public void before() {
        System.out.println("before..");
    }
}
```

pointcut形式

```xml
<context:component-scan base-package="com.xpress.service,com.xpress.dao,com.xpress.model,com.xpress.advice"/>
<aop:aspectj-autoproxy/>
```

```java
@Aspect
@Component //加载类，全部使用注解形式
public class AnnounceAdvice {
    //声明一个切入点
    @Pointcut("execution(* com.xpress.service..*(..))")
    private void pointcut() {
    }
    @Before("pointcut() && args(name)")// 获取参数，只会匹配有参数的方法
    public void doAccessCheck(String name) {
        System.out.println("前置通知:" + name);
    }
    @AfterReturning(pointcut = "pointcut()", returning = "result")// 获取返回值，只会匹配有返回值的方法
    public void doAfterReturning(String result) {
        System.out.println("后置通知:" + result);
    }
    @After("pointcut()")
    public void doAfter() {
        System.out.println("最终通知");
    }
    @AfterThrowing(pointcut = "pointcut()", throwing = "e")// 获取异常
    public void doAfterThrowing(Exception e) {
        System.out.println("例外通知:" + e);
    }
    // 你可以不调用proceed()方法，从而阻塞对被通知方法的访问，与之类似，你也可以在通知中对它进行多次调用。
    // 要这样做的一个场景就是实现重试逻辑，也就是在被通知方法失败后，进行重复尝试。
    @Around("pointcut()")
    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("进入方法");
        Object result = pjp.proceed();
        System.out.println("退出方法");
        return result;
    }
}
```

#### 处理参数

```java
public class Player {
    private List<String> musics;
    public void setMusics(List<String> musics) {
        this.musics = musics;
    }
    public void play(int index) {
        System.out.println("playing " + musics.get(index));
    }

}
```

```java
@Aspect
public class PlayerCounter {
    private Map<Integer, Integer> count = new HashMap<>();
    public Map<Integer, Integer> getCount() {
        return count;
    }
    @Pointcut("execution(* com.xpress.Player..*(int)) && args(index)")
    public void playCount(int index) {
    }
    @After(value = "playCount(index)", argNames = "index")
    public void saveCount(int index) {
        Integer value = 1;
        if (count.containsKey(index)) {
            value = count.get(index) + 1;
        }
        count.put(index, value);
    }
}
```

```java
@Configuration
@EnableAspectJAutoProxy
public class PlayerConfig {
    @Bean
    public Player player() {
        ArrayList<String> musics = new ArrayList<>();
        musics.add("music 0");
        musics.add("music 1");
        musics.add("music 2");
        musics.add("music 3");
        musics.add("music 4");
        musics.add("music 5");
        Player player = new Player();
        player.setMusics(musics);
        return player;
    }
    @Bean
    public PlayerCounter playerCounter() {
        return new PlayerCounter();
    }
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {PlayerConfig.class})
public class AspectjTest {
    @Autowired
    private Player player;
    @Autowired
    private PlayerCounter playerCounter;
    @Test
    public void testAspectJ() {
        player.play(1);
        player.play(1);
        player.play(2);
        player.play(3);
        player.play(5);
        player.play(2);
        System.out.println(playerCounter.getCount());
    }
}

```

#### 功能增强

```java
public interface Encoreable {
    void performEncore();
}
public class DefaultEncoreableImpl implements Encoreable {
    @Override
    public void performEncore() {
        System.out.println("perform....");
    }
}
```

```java
@Aspect
public class EncoreableIntroducer {
    @DeclareParents(value = "com.xpress.Player+", defaultImpl = DefaultEncoreableImpl.class)
    private Encoreable encoreable;
}
```

```java
@Around(value = "playCount(index)", argNames = "pjp,index")
public Object testEncore(ProceedingJoinPoint pjp, int index) {
    if (pjp.getThis() instanceof Encoreable) {// 可以在类似地方判断代理类是个增强后的实现类
        ((Encoreable) pjp.getThis()).performEncore();
    }
    //...
}
```

@DeclareParents注解由三部分组成：

* value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现Performance的类型。（标记符后面的+号表示是Performance的所有子类型，而不是Performance本身。）
* defaultImpl属性指定了为引入功能提供实现的类。在这里，我们指定的是DefaultEncoreable提供实现。
* @DeclareParents注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是Encoreable接口。

## 数据源配置

### jdbc.properties

```xml
<!-- 指定配置文件位置 -->
<context:property-placeholder location="classpath:jdbc.properties"/>
<!--datasource-->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
    <!-- 连接池启动时的初始值 -->
    <property name="initialSize" value="${jdbc.initialSize}"/>
    <!-- 连接池的最大值 -->
    <property name="maxActive" value="${jdbc.maxActive}"/>
    <!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 -->
    <property name="maxIdle" value="${jdbc.maxIdle}"/>
    <!-- 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 -->
    <property name="minIdle" value="${jdbc.minIdle}"/>
</bean>
<!--name-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="datasource"/>
</bean>
<!--dao-->
<bean id="userDao" class="com.xpress.dao.UserDao">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
</bean>
```

注入properties值

```java
@Value("${redis.creative.tag.rel}")
private static String CREATIVE_TAG_PREFIX;
@Value("${redis.creative.classify.rel}")
private static String CREATIVE_CLASSIFY_PREFIX;
```

### jndi

jndi方式配置数据源交个容器管理，如tomcat的context.xml中配置连接池属性

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:jee="http://www.springframework.org/schema/jee"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd 
        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd"
       default-lazy-init="true">

    <jee:jndi-lookup id="datasourceJndi" jndi-name="tomcatJndi" resource-ref="true"/>
    <bean id="dataSourceJndi" class="org.springframework.jndi.JndiObjectFactoryBean">
        <!--关联datasourceJndi配置-->
        <property name="jndiName" ref="datasourceJndi"/>
        <!--通过name直接配置-->
        <property name="jndiName" value="tomcatJndi"/>
    </bean>
</beans>
```

## 事务管理

### TransactionManager

|                            事务管理器                            |                             说明                            |
|------------------------------------------------------------------|-------------------------------------------------------------|
| org.springframework.jdbc.datasource.DataSourcetransactionManager | 使用spring jdbc或ibatis进行持久化数据时                     |
| org.springframework.orm.hibernate5.HibernatetransactionManager   | 使用hibernate5.0版本进行持久化                              |
| org.springframework.orm.jpa.JpaTransactionManager                | 使用JPA进行持久化时使用                                     |
| org.springframework.orm.jdo.JdoTransactionManager                | 持久化机制是Jdo时                                           |
| org.springframework.transaction.jta.JtaTransactionManager        | 使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用 |

### XML配置方式

```xml
<!--配置transactionManager事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="datasource"/>
</bean>
<!--配置advice-->
<tx:advice id="myTxAdvice">
    <tx:attributes>
        <tx:method name="get*" propagation="SUPPORTS"/>
        <tx:method name="delete*" propagation="REQUIRED"/>
        <tx:method name="update*" propagation="REQUIRED"/>
        <tx:method name="add*" propagation="REQUIRED"/>
        <tx:method name="*_FOR_NEW_TRANSACTION" propagation="REQUIRES_NEW"/>
    </tx:attributes>
</tx:advice>
<!--配置切面-->
<aop:config>
    <!-- 配置切入点 -->
    <aop:pointcut id="myTxPointcut" expression="execution(* com.xpress.service..*(..))"/>
    <!-- 配置切面 -->
    <aop:advisor advice-ref="myTxAdvice" pointcut-ref="myPointcut"/>
</aop:config>
```

### 注解方式

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"
       default-lazy-init="true" default-autowire="byName">
    <!--配置transactionManager-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="datasource"/>
    </bean>
    <!-- 开启事务注解 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
</beans>
```

```java
// 添加事务控制注解
@Transactional(rollbackFor = ServiceException.class)
public class UserDao {
    private JdbcTemplate jdbcTemplate;
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    public void updateUser() {
        int n = jdbcTemplate.update("UPDATE users SET username = 'smith' WHERE id=2");
        System.out.println(n);
    }
}
```

#### @Transactional

* rollbackFor = ServiceException.class 指定回滚的异常类型
* noRollbackFor = NoRollbackException.class 指定不会滚的异常类型
* propagation = Propagation.REQUIRED 指定事务传播性
* readOnly = true 设置是否只读事务，只读事务只能读取
* timeout = 10000 事务超时时间 seconds
* isolation = Isolation.READ_COMMITTED 数据库的隔离级别

### 事务控制

* 默认回滚RuntimeException，checked Exception不会回滚

#### 事务传播属性

* REQUIRED
    - 业务方法需要在一个事务中运行，如果方法运行时已经存在一个事务中，则加入到该事务，否则自己创建一个事务
* NOT_SUPPORTED
    - 声明方法不需要事务，如果方法没有关联到一个事务，容器不会为它开启事务，如果方法在一个事务中被调用，该事务会被挂起，方法执行结束后，原先的事务恢复执行
* REQUIRES_NEW
    - 不管是否存在事务，业务方法总会为自己发起一个新的事务，如果方法已经运行在一个事务中，则原有的事务会被挂起，新的事务会被创建，直到方法执行结束，新事务才算结束，原先的事务恢复执行
* MANDATORY
    - 业务方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务，如果业务方法没有在事务环境下调用，容器会抛出异常
* SUPPORTS
    - 如果业务方法在某个事务范围内被调用，则方法称为该事务的一部分，如果业务方法没有在事务范围内被调用，则方法在没有事务的环境下执行
* NEVER
    - 业务方法绝对不能在业务范围内执行，如果业务方法在某个事务中执行，容器会抛出异常
* NESTED
    - 如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动的事务，则按REQUIRED属性执行，它使用了单独的事务，这个事务拥有多个可回滚的保存点，内部事务回滚不会对外部事务造成影响，它只对DataSourceTransactionManager有效

## 乱码处理

配置CharacterEncodingFilter过滤器

```xml
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## i18n

```xml
<!-- 配置资源文件 -->
<!-- As an alternative to ResourceBundleMessageSource, 
     Spring provides a ReloadableResourceBundleMessageSource class. 
     This variant supports the same bundle file format but is more flexible 
     than the standard JDK based ResourceBundleMessageSource implementation. 
     In particular, it allows for reading files from any Spring resource location (not just from the classpath) 
     and supports hot reloading of bundle property files  -->
<bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name="basenames">
        <list>
            <!--xpress.properties
                xpress_en_US.properties
                xpress_zh_CN.properties-->
            <value>xpress</value>
            <!-- ReloadableResourceBundleMessageSource -->
            <!-- <value>classpath:xpress</value> -->
        </list>
    </property>
    <!--Set whether to use the message code as default message instead of throwing a NoSuchMessageException.-->
    <property name="useCodeAsDefaultMessage" value="true" />
</bean>
<!-- MessageSourceAccessor提供了省略Locale的调用方法 -->
<bean id="messageSourceAccessor" class="org.springframework.context.support.MessageSourceAccessor">
    <constructor-arg ref="messageSource" name="messageSource"/>
</bean>
```

```java
// 默认Locale
messageSource.getMessage("welcome", new Object[]{"admin", new Date()}, Locale.SIMPLIFIED_CHINESE);
new MessageSourceAccessor(messageSource).getMessage("welcome", new Object[]{"admin", new Date()});
// 当前ActionContext Locale
messageSource.getMessage("welcome", new Object[]{"admin", new Date()}, ActionContext.getContext().getLocale());
messageSourceAccessor.getMessage("welcome", new Object[]{"admin", new Date()}, ActionContext.getContext().getLocale());
```

## 事件发布及处理

spring event 可以简单实现业务解耦

Event handling in the `ApplicationContext` is provided through the `ApplicationEvent` class and `ApplicationListener` interface.

spring提供的默认事件

* ContextRefreshedEvent
* ContextStartedEvent
* ContextStoppedEvent
* ContextClosedEvent
* RequestHandledEvent

![event](/static/img/spring/event.png "event")

### 实现Spring事件发布

开启事务异步处理注解支持

```xml
<!-- 开启@AspectJ AOP代理 -->
<aop:aspectj-autoproxy/>
<!-- 任务调度器 -->
<task:scheduler id="scheduler" pool-size="10"/>
<!-- 任务执行器 -->
<task:executor id="executor" pool-size="10"/>
<!--开启注解调度支持 @Async @Scheduled-->
<task:annotation-driven executor="executor" scheduler="scheduler"/>
```

事件发布器实现接口ApplicationEventPublisherAware

```java
@Service("eventPublisherService")
public class EventPublisherServiceImpl implements EventPublisherService,ApplicationEventPublisherAware {
    private ApplicationEventPublisher applicationEventPublisher;

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {

        this.applicationEventPublisher = applicationEventPublisher;
    }

    public void executePublicEvent(ApplicationEvent event) {
        applicationEventPublisher.publishEvent(event);
    }
}
```

自定义事件

```java
public class MyEvent extends ApplicationEvent {
    private String eventCode;
    public MyEvent(Object source, String eventCode) {
        super(source);
        this.eventCode = eventCode;
    }
}
```

定义事件监听器

```java
@Component
public class MyEventListener implements ApplicationListener<MyEvent> {
    @Override
    @Async // 注解异步处理
    public void onApplicationEvent(MyEvent event) {
        System.out.println(event.getSource());// do something..
    }
}
//Spring 4.2以后
@EventListener(condition = "#event.shouldSendMsg")
public void afterRegisterSendMail(MessageEvent event) {
     mailService.send(event.getUser().getEmail(),"register successful");
}
```


### 异步

#### 全局异步

```xml
<!-- 任务执行器 -->
<task:executor id="executor" pool-size="10"/>
<!-- 名字必须是applicationEventMulticaster和messageSource是一样的，默认找这个名字的对象 -->
<!-- 名字必须是applicationEventMulticaster，因为AbstractApplicationContext默认找个 -->
<!-- 如果找不到就new一个，但不是异步调用而是同步调用 -->
<bean id="applicationEventMulticaster" class="org.springframework.context.event.SimpleApplicationEventMulticaster">
    <!-- 注入任务执行器 这样就实现了异步调用（缺点是全局的，要么全部异步，要么全部同步（删除这个属性即是同步））  -->
    <property name="taskExecutor" ref="executor"/>
</bean>
```

#### 非全局异步

见实现Spring事件发布部分，开启注解并根据@Async注解实现异步处理，非注解为同步处理

### 有序

实现SmartApplicationListener接口即可。  
或者使用@Order注解

### 事务控制

* 同步：同步会延用已经存在的事务控制
    - 在service中发布同步事件，事件处理中调用service，则在一个事务中处理
* 异步：分别开启不同的连接进行处理
    - 推荐开启第一个事务处理，结束后发布事件，防止在第一个事务中发布事件而事件执行时机不可预知第一个事务数据不能被事务处理读取的问题
    - 监控事务提交后处理事件

**监控事务提交后处理事件**

```java
@EventListener
public void afterRegisterSendMail(MessageEvent event) {
    // Spring 4.2 之前
    if (TransactionSynchronizationManager.isActualTransactionActive()) {
        TransactionSynchronizationManager.registerSynchronization(
                new TransactionSynchronizationAdapter() {
                    @Override
                    public void afterCommit() {
                        mailService.send(event);
                    }
                });
    } else {
        mailService.send(event);
    }
}
```

```java
// Spring 4.2 +
// BEFORE_COMMIT
// AFTER_COMMIT
// AFTER_ROLLBACK
// AFTER_COMPLETION
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void afterRegisterSendMail(MessageEvent event) {
    mailService.send(event);
}
```

## 框架整合

参看整合框架对应篇幅

------

*以上概念总结于传智播客Spring课程*