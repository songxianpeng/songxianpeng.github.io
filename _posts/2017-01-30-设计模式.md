---  
layout: post  
title: 设计模式  
tags: 设计模式  
categories: Java  
published: true  
---  

设计是有限度的，不能无限的考虑未来的变更情况，否则会陷入射击的泥潭而不能自拔

## 面向对象思想设计原则

* 单一职责原则(高内聚，低耦合)
	- 每个类（也适用于方法）应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个
		+ 职责和变化原因都是不可度量的，因项目和环境而异
		+ 会引起类的剧增
	- 最佳实践：接口一定要做到单一职责，类尽量做到单一职责
* 开闭原则
	- 一个对象对扩展开放，对修改关闭，对类的改动是通过增加代码进行的，而不是修改现有代码
		+ 借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展
		+ 抽象约束
			* 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现再接口或抽象类中不存在的public方法
			* 参数类型、引用对象尽量使用接口或抽象类
			* 抽象层尽量保持稳定，一旦确定即不允许修改
		+ 封装变化
			* 将相同的变化封装到同一个接口或抽象类中
			* 将不同的变化封装到不同的接口或抽象类中的，不应该有两个不同的变化出现再同一个接口或抽象类中
* 里氏替换原则
	- 在任何父类出现的地方都可以用它的子类来替代
		+ 子类必须完全实现父类的方法
		+ 子类可以有自己的个性
		+ 覆盖或实现父类的方法时输入参数可以被放大（不建议适用，子类不应对父类方法不应该重载，违背父类意图）
			* 子类中方法的前置条件必须与超类中的方法的前置条件相同或者更宽松（子类重载时参数要求要比父类方法宽泛）
		+ 覆写或实现父类的方法时输出结果可以被缩小
	- 最佳实践：避免子类个性化，如果必要个性化，重新提取一个父类
* 依赖倒置原则
	- 要依赖于抽象，不要依赖于具体实现
		+ 编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。
		+ 高层模块不应该依赖低层模块，两者都应该依赖其抽象
			* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口和抽象类产生的
		+ 抽象不应该依赖细节
			* 接口或抽象类不依赖于实现类
		+ 细节应该依赖抽象
			* 实现类依赖接口或抽象类
	- 最佳实践
		+ 每个类尽量都有接口或抽象类，或者兼备
		+ 变量的表面类型尽量是接口或抽象类
			* Util类一般不需要，如果使用类的clone方法，必须使用实现类，这是JDK提供的一个规范
		+ 尽量避免从具体类派生
		+ 尽量不要覆写基类的方法
		+ 结合里氏替换原则使用
* 接口分离原则
	- 不应该强迫程序依赖它们不需要使用的方法
		+ 一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中
		+ 客户端不应该依赖它不需要的接口
		+ 类间的依赖关系应该建立在最小的接口上
	- 最佳实践：
		+ 一个接口只服务与一个子模块和业务逻辑
		+ 通过业务逻辑压缩接口中的pulic方法
		+ 已经被污染了的接口，尽量去修改，若变更的风险很大，则采用适配器模式去转化处理
* 迪米特原则(最少知识原则)
	- 一个对象应当对其他对象尽可能少的了解
		+ 降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用
	- 最佳实践：
		+ 是否可以减少public方法和属性，修改未private、package-private、protected等访问权限，是否可以加上final关键字等
		+ 如果一个方法在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置再本类中

### 设计原则（Head first设计模式）

* 找出程序中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起
* 针对接口编程，而不是针实现编程
* 多用组合，少用继承
* 为了交互对象之前的松耦合设计而努力
	- 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低
* 类应该对扩展开放，对修改关闭
* 要依赖抽象，不要依赖具体类（依赖倒置原则）
	- 变量不可以持有具体类的引用
	- 不要让类派生自具体类
	- 不要覆盖基类中已实现的方法
* 最少知识原则（墨忒耳法则）
	- 减少对象之间的交互（减少对象之间耦合）
	- 只调用以下范围的方法
		+ 该对象本身
		+ 被当做方法的参数而传递进来的对象
		+ 此方法所创建或实例化的任何对象
		+ 对象的任何组件（被实例变量的引用）
	- 会增加封装用于和其他对象交互，复杂度和开发时间上升，并降低了运行时性能
* 好莱坞原则
	- 高层组件对低层组件的依赖方式是：别调用我们，我们会调用你
* 一个类应该只有一个引起变化的原因，尽量让每个类保持单一职责
	- 当一个模块或一个类被设计成只支持一组相关的功能时，我们说他具有高内聚，反之，当被设计成支持一组不相关的功能时，我说他具有低内聚

### 复用机制

* 继承
	- 白箱复用
	- 破坏了封装性
	- 父类子类依赖紧密，父类改变会影响子类
* 对象组合
	- 黑箱复用
	- 不破坏封装性
	- 依赖接口而解耦
	- 有助于保持每个类被封装，并集中在单个任务上
	- 动态的参数化的软件比静态的软件难于理解
	- 运行时效率低（主要）
	- 委托是对象组合的特例

**优先使用对象组合，而不是类继承**

## 设计模式总览

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。  
模式是在某情境下，针对某问题的某种解决方案

### 设计模式分类

* 创建型模式(对象的创建)(5个)
	- 简单工厂模式（静态工厂方法模式）(Simple Factory)
		+ 简单工厂模式不是GoF总结出来的23种设计模式之一
	- 工厂方法模式(Factory Method)
		+ 注重整体对象的创建方法
	- 抽象工厂模式(Abstract Factory)
		+ 创建具有不同分类的产品组合
	- 建造者模式(Builder)
		+ 旨在一步步的精确构造出一个复杂对象
	- 原型模式(Prototype)
	- 单例模式(Singleton)
* 结构型模式(处理类或对象的组合)(7个)
	- 外观模式(Facade)
		+ 封装和隔离内部业务
	- 适配器模式(Adatper)
		+ 不同对象之间相互转换
	- 代理模式(Proxy)
		+ 对代理对象具有控制权
	- 装饰模式(Decorator)
		+ 对类功能的增强或减弱
	- 桥接模式(Bridge)
		+ 解耦抽象与实现
		+ 两个维度的排列组合问题
	- 组合模式(Composite)
		+ 屏蔽部分与整体间的差别
	- 享元模式(Flyweight)
* 行为型模式(类或对象的交互和职责分配)(11个)
	- 模版方法模式(Template Method)
	- 观察者模式(Observer)
	- 状态模式(State)
		+ 封装状态变化，暴漏行为
	- 职责链模式(Chain of Responsibility)
	- 命令模式(Command)
		+ 使用命令将调用者和执行者解耦
	- 访问者模式(Visitor)
	- 策略模式(Strategy)
		+ 封装算法，实现算法自由替换
	- 备忘录模式(Memento)
	- 迭代器模式(Iterator)
	- 解释器模式(Interpreter)
	- 中介者模式(Mediator)
		+ 协调同事类之间关系

|          |  创建型  |     结构性     |  行为型  |
|----------|----------|----------------|----------|
| 用于类   | 工厂方法 | 适配器 （类）  | 解释器   |
|          |          |                | 模板方法 |
| 用于对象 | 抽象工厂 | 适配器（对象） | 责任链   |
|          | 创建者   | 桥接           | 命令     |
|          | 原型     | 组合           | 迭代器   |
|          | 单例     | 装饰           | 中介者   |
|          |          | 外观           | 备忘录   |
|          |          | 享元           | 观察者   |
|          |          | 代理           | 状态     |
|          |          |                | 策略     |
|          |          |                | 访问者   |

* 类模式用户处理类和子类之间的关系，这些关系通过继承建立，是静态的，编译时就确定下来了
* 对象模式处理对象之间的关系，这些关系具有动态性，运行时可变化

![relation](/static/img/Pattern/relation.jpg "relation")

### 如何选用设计模式

1. 考虑设计模式是怎样解决问题的
2. 浏览模式的意图部分
3. 研究模式怎样互相关联
4. 研究目的相似的模式
5. 检查重新设计的原因
6. 考虑设计中哪些是可以改变的

| 目的 |         设计模式        |                        可变的方面                        |
|------|-------------------------|----------------------------------------------------------|
| 创建 | Abstract Factory        | 产品对象家族                                             |
|      | Builder                 | 创建一个组合对象                                         |
|      | Factory Method          | 被实例化的子类                                           |
|      | Prototype               | 被实例化的类                                             |
|      | Singleton               | 一个类的唯一实例                                         |
| 结构 | Adapter                 | 对象的接口                                               |
|      | Bridge                  | 对象的实现                                               |
|      | Composite               | 一个对象的结构和组成                                     |
|      | Decorator               | 一个对象的职责，不生成子类                               |
|      | Facade                  | 一个子系统的接口                                         |
|      | Flyweight               | 对象的存储开销                                           |
|      | Proxy                   | 如何访问一个对象；对象的位置                             |
| 行为 | Chain of Responsibility | 满足一个请求的对象                                       |
|      | Command                 | 何时、怎样满足一个请求                                   |
|      | Interpreter             | 一个语言的问法及解释                                     |
|      | Iterator                | 如何编译、访问一个聚合的各元素                           |
|      | Mediator                | 对象间怎样交互、和谁交互                                 |
|      | Memento                 | 一个对象中那些私有信息存放在对象之外，什么时候存储       |
|      | Observer                | 多个多想依赖于另外一个对象，而这些对象又如何保持一致     |
|      | State                   | 对象的状态                                               |
|      | Strategy                | 算法                                                     |
|      | Template Method         | 算法中的某些步骤                                         |
|      | Visitor                 | 某些可作用于一个（组）对象上的操作，但不修改这些对象的类 |

### 如何使用设计模式

1. 大致浏览一遍模式
2. 回头去研究结构部分、参与者部分和写作部分
3. 看代码示例部分、看看这个模式代码形式的具体例子
4. 选择模式参与者的名字，使他们自应用上下文中有意义
5. 定义类
6. 定义模式中专用于应用的操作名称
7. 实现执行模式中责任和写作的操作

## 设计模式分类

### 简单工厂模式（静态工厂方法模式）

所有工厂模式都用来封装对象的创建

简单工厂模式又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责

* 缺点
	- 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护

```java
public class AnimalFactory {

	private AnimalFactory() {
	}

	// public static Dog createDog() {
	// return new Dog();
	// }
	//
	// public static Cat createCat() {
	// return new Cat();
	// }

	public static Animal createAnimal(String type) {
		if ("dog".equals(type)) {
			return new Dog();
		} else if ("cat".equals(type)) {
			return new Cat();
		} else {
			return null;
		}
	}
}

```

### 工厂方法模式

工厂方法模式定义了创建对象的接口，但由子类决定要实例化的是哪一个，工厂方法让类把实例化推迟到子类

* 优点
	- 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性

* 缺点
	- 需要额外的编写代码，增加了工作量

```java
public abstract class AbstractFactory {
    public abstract <T extends Product> T createProduct(Class<T> clazz);
}

public class ConcreteFactory extends AbstractFactory {
    @Override
    public <T extends Product> T createProduct(Class<T> clazz) {
        try {
            return (T) Class.forName(clazz.getName()).newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
}

public abstract class Product {
    public void method1() {
        System.out.println("method1");
    }
    public abstract void method2();
}

public class ConcreteProduct1 extends Product {
    @Override
    public void method2() {
        System.out.println("method2");
    }
}
```

```java
AbstractFactory abstractFactory = new ConcreteFactory();
ConcreteProduct1 product = abstractFactory.createProduct(ConcreteProduct1.class);
product.method1();
product.method2();
```

### 抽象工厂模式

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

* 有N个产品族，在抽象工厂类中就应该有N个创建方法
* 有M个产品等级，就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务
* 产品族扩展困难，而产品等级扩展容易


```java
public interface AbstractFactory {
	public abstract Product createProductA();
	public abstract Product createProductB();
}
```

```java
public interface Product {
	public abstract void method();
}
```

```java
public class Product1Factory implements AbstractFactory {
	@Override
	public Product createProductA() {
		return new ConcreteProduct1();
	}
	@Override
	public Product createProductB() {
		return new ConcreteProduct2();
	}
}
```

```java
public class Product2Factory implements AbstractFactory {
	@Override
	public Product createProductA() {
		return new ConcreteProduct3();
	}
	@Override
	public Product createProductB() {
		return new ConcreteProduct4();
	}
}
```

```java
AbstractFactory f = new ConcreteProduct1Factory();
Product a = f.createProductA();
a.method();

f = new ConcreteProduct2Factory();
a = f.createProductB();
a.method();
```

### 工厂方法模式和抽象工厂模式

* 工厂方法模式通过子类创建对象，抽象工厂通过实现类（对象组合）创建对象
* 抽象工厂的方法常以工厂方法模式实现
* 抽象工厂和工厂方法用于实例化具体类的解耦
* 抽象工厂用于创建产品家族和想让制造的相关产品集合起来

> 所有的工厂模式都是用来封装对象的创建  
> 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦  
> 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象  
> 抽象工厂使用组合：对象的创建被实现在工厂接口所暴漏出来的方法中  
> 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合  
> 工厂方法允许类将实例化延迟早子类进行  
> 抽象工厂创建相关的对象家族，而不需要依赖他们的具体类  
> 依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象  
> 工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体编程  

### 创建者模式(生成器模式)

创建者模式封装一个产品的构造过程，并允许按步骤构造  
将一个复杂对象的创建与他的表示分离，使得同样的构建过程可以创建不同的表示

* 优点：
	- 将一个复杂对象的创建过程封装起来
	- 允许通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）
	- 向客户隐藏产品内部的实现
	- 产品的实现可以被替换，因为客户只看到一个抽象的接口
* 缺点：
	- 采用创建者模式创建对象的客户，需要具备更多的领域知识

```java
public interface CarBuilder {
    CarBuilder buildWheel();
    CarBuilder buildEngine();
    CarBuilder buildSeats(int number);
    CarBuilder buildContainer();
    Car getCar();
}
```

```java
public class Car {
    List<String> config = new ArrayList<>();
    public void addConfig(String config) {
        this.config.add(config);
    }
    @Override
    public String toString() {
        return config.stream().reduce("", (x, y) -> x.concat(y).concat("\r\n"));
    }
}

```

```java
public class TrunkBuilder implements CarBuilder {
    private Car car = new Car();
    @Override
    public CarBuilder buildWheel() {
        car.addConfig("car has a big wheel");
        return this;
    }
    @Override
    public CarBuilder buildEngine() {
        car.addConfig("car has a little engine");
        return this;
    }
    @Override
    public CarBuilder buildSeats(int number) {
        car.addConfig(MessageFormat.format("car has a {0} seats", number));
        return this;
    }
    @Override
    public CarBuilder buildContainer() {
        car.addConfig("car has a big containers");
        return this;
    }
    @Override
    public Car getCar() {
        return car;
    }
}

```


```java
Car car = new TrunkBuilder().buildContainer()
        .buildEngine()
        .buildSeats(3)
        .buildWheel()
        .getCar();
System.out.println(car);
car = new TrunkBuilder()
        .buildEngine()
        .buildWheel()
        .getCar();
System.out.println(car);
```

### 原型模式

在创建给定类的实例的过程很昂贵或复杂时，使用原型模式  
原型模式常用来代替抽象工厂  

* 用途：
	- 在一个复杂的类层次中，当系统不惜从其中的许多类型创建新对象时，可以考虑原型
* 优点：
	- 向客户隐藏制造新实例的复杂性
	- 提供让客户能够产生位置类型对象的选项
	- 在某些环境下，复制对象比创建新对象更有效
	- 性能优良
* 缺点：
	- 对象复制有时相当复杂
	- 逃避了构造函数的约束（也可做优点）
* 注意事项：
	- 构造函数不会被执行
	- 深拷贝和浅拷贝问题
	- clone和final冲突（手动拷贝时无法赋值，下面的方式无视）

```java
public interface Prototype {
    Object clone();
}
```

```java
public class ConcretePrototype implements Prototype, Cloneable, Serializable {
    private static final long serialVersionUID = 7231405363797237036L;
    @Override
    public Object clone() {
    	    // 使用json序列化
    	    // Gson gson = new Gson();
    	    // return gson.fromJson(gson.toJson(this), this.getClass());

    	    // 使用流
        try (
                //将对象写到流里
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                ObjectOutputStream oos = new ObjectOutputStream(bos);
        ) {
            oos.writeObject(this);
            try (//从流里读回来
                 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
                 ObjectInputStream ois = new ObjectInputStream(bis);
             ) {
                return ois.readObject();
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

```java
public class PrototypeManager {
	// Singleton implements
    private Map<String, Prototype> prototypeMap = new HashMap<>();
    public void addPrototype(String name, Prototype prototype) {
        prototypeMap.put(name, prototype);
    }
    public void removePrototype(String name) {
        prototypeMap.remove(name);
    }
    public Prototype getPrototype(String name) {
        return (Prototype) prototypeMap.get(name).clone();
    }
}

```

```java
public class Client {
    public static void main(String[] args) {
        PrototypeManager prototypeManager = new PrototypeManager();
        prototypeManager.addPrototype("first",new ConcretePrototype());
        Prototype first = prototypeManager.getPrototype("first");
    }
}
```

### 单例模式

确保一个类只有一个实例，并提供一个全局访问点  
单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。

* 优点
	- 在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
	- 可以延迟实例化0
* 缺点
	- 没有抽象层，因此扩展很难。
	- 职责过重，在一定程序上违背了单一职责

> 单例模式确保程序中一个类最多只有一个实例  
> 单例模式也提供访问这个实例的全局点  
> 在Java中实现单例模式需要私有的狗仔器、一个静态方法和一个静态变量  
> 确定在性能和资源上的限制，然后小心的选择适当的方案来实现单例，以解决多线程的问题（我们必须认定所有的程序都是多线程）  
> 如果不采用第五版以后的Java2，双重检查加锁的实现会失效  
> 小心，如果你使用多个类加载器，可能导致单例失效而产生多个实例  
> 如果使用JVM1.2或之前的版本，你必须建立单例注册表，以免垃圾回收器将单例回收  

#### 设计思想

保证类在内存中只有一个对象

**如何实现类在内存中只有一个对象呢?**

* 构造私有
* 本身提供一个对象
* 通过公共的方法让外界访问

#### 饿汉式(开发)

```java
public class Singleton {
	// 构造私有
	private Singleton() {
	}

	// 自己造一个
	// 静态方法只能访问静态成员变量，加静态
	// 为了不让外界直接访问修改这个值，加private
	private static Singleton s = new Singleton();

	// 提供公共的访问方式
	// 为了保证外界能够直接使用该方法，加静态
	public static Singleton getSingleton() {
		return s;
	}
}
```

#### 懒汉式

线程安全问题

懒加载思想(延迟加载)

```java
public class Singleton {
	private Singleton() {
	}
	// 使用volatile禁止指令重排
	private volatile static  Singleton t = null;
	// 锁范围较大
	public synchronized static Singleton getSingleton() {
		if (t == null) {//这里有线程安全问题 所以要枷加锁
			t = new Singleton();
		}
		return t;
	}
	// 缩小锁范围，但是要做双重检查 jdk 1.5以后有效
	public static Singleton getSingleton() {
		if (t == null) {
			synchronized(Singleton.class){
				if (t == null) {// 双重检查
					t = new Singleton();
				}
			}
		}
		return t;
	}
}
```

#### 内部类方式（static holder）

既支持了延迟加载，也是线程安全的，较完美的解决方案

> **多线程缺省同步锁的知识：**
> 解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制，但是在某些情况下，JVM已经隐含的为您执行了同步，不用自己再来进行同步控制。  
> 
> 1. 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时  
> 2. 访问final字段时  
> 3. 在创建线程之前创建对象时  
> 4. 线程可以看见它将要处理的对象时  

> 要想很简单的实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是会浪费一定的时间空间？因为这种实现方式，会在类装载的时候就初始化对象。

> 一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同步实现延迟加载和线程安全。

```java
public class Singleton {
    private static class StaticHolder {
        private static Singleton instance;
        static {
            instance = new Singleton();
        }
    }
    private Singleton(){
    }
    public static Singleton getInstance() {
        return StaticHolder.instance;
    }
}
```

#### 枚举式（推荐）

好处

1. 线程安全（枚举底层是线程安全的）
2. 不会因为序列化而产生新的实例（因为它自己实现了readResolve方法）
3. 防止反射攻击。（因为enum实际上是abstract的）

```java
public enum Singleton {
    INSTANCE;
    Singleton() {
    }
    public void operate() {
    }
}
```

#### 类加载器和jdk1.2垃圾回收问题

*多个类加载器会在各自的命名空间下加载同一个类，造成存在一个类的多一个实例*

解决：指定同一个类加载器加载

*JDK1.2之前会将单例模式认为是没有引用而回收，再次getInstance()又创建一个对象*

解决：建立单例注册表...使用全局引用指向单例？

### 外观模式（门面模式）

提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用  
外观不只是简化接口，也将客户端从组件的子系统中解耦  

* 使用场景：
	- 为一个复杂的模块或子系统提供一个供外界访问的接口
	- 子系统相对独立，外界黑箱操作
* 优点：
	- 减少系统的相互依赖
	- 提高了灵活性
	- 提高安全性
* 缺点：
	- 违反开闭原则，有问题要修改门面类
* 最佳实践：
	- 门面十分庞大或子系统可以提供不同的访问路径时，使用多个门面
	- 门面不应参与业务，如果需要就多封装一层，防止子系统业务对门面的依赖

```java
public class ProgramFacade {
    private Designer designer;
    private Programmer programmer;
    private Tester tester;
    private Operator operator;
    public ProgramFacade(Designer designer, Programmer programmer, Tester tester, Operator operator) {
        this.designer = designer;
        this.programmer = programmer;
        this.tester = tester;
        this.operator = operator;
    }
    public void buildProgram(Program program){
        // 这里最好再封装一层，防止依赖倒置
        designer.design(program);
        programmer.program(program);
        tester.test(program);
        operator.operate(program);
    }
    public void shutdownProgram(Program program){
        operator.shutdown(program);
    }
}

```

### 适配器模式

将一个类的接口转换成另外一个客户希望的接口。从而使原来不能直接调用的接口变的可以调用。  
适配器有两种形式：对象适配器和类适配器，对象适配器使用组合，类适配器需要多继承  

* 优点
	- 让本来不适合使用的接口变得适合使用
* 缺点
	- 一次只能适配一个类，使用有一定的局限性


*接口实现类适配*

```java
/*
 * 针对用户操作的四种功能接口
 */
public interface UserDao {
	public abstract void add();
	public abstract void delete();
	public abstract void update();
	public abstract void find();
}
```

```java
//适配器类
public abstract class UserAdapter implements UserDao {
	@Override
	public void add() {
	}
	@Override
	public void delete() {
	}
	@Override
	public void update() {
	}
	@Override
	public void find() {
	}
}
```

```java
// 适配器模式实现类
public class UserDaoImpl2 extends UserAdapter {
	@Override
	public void add() {
		System.out.println("添加功能");
	}
}
```

*不同接口转换适配*

```java
public class EnumerationIteratorAdaptor implements Iterator {
    private Enumeration enumeration;
    public EnumerationIteratorAdaptor(Enumeration enumeration) {
        this.enumeration = enumeration;
    }
    public boolean hasNext() {
        return enumeration.hasMoreElements();
    }
    public Object next() {
        return enumeration.nextElement();
    }
    public void remove() {
        throw new UnsupportedOperationException("adapter not implement method");
    }
}
```

### 适配器模式和外观模式

外观和适配器可以包装许多类，但是外观的意图是简化接口，而是配置的意图是将接口转换成不同接口

> 当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器  
> 当需要简化并统一一个很大的接口或者一群复杂的接口是，使用外观  
> 适配器改变接口以符合客户的期望  
> 外观将客户从一个复杂的子系统中解耦  
> 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定  
> 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行  
> 适配器模式有两种形式：对象适配器和类适配器，类适配器需要用到多重继承  
> 你可以为一个子系统实现一个以上的外观  
> 适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以新增行为和责任；而外观将一群对象包装起来以简化其接口  

### 代理模式（委托模式）

代理模式为另一个对象提供一个替身或占位符以控制这个对象的访问  
使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象

**分类**

* 远程代理
	- Java的RMI调用
* 虚拟代理（必要时创建被代理对象）
	- 懒加载
* 保护代理
	- 决定对象访问
* 防火墙代理
	- 防火墙系统
* 智能引用代理
* 缓存代理
	- Web服务器代理
* 同步代理
	- JavaSpaces
* 复杂隐藏代理
* 写入时复制代理
	- CopyOnWriteArrayList
* 动态代理
	- java.util.reflect包提供Proxy类实现接口代理
	- cglib的继承代理

> 代理模式为另一个对象提供代表，以遍控制对对象的访问，管理访问的形式有许多种  
> 远程代理管理客户和远程对象之间的交互  
> 虚拟代理控制访问实例化开销大的对象  
> 保护代理基于调用者控制对对象方法的访问  
> 代理模式有许多变体，如：缓存代理、同步代理、防火墙代理和写入时复制代理  
> 代理在结构上类似装饰者，但是目的不同：装饰者模式为对象加上行为，而代理是控制访问  
> Java内置支持代理，可以根据需要建立动态代理，并将所有调用分配到所选处理器  
> 就和其他的包装着（wrapper）一样，代理会造成你的设计中类的数目增加  

```java
// 虚拟代理（此实例可以使用状态模式改写）
public class ImageProxy implements Icon {
    private ImageIcon imageIcon;
    @Override
    public void paintIcon(Component c, Graphics g, int x, int y) {
        if (imageIcon == null) {
            imageIcon.paintIcon(c, g, x, y);
        } else {
            g.drawString("loading....", x, y);
            //imageIcon=.......load image code
        }
    }
    @Override
    public int getIconWidth() {
        if (imageIcon == null) {
            return 800;
        } else {
            return imageIcon.getIconWidth();
        }
    }
    @Override
    public int getIconHeight() {
        if (imageIcon == null) {
            return 800;
        } else {
            return imageIcon.getIconHeight();
        }
    }
}
```

**动态代理**

*参见《反射和动态代理部分》*

### 装饰者模式

动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的方案  
装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案  

* 优点
	- 使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能
* 缺点
	- 正因为可以随意组合，所以就可能出现一些不合理的逻辑
	- 多层装饰的复杂性

> 继承属于扩展形式之一，单不见得是达到弹性设计的最佳方式  
> 在我们的设计中，应该允许行为被拓展，而无需修改现有的代码  
> 组合和委托可用于在运行时动态的加上行为  
> 除了继承，装饰者模式也可以让我们扩展行为  
> 装饰者模式意味着一群装饰者类，这些类用来包装具体组件  
> 装饰者类反映出被装饰者的组件类型（事实上，他们拥有相同的类型，都经过接口或继承实现）  
> 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者整个替代掉，而达到特定的目的  
> 你可以用无数个装饰者包装一个组件  
> 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型  
> 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂  

```java
public interface Phone {
	public abstract void call();
}
```

```java
public class IPhone implements Phone {
	@Override
	public void call() {
		System.out.println("手机可以打电话了");
	}
}
```

```java
// 装饰抽象类
public abstract class PhoneDecorate implements Phone {
	private Phone p;
	public PhoneDecorate(Phone p) {
		this.p = p;
	}
	@Override
	public void call() {
		this.p.call();
	}
}
```

```java
public class MusicPhoneDecorate extends PhoneDecorate {
	public MusicPhoneDecorate(Phone p) {
		super(p);
	}
	@Override
	public void call() {
		super.call();
		System.out.println("手机可以听音乐");
	}
}
```

```java
public class RingPhoneDecorate extends PhoneDecorate {
	public RingPhoneDecorate(Phone p) {
		super(p);
	}
	@Override
	public void call() {
		System.out.println("手机可以听彩铃");
		super.call();
	}
}
```

```java
Phone p = new IPhone();
p.call();
System.out.println("------------");

// 需求：我想在接电话前，听彩铃
PhoneDecorate pd = new RingPhoneDecorate(p);
pd.call();// 听彩铃打电话

// 需求：我想在接电话后，听音乐
pd = new MusicPhoneDecorate(p);
pd.call();// 打电话听音乐

// 需求：我要想手机在接前听彩铃，接后听音乐
// 自己提供装饰类，在打电话前听彩铃，打电话后听音乐或者嵌套使用装饰类
pd = new RingPhoneDecorate(new MusicPhoneDecorate(p));
pd.call();// 同时听彩铃打电话听音乐
```

```java
// Jdk中的装饰模式
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Scanner sc = new Scanner(System.in);
```

### 桥接模式（桥梁模式）

使用聚合代替继承，解决两个维度排列组合问题  
使用桥接模式，不止改变你的实现，也改变你的抽象，将抽象的部分与它的实现部分分离，使它们都可以独立的变化。

* 用途
	- 类的抽象及他的实现都可以通过生成子类的方法加以扩充
	- 当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用
	- 不希望或不适用使用继承的场景
	- 重用性要求较高的场景
* 好处：
	- 将实现予以解耦
	- 抽象和实现可以独立扩展，不会影响到对方
	- 对于“具体的抽象类”所做的改变，不会影响到客户
* 缺点：
	- 增加了复杂度

![bridge.png](/static/img/Pattern/bridge.png "bridge.png")

```java
public abstract class Abstraction {
    Bridge bridge;
    public Abstraction(Bridge bridge) {
        this.bridge = bridge;
    }
    void operation() {
        bridge.operate();
    }
}
```

```java
public interface Bridge {
    void operate();
}
```

```java
public class BridgeImpl implements Bridge {
    @Override
    public void operate() {
        System.out.println("operate");
    }
}
```

```java
public class AnotherBridgeImpl implements Bridge {
    @Override
    public void operate() {
        System.out.println("another operate");
    }
}
```

```java
public class RefineAbstraction extends Abstraction {
    public RefineAbstraction(Bridge bridge) {
        super(bridge);
    }
    public void run() {
        System.out.println("run");
    }
}

```

### 组合模式（部分-整体模式）

组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象及对象组合  
组合模式让我们能使用树形方式创建对象的结构，树里面包含了组合以及个别的对象。  
使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别  
与依赖倒置原则冲突，直接使用了实现类，限制了接口的影响范围

*组合包含组件，组件包含两种：组合和叶子节点元素*

> 组合模式提供一个机构，可同时包容个别对象和组合对象  
> 组合模式允许客户对个别对象以及组合对象一视同仁  
> 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶子节点  
> 在实现组合模式时，有许多设计上的折衷，要根据需要平衡透明性和安全性  

**透明模式和安全模式**

透明模式：叶子节点和分支节点有相同的结构，通过判断getChildren()判断（基本遵循了依赖倒置原则）
安全模式：叶子节点和分支节点不相同的结构

组合模式常和迭代器模式和访问者模式一起使用

#### 组合模式和迭代器模式组合使用

```java
// 组合接口
public interface Composite /*extends Iterable*/{
    // 添加组件
    void add(Composite composite);
    // 删除组件
    void remove(Composite composite);
    // 返回组件的遍历
    Iterator<Composite> iterator();
}
```

```java
// 日程组合
public class Schedule implements Composite {
    private String name;
    public Schedule(String name) {
        this.name = name;
    }
    // 组件
    private ArrayList<Composite> composites = new ArrayList<>();
    @Override
    public void add(Composite composite) {
        composites.add(composite);
    }
    @Override
    public void remove(Composite composite) {
        composites.remove(composite);
    }
    @Override
    public Iterator<Composite> iterator() {
        return composites.iterator();
    }
    @Override
    public String toString() {
        return "Schedule{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
// 会议组件
public class Meeting implements Composite {
    private String name;
    public Meeting(String name) {
        this.name = name;
    }
    @Override
    public void add(Composite composite) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void remove(Composite composite) {
        throw new UnsupportedOperationException();
    }
    @Override
    public Iterator<Composite> iterator() {
        return null;
    }
    @Override
    public String toString() {
        return "Meeting{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java

// 组合模式的迭代器
public class CompositeIterator implements Iterator<Composite> {
    // 用栈保存当前的未进行的迭代器
    private Stack<Iterator<Composite>> iterators = new Stack<>();
    public CompositeIterator(Iterable<Composite> composites) {
        // 将最开始的迭代器进栈
        iterators.push(composites.iterator());
    }
    @Override
    public boolean hasNext() {
        // 如果栈内没有课迭代对象，则结束
        if (iterators.size() == 0) {
            return false;
        } else {
            //查看当前迭代器是否有下一个对象
            Iterator iterator = iterators.peek();
            if (iterator.hasNext()) {// 如果有，可以调用next
                return true;
            } else {
                iterators.pop();//没有则当前迭代器出栈，递归判断下一迭代器
                return hasNext();
            }
        }
    }
    @Override
    public Composite next() {
        // hasNext时取出当前迭代器的next
        Composite next = iterators.peek().next();
        if (next.iterator() != null) {
            // 如果当前遍历对象有子，当前对象迭代器进栈，下次遍历当前对象的子
            iterators.push(next.iterator());
        }
        return next;
    }
}
```

```java
@Test
public void test() throws Exception {
    Schedule today = new Schedule("today");
    Schedule morning = new Schedule("morning");
    morning.add(new Meeting("1"));
    morning.add(new Meeting("2"));
    morning.add(new Meeting("3"));
    today.add(morning);
    Schedule afternoon = new Schedule("afternoon");
    afternoon.add(new Meeting("4"));
    afternoon.add(new Meeting("5"));
    afternoon.add(new Meeting("6"));
    today.add(afternoon);
    Schedule tomorrow = new Schedule("tomorrow");
    tomorrow.add(new Meeting("7"));
    tomorrow.add(new Meeting("8"));
    tomorrow.add(new Meeting("9"));
    Schedule noon = new Schedule("noon");
    noon.add(new Meeting("10"));
    noon.add(new Meeting("11"));
    noon.add(new Meeting("12"));
    tomorrow.add(noon);
    ArrayList<Composite> composites = new ArrayList<>();
    composites.add(today);
    composites.add(tomorrow);

    CompositeIterator compositeIterator = new CompositeIterator(composites);
    while (compositeIterator.hasNext()) {
        System.out.println(compositeIterator.next());
    }
    // Schedule{name='today'}
    // Schedule{name='morning'}
    // Meeting{name='1'}
    // Meeting{name='2'}
    // Meeting{name='3'}
    // Schedule{name='afternoon'}
    // Meeting{name='4'}
    // Meeting{name='5'}
    // Meeting{name='6'}
    // Schedule{name='tomorrow'}
    // Meeting{name='7'}
    // Meeting{name='8'}
    // Meeting{name='9'}
    // Schedule{name='noon'}
    // Meeting{name='10'}
    // Meeting{name='11'}
    // Meeting{name='12'}
}
```

#### 规格模式(Specification Pattern)

这个模式是组合模式的一个扩展

```java
public interface ISpecification<T> {
    boolean isSatisfiedBy(T candidate);
    ISpecification and(ISpecification specification);
    ISpecification or(ISpecification specification);
    ISpecification not();
}
// 父类依赖子类的场景，只有再非常明确不会变化的场景中存在，它缺乏扩展性
public abstract class CompositeSpecification<T> implements ISpecification<T> {
    @Override
    public ISpecification and(ISpecification specification) {
        return new AndSpecification(this, specification);
    }
    @Override
    public ISpecification or(ISpecification specification) {
        return new OrSpecification(this, specification);
    }
    @Override
    public ISpecification not() {
        return new NotSpecification(this);
    }
}
```

```java
public class AndSpecification<T> extends CompositeSpecification<T> {
    private ISpecification left;
    private ISpecification right;
    public AndSpecification(ISpecification left, ISpecification right) {
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean isSatisfiedBy(T candidate) {
        return left.isSatisfiedBy(candidate) && right.isSatisfiedBy(candidate);
    }
}
public class OrSpecification extends CompositeSpecification {
    private ISpecification left;
    private ISpecification right;
    public OrSpecification(ISpecification left, ISpecification right) {
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean isSatisfiedBy(Object candidate) {
        return left.isSatisfiedBy(candidate) || right.isSatisfiedBy(candidate);
    }
}
public class NotSpecification extends CompositeSpecification {
    private ISpecification specification;
    public NotSpecification(ISpecification specification) {
        this.specification = specification;
    }
    @Override
    public boolean isSatisfiedBy(Object candidate) {
        return !specification.isSatisfiedBy(candidate);
    }
}
```

```java
public class CustomSpecification extends CompositeSpecification<Integer> {
    Integer object;
    public CustomSpecification(Integer object) {
        this.object = object;
    }
    @Override
    public boolean isSatisfiedBy(Integer candidate) {
        return candidate > object;
    }
}
```

```java
// 大于15或者大于20
ISpecification<Integer> integerISpecification15 = new CustomSpecification(15);
ISpecification<Integer> integerISpecification20 = new CustomSpecification(20);
IntStream.range(0, 31)
        .filter(
                i -> integerISpecification15.or(integerISpecification20).isSatisfiedBy(i)
        )
        .forEach(System.out::println);
```


### 享元模式

如果想让某个类的一个实例能用来提供许多“虚拟实例”，就使用享元模式（有效的支持大量细粒度的对象）  
享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。  
例如IntegerCache和String字符串常量池

* 使用场景：
	- 当一个类有许多实例，而这些实例能被同一个方法控制的时候，使用享元模式
* 优点：
	- 减少运行时对象实例的个数，节省内存
	- 将许多的“虚拟”对象的状态集中管理
* 缺点：
	- 一旦你实现了它，那么单个逻辑的实例将无法拥有独立而不同的行为
* 注意事项：
	- 线程安全问题

```java
public interface Flyweight {
    // 参数state是外蕴状态
    void operate(String state);
}
```

```java
public class ConcreteFlyweight implements Flyweight {
    private Integer code = null;
    // 构造函数，内蕴状态作为参数传入
    public ConcreteFlyweight(Integer code) {
        this.code = code;
    }
    /**
     * 外蕴状态作为参数传入方法中，改变方法的行为，
     * 但是并不改变对象的内蕴状态。
     */
    @Override
    public void operate(String message) {
        System.out.println("Intrinsic State = " + this.code);
        System.out.println("Extrinsic State = " + message);
    }
}
```

```java
public class FlyweightFactory {
    private Map<Integer, Flyweight> files = new HashMap<Integer, Flyweight>();
    public Flyweight factory(Integer state) {
        //先从缓存中查找对象
        Flyweight fly = files.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            files.put(state, fly);
        }
        return fly;
    }
}
```

```java
FlyweightFactory factory = new FlyweightFactory();
Flyweight fly = factory.factory(1);
fly.operate("First Call");

fly = factory.factory(2);
fly.operate("Second Call");

fly = factory.factory(1);
fly.operate("Third Call");
// Intrinsic State = 1
// Extrinsic State = First Call
// Intrinsic State = 2
// Extrinsic State = Second Call
// Intrinsic State = 1
// Extrinsic State = Third Call
```

### 模版方法模式

模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

* 优点
	- 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，既兼顾了原则性，有不失灵活性
		+ 封装不变部分，扩展可变部分
		+ 提取公共部分代码便于维护
		+ 行为由父类控制，子类实现
* 缺点
	- 如果算法骨架有修改的话，则需要修改抽象类

> 模板方法定义了算法的步骤，把这些步骤实现延迟到子类  
> 模板方法模式为我们提供了一种代码复用的重要技巧  
> 模板方法的抽象类可以定义具体方法、抽象方法和钩子  
> 抽象方法由子类实现  
> 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它  
> 为了防止子类改变模板方法中的算法，可以将模板方法声明为final  
> 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块  
> 你将在真实世界代码中查看到模板方法模式的许多变体，不要期待他们全都是一眼可以被你认出来  
> 策略模式和模板方法模式都封装算法，一个用组合，一个用继承  
> 工厂方法是模板方法的一种特殊版本  

```java
public abstract class GetTime {
    // 需求：请给我计算出一段代码的运行时间
    // final防止子类覆盖
    public final long getTime() {
        long start = System.currentTimeMillis();
        code();
        long end = System.currentTimeMillis();
        if (isTraceMode()) {
            System.out.println("start at:" + start);
            System.out.println("end at:" + end);
        }
        return end - start;
    }
    // 必须实现，使用abstract 模版方法使用protected降低访问权限，符合迪米特法则
    protected abstract void code();
    // 可选实现，使用钩子，提供默认实现，子类选择是否覆盖父类方法
    public boolean isTraceMode() {
        return true;
    }
}
```

```java
public class ForDemo extends GetTime {
	@Override
	protected void code() {
		for (int x = 0; x < 100000; x++) {
			System.out.println(x);
		}
	}
}
```

### 观察者模式（订阅模式）

观察者模式定义了对象之间的一(Subject)对多(Observer)依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新  
JDK自带了观察者模式实现，Observable类和Observer接口，但是Observable是一个类并没有实现任何接口所以很局限  

> 观察者模式定义了对象之间的一对多关系  
> 主题（也就是观察者）用一个共同的接口来更新观察者  
> 观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现类观察者接口  
> 使用此模式时，你可以从被观察者出推（push）或拉（pull）数据，然而，推的方式被认为更正确  
> 有多个观察者时，不可以依赖特定的通知次序（取消订阅会影响顺序）  
> Java有多种观察者模式的实现，包括了通用的java.util.Observable，要注意它的一些问题(不是接口，扩展和多继承问题)，如果有必要的话，可以实现Obserable  
> Swing大量使用观察者模式，许多GUI框架也如此  
> 此模式被应用在很多地方，如JavaBeans、RMI  

* 使用场景：
	- 关联行为场景
	- 时间多级触发场景
	- 跨系统的消息交换场景，如消息队列待处理机制
* 缺点：
	- 调试复杂
	- 顺序执行的消息通知会造成效率问题，一般考虑采用异步的方式
* 注意事项：
	- 广播链最好控制在两次以内
	- 异步的线程安全和队列问题，参考消息队列

```java
// 主题
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

public class MySubject implements Subject {
    private String message;
    List<Observer> observers = new ArrayList<Observer>();
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this, this);
        }
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
}
// 观察者
public interface Observer {
    void update(Subject subject, Object args);
}

public class MyObserver implements Observer {
    public MyObserver(Subject subject) {
        subject.registerObserver(this);
    }
    public void update(Subject subject, Object args) {
        if (subject instanceof MySubject) {
            MySubject mySubject = (MySubject) args;
            System.out.println(mySubject.getMessage());
        }
    }
}
//测试
@Test
public void update() throws Exception {
    MySubject subject = new MySubject();
    MyObserver myObserver = new MyObserver(subject);
    MyObserver myObserver1 = new MyObserver(subject);
    MyObserver myObserver2 = new MyObserver(subject);
    MyObserver myObserver3 = new MyObserver(subject);
    MyObserver myObserver4 = new MyObserver(subject);
    subject.setMessage("hello");
    subject.notifyObservers();
}
```

### 状态模式

策略模式和状态模式是双胞胎  
允许对象在内部状态改变时，改变它的行为，对象看起来好像修改了它的类。

* 使用场景：
	- 行为随状态改变而改变的场景
	- 条件、分支语句的替代者
* 优点：
	- 结构清晰，避免了多重判断
	- 遵循开闭原则和单一职责原则
	- 封装性好，外部不知道因为状态改变引起行为改变
* 缺点：
	- 状态类膨胀
* 注意事项：
	- 行为受状态约束的情况下使用状态模式

> 状态模式允许一个对象基于内部状态而拥有不同的行为  
> 和程序状态机（PSM）不同，状态模式用类代表状态  
> Context会将行为委托给当前状态  
> 通过将每个状态封装进一个类，我们把以后需要做的任何更改都局部化了  
> 状态模式和策略模式有相同的类图，但是他们的意图不同  
> 策略模式通常会用行为或算法来配置Context类  
> 状态模式允许Context随着状态的改变而改变行为  
> 状态转换可以由State类或Context控制  
> 使用状态模式通常会导致类的数目大量增加  
> 状态类可以被多个Context实例共享  

```java
public interface State {
    void handle();
}
```

```java
public abstract class AbstractState implements State {
    TrafficLightContext trafficLightContext;
    private String name;
    private Double i = 1d;
    AbstractState(TrafficLightContext trafficLightContext, String name, Double i) {
        this.trafficLightContext = trafficLightContext;
        this.name = name;
        if (i != null) {
            this.i = i;
        }
    }
    @Override
    public void handle() {
        System.out.println(MessageFormat.format("{0} light", name));
        try {
            Thread.sleep(new Double(i * 1000).longValue());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class GreenState extends AbstractState {
    GreenState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "green", 1d);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getYellowState());
    }
}

public class RedState extends AbstractState {
    RedState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "red", 1d);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getGreenState());
    }
}

public class YellowState extends AbstractState {
    YellowState(TrafficLightContext trafficLightContext) {
        super(trafficLightContext, "yellow", 0.5);
    }
    @Override
    public void handle() {
        super.handle();
        trafficLightContext.setState(trafficLightContext.getRedState());
    }
}
```

```java
public class TrafficLightContext {
	// TODO:状态对象应该定义成常量
    private YellowState yellowState;
    private RedState redState;
    private GreenState greenState;
    private State state;
    TrafficLightContext() {
        this.yellowState = new YellowState(this);
        this.redState = new RedState(this);
        this.greenState = new GreenState(this);
        this.state = redState;
    }
    public void change() {
    		// 委托执行
        state.handle();
    }
    public YellowState getYellowState() {
        return yellowState;
    }
    public RedState getRedState() {
        return redState;
    }
    public GreenState getGreenState() {
        return greenState;
    }
    public void setState(State state) {
        this.state = state;
    }
}
```

```java
@Test
public void change() throws Exception {
    TrafficLightContext trafficLightContext = new TrafficLightContext();
    int i = 10;
    while (i > 0) {
        trafficLightContext.change();
        i--;
    }
}
```

### 责任链模式

当你想让一个以上的对象有你会能够处理某个请求的时候，就使用责任链模式

* 用途：
	- 经常被使用在窗口系统中，处理鼠标和键盘的事件
* 优点：
	- 将请求的发送者和接受者解耦
	- 可以简化你的对象，因为他不需要知道链的结构
	- 通过改变链内部的成员或调动它的次序，允许你动态的增加或删除责任
* 缺点：
	- 并不能保证请求一定会被执行，如果没有任何对象处理它的话，它可能落到链微端之外
	- 可能不容易观察运行时特征，有碍于除错
	- 节点过多引发的性能问题，调试也变的困难

#### 纯的与不纯的责任链模式

一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。

* 在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；
* 在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。

**纯的的责任链模式**

```java
public abstract class Handler {
    /**
     * 持有后继的责任对象
     */
    protected Handler successor;
    /**
     * 示意处理请求的方法，虽然这个示意方法是没有传入参数的
     * 但实际是可以传入参数的，根据具体需要来选择是否传递参数
     */
    public abstract void handleRequest();
    /**
     * 取值方法
     */
    public Handler getSuccessor() {
        return successor;
    }
    /**
     * 赋值方法，设置后继的责任对象
     */
    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
}
```

```java
public class ConcreteHandler extends Handler {
    /**
     * 处理方法，调用此方法处理请求
     */
    @Override
    public void handleRequest() {
        // 首先判断是否应该处理请求
        // ..
        // 然后判断是否应该放过请求

        /**
         * 判断是否有后继的责任对象
         * 如果有，就转发请求给后继的责任对象
         * 如果没有，则处理请求
         */
        if (getSuccessor() != null) {
            System.out.println("放过请求");
            getSuccessor().handleRequest();
        } else {
            System.out.println("处理请求");
        }
    }
}
```

```java
//组装责任链
Handler handler1 = new ConcreteHandler();
Handler handler2 = new ConcreteHandler();
handler1.setSuccessor(handler2);
//提交请求
handler1.handleRequest();
```

**不纯的责任链模式**

```java
public interface Filter {
    void doFilter(Request request, Response response, FilterChain filterChain);
}

public class MyFirstFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "first";
        filterChain.doFilter(request, response, filterChain);
        response.output += "first";
    }
}

public class MySecondFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        request.input += "second";
        filterChain.doFilter(request, response, filterChain);
        response.output += "second";
    }
}
//过滤器链
public class FilterChain {
    private List<Filter> filters = new ArrayList<Filter>();
    Iterator<Filter> iterator;
    public FilterChain addFilter(Filter filter) {
        filters.add(filter);
        return this;
    }
    public FilterChain addFilter(FilterChain filterChain) {
        filters.addAll(filterChain.filters);
        return this;
    }
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        if (iterator == null) {
            iterator = filters.iterator();
        }
        if (iterator.hasNext()) {
            iterator.next().doFilter(request, response, filterChain);
        }
    }
}
```

### 命令模式

将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作

**适用场景**

* 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互
* 需要在不同的时间指定请求、将请求排队
* 系统需要支持命令的撤消(undo)

> 命令模式将发出请求的对象和执行请求的对象解耦  
> 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作  
> 调用者通过调用命令对象的execute()发出请求，这会使得接受者的动作被调用  
> 调用者可以接受命令当做参数，甚至在运行时动态的进行  
> 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态  
> 宏命令是命令的一种简单延伸，允许调用多个命令，宏方法也可以支持撤销  
> 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接受者  
> 命令也可以用来实现日志和事务系统  
> 命令模式可以结合责任链模式，实现命令族的解析任务
> 命令模式可以结合模版方法模式，减少命令子类的膨胀


```java
public class Light {
    public void on() {
        System.out.println("light");
    }
    public void off() {
        System.out.println("...");
    }
}

public interface Command {
    void execute();
    //void undo();通过子类实现undo方法撤销
}

public class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) {
        this.light = light;
    }
    public void execute() {
        light.on();
    }
}
public class LightOffCommand implements Command {
    private Light light;
    public LightOffCommand(Light light) {
        this.light = light;
    }
    public void execute() {
        light.off();
    }
}

public class Invoker {
    Command command;
    //Command lastCommand;
    //void undo(){lastCommond.undo();};
    public Invoker(Command command) {
        this.command = command;
    }
    void invoke() {
        command.execute();
        //lastCommand = command;
    }
    public void setCommand(Command command) {
        this.command = command;
    }
}

public class Client {
    public static void main(String[] args) {
    	    // 实现Light、Car等Reciver和Invoker之间解耦
        Light light = new Light();
        Command command = new LightOnCommand(light);
        Invoker invoker = new Invoker(command);
        invoker.invoke();
        command = new LightOffCommand(light);
        invoker.setCommand(command);
        invoker.invoke();
        Car car = new Car();
        command = new CarDriveCommand(car);
        invoker.setCommand(command);
        invoker.invoke();
    }
}
```

#### 雇工模式(仆人模式)(Servant Design Pattern)

雇工模式是命令模式的简化

```java
public interface IServiced {
    void serviced();
}
public class BreakfastServiced implements IServiced {
    @Override
    public void serviced() {
        System.out.println("breakfast serviced");
    }
}
public class DinnerServiced implements IServiced {
    @Override
    public void serviced() {
        System.out.println("dinner serviced");
    }
}
```

```java
//雇工父类
public class Servant {
    public void services(IServiced serviced) {
        //委托给serviced对象去实现
        serviced.serviced();
    }
}
```


### 访问者模式

封装一些作用于某数种数据结构中的各元素的操作，它可以再不改变数据结构的前提下定义作用于这些元素的新的操作
当你需要为一个对象的组合增加新的能力，且封装并不重要时，使用访问者模式  
访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。

* 使用场景：
	- 一个对象结构包含很多结构不同的类对象，迭代器模式无法胜任的时候（避免instanceOf检查）
	- 需要对一个对象结构中进行很多不同且不相关的操作的时候
	- 使用访问者模式避免污染类对象，封装操作
* 优点：
	- 允许你对组合结构加入新的操作，而无需改变结构本身
	- 想要加入新的操作，相对容易
	- 访问者所进行的操作，其代码时集中在一起的，符合单一职责原则，扩展性优秀
* 缺点：
	- 会打破组合类的封装，不符合迪米特法则
	- 游走的功能牵涉其中，所以对组合结构的改变就更加困难
	- 违背了依赖倒置原则

```java
public interface Visitor {
    /**
     * 对应于NodeA的访问操作
     */
    public void visit(NodeA node);
    /**
     * 对应于NodeB的访问操作
     */
    public void visit(NodeB node);
}
```

```java
public class VisitorA implements Visitor {
    /**
     * 对应于NodeA的访问操作
     */
    @Override
    public void visit(NodeA node) {
        System.out.println(node.operationA());
    }
    /**
     * 对应于NodeB的访问操作
     */
    @Override
    public void visit(NodeB node) {
        System.out.println(node.operationB());
    }
}
```

```java
public class VisitorB implements Visitor {
    /**
     * 对应于NodeA的访问操作
     */
    @Override
    public void visit(NodeA node) {
        System.out.println(node.operationA());
    }
    /**
     * 对应于NodeB的访问操作
     */
    @Override
    public void visit(NodeB node) {
        System.out.println(node.operationB());
    }
}
```

```java
public abstract class Node {
    /**
     * 接受操作
     */
    public abstract void accept(Visitor visitor);
}
```

```java
public class NodeA extends Node{
    /**
     * 接受操作
     */
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    /**
     * NodeA特有的方法
     */
    public String operationA(){
        return "NodeA";
    }
}
```

```java
public class NodeB extends Node{
    /**
     * 接受方法
     */
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    /**
     * NodeB特有的方法
     */
    public String operationB(){
        return "NodeB";
    }
}
```

```java
// 结构对象角色类，这个结构对象角色持有一个聚集，并向外界提供add()方法作为对聚集的管理操作。
// 通过调用这个方法，可以动态地增加一个新的节点。
// 虽然在这个示意性的实现里并没有出现一个复杂的具有多个树枝节点的对象树结构，
// 但是，在实际系统中访问者模式通常是用来处理复杂的对象树结构的，而且访问者模式可以用来处理跨越多个等级结构的树结构问题。
public class ObjectStructure {
    private List<Node> nodes = new ArrayList<Node>();
    /**
     * 执行方法操作
     */
    public void action(Visitor visitor){
        for(Node node : nodes) {
            node.accept(visitor);
        }
    }
    /**
     * 添加一个新元素
     */
    public void add(Node node){
        nodes.add(node);
    }
}
```

```java
ObjectStructure os = new ObjectStructure();
//给结构增加一个节点
os.add(new NodeA());
//给结构增加一个节点
os.add(new NodeB());
//创建一个访问者
Visitor visitor = new VisitorA();
os.action(visitor);
```

### 策略模式

定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户  
具体比较方法交给不同的装配策略实现，AOP中的advice也是策略模式  

* 适用场景：
	- 多个类只有算法或者行为上略有不同的场景
	- 算法需要自由切换的场景
	- 需要屏蔽算法规则的场景
* 优点：
	- 算法可以自由切换
	- 避免多重条件判断
	- 扩展性良好
* 缺点：
	- 策略类数量膨胀
	- 所有策略类都要对外暴漏，违背了迪米特法则
		+ 使用工厂方法模式、代理模式、享元模式弥补
* 注意事项：
	- 如果一个算法家族的具体策略超过四个，考虑使用复合模式防止策略类膨胀

Comparable和Comparator

```java
public class MyNumber implements Comparable<MyNumber> {
    int value;
    private Comparator<MyNumber> myNumberComparator;
    public MyNumber(Comparator<MyNumber> myNumberComparator) {
        this.myNumberComparator = myNumberComparator;
    }
    @Override
    public int compareTo(MyNumber o) {
        return myNumberComparator.compare(this, o);
    }
    public int getValue() {
        return value;
    }
    public void setValue(int value) {
        this.value = value;
    }
}
```

```java
public class MyComparator implements Comparator<MyNumber> {
    @Override
    public int compare(MyNumber o1, MyNumber o2) {
        return o1.value - o2.value;
    }
}
```

### 备忘录模式

当你让对象返回之前的状态时，使用备忘录模式  
在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态

* 目标：
	- 储存系统关键对象的重要状态
	- 维护关键对象的封装
* 优点：
	- 将被储存的状态放在外面，不要和关键对象混在一起
	- 保持关键对象的数据封装
	- 提供了容易实现的恢复能力
* 缺点：
	- 储存和恢复状态的过程可能相当耗时
	- 考虑使用序列化机制替代
* 注意事项：
	- 备忘录就近使用，建立即使用，不使用即废弃，等待垃圾回收
	- 大对象建立备忘录耗费资源
	- 不要在建立备份频繁的场景使用，无法控制备忘录建立的对象数量

* “白箱”备忘录模式
	- 备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。(Memento作为公开的外部类)
* “黑箱”备忘录模式
	- 备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口(Memento作为内部类，向外提供MementoIF接口的实现类，而不暴漏Memento具体类)

**多重检查点(白箱)**

```java
// 发起人角色
public class Originator {
    private List<String> states;
    // 检查点指数
    private int index;
    // 构造函数
    public Originator(){
        states = new ArrayList<String>();
        index = 0;
    }
    // 工厂方法，返还一个新的备忘录对象
    public Memento createMemento(){
        return new Memento(states , index);
    }
    // 将发起人恢复到备忘录对象记录的状态上
    public void restoreMemento(Memento memento){
        states = memento.getStates();
        index = memento.getIndex();
    }
    // 状态的赋值方法
    public void setState(String state){
        states.add(state);
        index++;
    }
    // 辅助方法，打印所有状态
    public void printStates(){
        for(String state : states){
            System.out.println(state);
        }
    }
}
```

```java
public class Memento {
    private List<String> states;
    private int index;
    public Memento(List<String> states , int index){
        this.states = new ArrayList<String>(states);
        this.index = index;
    }
    public List<String> getStates() {
        return states;
    }
    public int getIndex() {
        return index;
    }
}
```

```java
public class Caretaker {
    private Originator o;
    private List<Memento> mementos = new ArrayList<Memento>();
    private int current;
    public Caretaker(Originator o){
        this.o = o;
        current = 0;
    }
    // 创建一个新的检查点
    public int createMemento(){
        Memento memento = o.createMemento();
        mementos.add(memento);
        return current++;
    }
    // 将发起人恢复到某个检查点
    public void restoreMemento(int index){
        Memento memento = mementos.get(index);
        o.restoreMemento(memento);
    }
    // 将某个检查点删除
    public void removeMemento(int index){
        mementos.remove(index);
    }
}
```

```java
Originator o = new Originator();
Caretaker c = new Caretaker(o);
//改变状态
o.setState("state 0");
//建立一个检查点
c.createMemento();
//改变状态
o.setState("state 1");
//建立一个检查点
c.createMemento();
//改变状态
o.setState("state 2");
//建立一个检查点
c.createMemento();
//改变状态
o.setState("state 3");
//建立一个检查点
c.createMemento();
//打印出所有检查点
o.printStates();
System.out.println("-----------------恢复检查点-----------------");
//恢复到第二个检查点
c.restoreMemento(2);
//打印出所有检查点
o.printStates();
```


### 迭代器模式

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴漏其内部的表示  
把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所  

> 迭代器允许访问聚合的元素，而不需要暴漏它的内在结构  
> 迭代器将遍历聚合的工作封装近一个对象中  
> 当使用迭代器的时候，我们依赖聚合提供遍历  
> 迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制  
> 我们应该努力让一个类只分配一个责任  

```java
// Jdk的Iterator接口
public interface Iterator<E> {
    boolean hasNext();
    E next();
    // defalut方法不用实现
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}

```

```java
public class MyIntegerIterator implements Iterator<Integer> {
    private Integer integer;
    public MyIntegerIterator(Integer integer) {
        this.integer = integer;
    }
    public boolean hasNext() {
        return integer < Integer.MAX_VALUE;
    }
    public Integer next() {
	    //自动拆箱 return this.integer = this.integer.intValue() + 1;
        return ++integer;
    }
}
```

### 解释器模式

给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子

* 使用场景：
	- 重复发生的问题可以使用解释器模式（终结符表达式相同，非终结符表达式定制）
	- 简单语法解析，复杂使用其他替代库
* 优点：
	- 将每一个Context规则表示成一个类，方便与实现语言
	- 因为Context由许多类表示，所以你可以轻易的扩展此Context（扩展表达式）
	- 通过在类结构中加入新的方法，可以在解释的同时增加新的行为
* 缺点：
	- 当Context规则数目太大时，这个模式可能会变的非常繁杂
	- 表达式类膨胀
	- 递归导致调试困难
	- 递归和循环导致效率低下
* 注意事项：
	- 不要在重要模块中使用解释器模式，使用shell、JRuby、Groovy等脚本替代解释器模式
	- 考虑使用Expression4J、MESP（Math Expression String Parser）、Jep等开源的解析包替代

```java
public interface Expression<T> {
    T interpret(Context context);
}
public class VarExpression implements Expression<Integer> {
    private String key;
    public VarExpression(String key) {
        this.key = key;
    }
    public Integer interpret(Context context) {
        return (Integer) context.getExpression(this.key).interpret(context);
    }
}
public abstract class SymbolExpression<T> implements Expression<T> {
    protected Expression<T> left;
    protected Expression<T> right;
    //所有的解析公式都应只关心自己左右两个表达式的结果
    public SymbolExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
}
public class AddExpression implements Expression<Integer> {
    private Expression<Integer> left;
    private Expression<Integer> right;
    public AddExpression(Expression<Integer> left, Expression<Integer> right) {
        this.left = left;
        this.right = right;
    }
    @Override
    public Integer interpret(Context context) {
        return left.interpret(context) + right.interpret(context);
    }
}
public class SubExpression extends SymbolExpression {
    private Expression<Integer> left;
    private Expression<Integer> right;
    public SubExpression(Expression left, Expression right) {
        super(left, right);
        this.left = left;
        this.right = right;
    }
    @Override
    public Integer interpret(Context context) {
        return left.interpret(context) - right.interpret(context);
    }
}
```

```java
public class Context {
    private Map<String, Expression> stringExpressionMap = new HashMap<>();
    public Context() {
        stringExpressionMap.put("1", context -> (1));
        stringExpressionMap.put("2", context -> (2));
        stringExpressionMap.put("3", context -> (3));
        stringExpressionMap.put("4", context -> (4));
        stringExpressionMap.put("5", context -> (5));
        stringExpressionMap.put("6", context -> (6));
        stringExpressionMap.put("7", context -> (7));
        stringExpressionMap.put("8", context -> (8));
        stringExpressionMap.put("9", context -> (9));
        stringExpressionMap.put("0", context -> (0));
    }
    public Expression getExpression(String str) {
        return stringExpressionMap.get(str);
    }
    public void addExpression(String str, Expression expression) {
        this.stringExpressionMap.put(str, expression);
    }
}
```

```java
public class Calculator<T> {
    //定义表达式
    private Expression expression;
    //构造函数传参，并解析
    public Calculator(String expStr) {
        //定义一个栈，安排运算的先后顺序
        Stack<Expression> stack = new Stack<Expression>();
        //表达式拆分为字符数组
        char[] charArray = expStr.toCharArray();
        //运算
        Expression left = null;
        Expression right = null;
        for (int i = 0; i < charArray.length; i++) {
            switch (charArray[i]) {
                case '+': //加法
                    //加法结果放到栈中
                    left = stack.pop();
                    right = new VarExpression(String.valueOf(charArray[++i]));
                    stack.push(new AddExpression(left, right));
                    break;
                case '-':
                    left = stack.pop();
                    right = new VarExpression(String.valueOf(charArray[++i]));
                    stack.push(new SubExpression(left, right));
                    break;
                default:  //公式中的变量
                    stack.push(new VarExpression(String.valueOf(charArray[i])));
            }
        }
        //把运算结果抛出来
        this.expression = stack.pop();
    }
    //开始运算
    public T run(Context context) {
        return (T) this.expression.interpret(context);
    }
}
```

```java
System.out.println(new Calculator<Integer>("1-2+3-4-6+5+7-8+9+0").run(new Context()));
```

### 中介者模式（调停者模式）

中介者模式集中相关对象之间复杂的沟通和控制方式

* 用途：
	- 常被用于协调相关的GUI组件
* 优点：
	- 通过将对象彼此解耦（一对多依赖转换为一对一依赖），可以增加对象的复用性
	- 通过将控制逻辑集中，可以简化系统维护
	- 可以让对象之间所传递的消息变得简单且大幅减少
* 缺点：
	- 设计不当，增加复杂度，同事类越多，中介者越复杂
	- 往往与依赖倒置原则冲突，具有继承带来的侵入性
* 最佳实践：
	- N个对象之间产生了相互依赖（N>2）
	- 多个对象之间有依赖，但依赖关系尚不确定或有发生改变的可能，使用中介者模式降低风险扩散

```java
// 抽象中介者，做同事类注入（同事类拥有相同方法使用抽象类，没有使用实现类）
public abstract class Mediator {
    //定义同事类(多个)
    protected ConcreteColleague concreteColleague;
    //通过getter/setter方法把同事类注入进来
    public ConcreteColleague getConcreteColleague() {
        return concreteColleague;
    }
    public void setConcreteColleague(ConcreteColleague concreteColleague) {
        this.concreteColleague = concreteColleague;
    }
    //中介者模式的业务逻辑
    public abstract void doSomething();
}
public class ConcreteMediator extends Mediator {
	//多个特定方法调用特定同事功能
    @Override
    public void doSomething() {
        //调用同事类的方法，只要是public方法都可以调用
        super.concreteColleague.selfMethod();
    }
}
```

```java
// 抽象同事类，注入中介者
public abstract class Colleague {
    protected Mediator mediator;
    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
}

public class ConcreteColleague extends Colleague {
    private String self;
    //通过构造函数传递中介者
    public ConcreteColleague(Mediator mediator, String self) {
        super(mediator);
        this.self = self;
    }
    //自有方法 self-method
    public void selfMethod() {
        //处理自己的业务逻辑
        System.out.println("invoked self" + self);
    }
    //依赖方法 dep-method
    public void depMethod() {
        //处理自己的业务逻辑
        //自己不能处理的业务逻辑，委托给中介者处理
        super.mediator.doSomething();
    }
}
```

```java
// 中介者使用setter方法注入同事类，同事类使用构造函数注入中介者
Mediator mediator = new ConcreteMediator();
ConcreteColleague concreteColleague = new ConcreteColleague(mediator, "1");
ConcreteColleague concreteColleague1 = new ConcreteColleague(mediator, "2");
mediator.setConcreteColleague(concreteColleague);
concreteColleague1.selfMethod();
concreteColleague1.depMethod();
// invoked self2
// invoked self1
```

## 复合模式（Compound Patter）

模式通常被遗弃使用，并被组合在同一个设计解决方案中  
复合模式在同一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题，如MVC模式  

> MVC是复合模式，结合了观察者模式（Model是被观察者）、策略模式（Controller是策略）和组合模式（View内的控件管理）？？？  
> 模型使用观察者模式，以便观察者更新，同时保持两者之间解耦  
> 控制器是视图的策略，视图可以使用不同的控制器实现  
> 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，如面板、框架和按钮  
> 这些模式携手合作，把MVC模式的三层解耦，这样保持设计的干净又有弹性  
> 适配器模式用来将新的模型适配成已有的视图和控制器  

## 常见设计缺陷及解决

* 显示指定一个类创建对象
	- 工厂模式、原型模式
* 对特殊操作的依赖
	- 责任链模式、命令模式
* 对硬件或软件平台的依赖
	- 抽象工厂模式、桥接模式
* 对对象表示或实现的依赖
	- 抽象工厂模式、桥接模式、记事本模式、代理模式
* 算法依赖
	- 创建者模式、迭代器模式、策略模式、模范方法模式、访问者模式
* 紧耦合
	- 抽象工厂模式、命令模式、外观模式、中介者模式、观察者模式、责任链模式
* 通过生成子类扩展功能
	- 桥接模式、责任链模式、组合模式、装饰模式、观察者模式、策略模式
* 不能方便的对类进行修改
	- 适配器模式、装饰模式、访问者模式

----------

*以上概念总结于传智播客Java基础课程*