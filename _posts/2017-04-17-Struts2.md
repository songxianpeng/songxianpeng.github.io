---  
lajout: post  
title: Struts2  
tags: Struts2  
categories: JavaEE  
published: true  
---  

## Struts2

Struts2是在Struts1和webwork基础之上发展的`全新`的框架

### 配置

**web.xml**

```xml
<!-- Struts2 filter -->
<filter>
    <filter-name>struts2</filter-name>
    <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
    <init-param>
        <param-name>struts.i18n.encoding</param-name> 
        <param-value>utf-8</param-value>
    </init-param>
</filter>
```

**struts.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">
<struts>
    <constant name="struts.devMode" value="true"/>
    <package name="basicStruts2" extends="struts-default">
        <action name="index">
            <result>/index.html</result>
        </action>
        <action name="hello" class="com.xpress.hello.action.HelloWorldAction" method="execute">
            <result name="success">/index.jsp</result>
        </action>
    </package>
</struts>
```

**action**

```java
public class HelloWorldAction extends ActionSupport {
    private static final long serialVersionUID = 1L;
    public String execute() throws Exception {
        return SUCCESS;
    }
}
```

#### struts.xml配置文件

##### include

```xml
<include file="struts-login.xml"/>
```

##### constant

常量配置，可配置default.properties内容，另可在web.xml中的filter init参数中配置，也可在struts.properties中配置

**常用常量**

```xml
<constant name="struts.devMode" value="true"/>
<constant name="struts.i18n.encoding" value="UTF-8"/>
<constant name="struts.action.extension" value="do,action,,"/>
```

##### package

包

* name 包名
* extends 继承关系
    - 默认`struts-default`
* namespace package访问路径

##### package>action

动作

* name action访问路径
* class action执行的class全路径
* method action执行的方法名称

###### method配置

方法访问配置

* action标签的method属性
* 使用通配符
* 动态访问

```xml
<!-- method属性方式 -->
<action name="addHelloAction" class="com.xpress.action.HelloAction" method="add">
</action>
<action name="deleteHelloAction" class="com.xpress.action.HelloAction" method="delete">
</action>
<!-- 通配符方式 -->
<action name="*HelloAction" class="com.xpress.action.HelloAction" method="{1}">
</action>
<!-- 通配符方式 -->
<constant name="struts.enable.DynamicMethodInvocation" value="true"/>
<action name="helloAction" class="com.xpress.action.HelloAction">
</action>
<!-- http://localhost:8080/helloAction!add.action -->
<!-- http://localhost:8080/helloAction!delete.action -->
```

##### package>action>result

返回结果

* name 同方法返回值
* type 结果处理方式（转发或重定向，默认转发）

###### result配置

* 全局结果页面
    - action返回的结果和页面都是相同的可以使用
* 局部结果页面

```xml
<!-- 全局结果页面配置 -->
 <package name="default" extends="struts-default" namespace="/">
    <!-- 作用范围为package -->
    <global-results>
        <result name="success">index.jsp</result>
    </global-results>

    <action name="addHelloAction" class="com.xpress.action.HelloAction" method="add">
        <!-- 使用全局结果页面 -->
        <!-- <result name="success">index.jsp</result> -->
    </action>
    <action name="deleteHelloAction" class="com.xpress.action.HelloAction" method="delete">
        <!-- 使用局部结果页面，全局结果页面则不生效 -->
        <result name="success">index.jsp</result>
    </action>
</package>
```

**type属性值**

* 到页面
    - dispatcher 转发（默认值）
    - redirect 重定向
* 到action
    - chain 转发到actin（一般不用，缓存问题）
    - redirectAction 重定向到action

### action

#### 三种实现方式

* 普通类
* 实现Action接口
* 继承自ActionSupport

**method无返回值**

* 使用void返回值类型
* return NONE;

#### 获取表单数据

##### 获取表单数据

* 使用ActionContext类（推荐，完全解耦合）
* 使用ServletActionContext类（常见）
* 使用接口注入

```java
public class HelloAction extends ActionSupport implements ServletRequestAware {
    private HttpServletRequest httpServletRequest;

    @Override
    public void setServletRequest(HttpServletRequest request) {
        httpServletRequest = request;
    }

    public String getParameter() {
        Map parameters;
        // 使用ActionContext
        ActionContext actionContext = ActionContext.getContext();
        parameters = actionContext.getParameters();
        // 使用ServletActionContext
        HttpServletRequest request = ServletActionContext.getRequest();
        parameters = request.getParameterMap();
        // 实现ServletRequestAware接口注入request
        parameters = httpServletRequest.getParameterMap();
        // 原始数据封装
        // 属性封装
        // 模型驱动封装
        return NONE;
    }
}
```

##### 封装数据到实体

* 原始数据封装
    - 获取request后获得parameter
    - 设置到实体中
* 属性封装
    - 使用action成员变量
    - 表单项和成员变量名一致并生成get、set方法
    - 获取属性值并设置到实体中
* 模型驱动封装
    - 实现ModelDriven<T>接口
    - 创建需要转换的实体对象，**并new一个实例**
    - 实现T getModel()方法返回需要转换的实体
* 表达式封装
    - 属性封装的属性为实体对象并生成get、set方法（会使用get方法查找对象）
    - 表单中使用表达式名称（name="bean.property"）
    - 如果实体时Map或者List也可以封装（name="list[0].property"，name="map['key'].property"）

*ps；不能同时使用属性封装和模型驱动封装获取同一表单数据，同时使用只执行模型驱动封装*


###### 模型驱动封装和表达式封装比较

* 都可以封装表单数据到实体
* 使用模型驱动只能把数据封装到一个实体，表达式封装可以封装到多个实体中

#### 操作域对象

```java
// ActionContext中也提供了域对象操作的方法，但是存在同步问题
HttpServletRequest httpServletRequest = ServletActionContext.getRequest();
HttpSession httpSession = httpServletRequest.getSession();
ServletContext servletContext = ServletActionContext.getServletContext();
```

### Servlet和Action的区别

Servlet：默认第一次访问的时候创建，创建一次
Action：访问时候创建，每次访问时候都会创建一个对象，创建多次

### 值栈

每个Action对象都会有一个值栈对象

#### 获取值栈对象方法

```java
ValueStack valueStack = ActionContext.getContext().getValueStack();
```

#### 值栈结构

值栈分为两部分：root和context

* root:Value Stack Contents，对象是CompoundRoot，结构是list结合（一般操作root中数据）
* context:Stack Context，对象是OgnlContext，结构是map集合

*使用标签查看值栈结构和存储值*

```jsp
<s:debug/>
```

##### root

向值栈中放数据

* ActionContext.getContext().getValueStack().push(new Object()); 存入值栈的map中
* ActionContext.getContext().getValueStack().set("key",new Object()); 存入值栈中
* 在action中创建成员变量并提供get方法并给对象赋值 存入值栈的action引用的对象中（常用）

##### context

context常用存储对象

|     key     |              value               |
|-------------|----------------------------------|
| request     | request对象引用                  |
| session     | HttpSession对象引用              |
| application | ServletContext对象引用           |
| parameters  | 传递的相关参数                   |
| attr        | 获取域对象中域范围最小的域中的值 |

### OGNL和Struts标签

OGNL是一个独立的项目，Struts2的默认表达式语言，主要用域操作Struts值栈数据

* 支持对象方法调用
* 支持类静态方法调用和值访问
* 支持赋值操作和表达式串联
* 访问OGNL context和ActionContext
* 操作集合对象

#### OGNL中"#"和"%"的使用

##### “#”使用

使用#获取context中数据

> #context的key名称.域对象的key

```jsp
<s:property value="#request.key"/>
<s:property value="#session.key"/>
<s:property value="#application.key"/>
<!-- 参见下面list获取值例子 -->
```

##### “%”使用

在Struts表单标签中使用ognl表达式不被识别，需要%{}后才会识别

```jsp
<s:textfield name="username" value="%{#request.key}"/>
```

#### 获取值栈中的数据

```java
private String str;
private User user;
private List<User> userList;
public String getStr() {
    return str;
}
public User getUser() {
    return user;
}
public List<User> getUserList() {
    return userList;
}
```

```jsp
<%@taglib prefix="s" uri="/struts-tags" %>
<!-- 获取字符串对象 -->
<s:property value="str"/>
<!-- 获取对象值 -->
<s:property value="user.username"/>
<!-- 获取list值 -->
<s:property value="userList[0].username"/>
<!-- 不指定var直接遍历 -->
<s:iterator value="userList">
    <s:property value="username"/>
    <s:property value="password"/>
    <s:property value="nickname"/>
</s:iterator>
<!-- ognl把每次遍历的对象user放到context对象里面，获取context内对象要加#号，否则从root中取值 -->
<s:iterator value="userList" var="user">
    <s:property value="#user.username"/>
    <s:property value="#user.password"/>
    <s:property value="#user.nickname"/>
</s:iterator>
```

```java
ActionContext.getContext().getValueStack().set("key","value");
ActionContext.getContext().getValueStack().push("value");
```

```jsp
<%@taglib prefix="s" uri="/struts-tags" %>
<!-- 获取set对象 -->
<s:property value="key"/>
<!-- push方法设置值，没有名称 -->
<!-- 想值栈中放数据，会把向值栈存放的数据放到数组里面，数组的名称top -->
<!-- ognl根据数据获取值下标放前面 -->
<s:property value="[0].top"/>
```

#### EL表达式为什么可以获取值栈数据

* EL表达式使用getAttribute()方法获取域对象中的值
* struts底层增强了request对象里的getAttribute()方法
    - 首先获取request域中的值，如果获取到直接返回
    - 如果从request域中没有获取到值，则去值栈中获取并将值放到域对象里

*ps：鉴于上面过程，使用el表达式遍历值栈对象效率很低，推荐使用struts标签配合ognl表达式操作数据*

### 源码分析

* org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter
    - init()方法加载配置文件包含自己创建的配置和struts自带的配置
        + init_DefaultProperties(); org/apache/struts2/default.properties
        + init_TraditionalXmlConfigurations(); DEFAULT_CONFIGURATION_PATHS:struts-default.xml,struts-plugin.xml,struts.xml
        + init_LegacyStrutsProperties(); stuts.properties, struts.custom.properties
        + init_CustomConfigurationProviders(); 用户自定义的配置加载器
        + init_FilterInitParameters(); filter的init参数配置
        + init_AliasStandardObjects(); 初始化标准类
    - doFilter()
        + prepare.wrapRequest() 增强request的getAttribute()方法，获取值栈对象并放入域对象

------

*以上概念总结于传智播客JavaWeb课程*