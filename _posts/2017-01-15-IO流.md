---
layout: post
title: Java IO/NIO、Netty
tags: IO File netty NIO 
categories: Java
published: true
---

## File

文件和目录(文件夹)路径名的抽象表示形式

> 仅仅是一个路径的表示，不代码具体的事物一定是存在的。

### list()方法

通过参数FilenameFilter限定符合要求的文件或目录

```java
// 封装e判断目录
File file = new File("d:\\");

// 获取该目录下所有文件或者文件夹的String数组
// public String[] list(FilenameFilter filter)
String[] strArray = file.list(new FilenameFilter() {
	@Override
	public boolean accept(File dir, String name) {
		return new File(dir, name).isFile() && name.endsWith(".jpg");
	}
});

// 遍历
for (String s : strArray) {
	System.out.println(s);
}
```

### 递归遍历文件夹

```java
private static void getAllJavaFilePaths(File srcFolder) {
	// 获取该目录下所有的文件或者文件夹的File数组
	File[] fileArray = srcFolder.listFiles();

	// 遍历该File数组，得到每一个File对象
	for (File file : fileArray) {
		// 判断该File对象是否是文件夹
		if (file.isDirectory()) {
			getAllJavaFilePaths(file);
		} else {
			// 继续判断是否以.java结尾
			if (file.getName().endsWith(".java")) {
				// 就输出该文件的绝对路径
				System.out.println(file.getAbsolutePath());
			}
		}
	}
}
```

## IO流

### 分类

* 按照数据流向
	- 输入流
	- 输出流
* 按照数据类型（默认）
	- 字节流
		+ 字节输入流
		+ 字节输出流
	- 字符流
		+ 字符输入流
		+ 字符输出流

### 基类

* 字节流的抽象基类及子类：
	- InputStream
		+ FileInputStream
		+ BufferedInputStream
	- OutputStream
		+ FileOutputStream
		+ BufferedOutputStream
* 字符流的抽象基类及子类：
	- Reader
		+ FileReader
		+ BufferedReader
	- Writer
		+ FileWriter
		+ BufferedWriter

![IO流小结图解](/static/img/IO流/IO流小结图解.jpg "IO流小结图解")

### 字节流

#### FileOutputStream和FileInputStream

```java
// 基本字节流一次读写一个字节数组
public static void method2(String srcString, String destString)
		throws IOException {
	FileInputStream fis = new FileInputStream(srcString);
	FileOutputStream fos = new FileOutputStream(destString);

	byte[] bys = new byte[1024];
	int len = 0;
	while ((len = fis.read(bys)) != -1) {
		fos.write(bys, 0, len);
	}

	fos.close();
	fis.close();
}

// 基本字节流一次读写一个字节
public static void method1(String srcString, String destString)
		throws IOException {
	FileInputStream fis = new FileInputStream(srcString);
	FileOutputStream fos = new FileOutputStream(destString);

	int by = 0;
	while ((by = fis.read()) != -1) {
		fos.write(by);
	}

	fos.close();
	fis.close();
}
```

#### 换行符

* windows:`\r\n`
* linux:`\n`
* Mac:`\r`

#### 追加文件

```java
// 创建一个向具有指定 name 的文件中写入数据的输出文件流。
// 如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。
FileOutputStream fos = new FileOutputStream("fos3.txt", true);
```

#### 创建字节输出流对象做了几件事情

1. 调用系统功能去创建文件
2. 创建fos对象
3. 把fos对象指向这个文件

### 字节缓冲区流

#### BufferedOutputStream和BufferedInputStream

```java
// 高效字节流一次读写一个字节数组：
public static void method4(String srcString, String destString)
		throws IOException {
	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(
			srcString));
	//为什么不传递一个具体的文件或者文件路径，而是传递一个OutputStream对象?
	//因为字节缓冲区流仅仅提供缓冲区，为高效而设计的。真正的读写操作还是基本的流对象实现。

	//构造方法可以指定缓冲区的大小，但是我们一般不用，默认缓冲区大小就够了
	BufferedOutputStream bos = new BufferedOutputStream(
			new FileOutputStream(destString));

	byte[] bys = new byte[1024];
	int len = 0;
	while ((len = bis.read(bys)) != -1) {
		bos.write(bys, 0, len);
	}

	bos.close();
	bis.close();
}

// 高效字节流一次读写一个字节：
public static void method3(String srcString, String destString)
		throws IOException {
	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(
			srcString));
	BufferedOutputStream bos = new BufferedOutputStream(
			new FileOutputStream(destString));

	int by = 0;
	while ((by = bis.read()) != -1) {
		bos.write(by);

	}

	bos.close();
	bis.close();
}
```

### 字符流

**计算机是如何识别什么时候该把两个字节转换为一个中文呢?**

> 在计算机中中文的存储分两个字节：  
>> 第一个字节肯定是负数。  
>> 第二个字节常见的是负数，可能有正数。但是没影响。  

```java
// String s = "abcde";
// // [97, 98, 99, 100, 101]

String s = "我爱你中国";
// [-50, -46, -80, -82, -60, -29, -42, -48, -71, -6]

byte[] bys = s.getBytes();
System.out.println(Arrays.toString(bys));
```

由于字节流操作中文不是特别方便，所以，java就提供了转换流。  
转换流其实是一个字符流
> 字符流=字节流+编码表。

#### 编码表

> 计算机只能识别二进制数据，早期由来是电信号。  
> 为了方便应用计算机，让它可以识别各个国家的文字。  
> 就将各个国家的文字用数字来表示，并一一对应，形成一张表。  
> 
> ASCII：美国标准信息交换码。用一个字节的7位可以表示。  
> ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。  
> GB2312：中国的中文编码表。  
> GBK：中国的中文编码表升级，融合了更多的中文文字符号。  
> GB18030：GBK的取代版本  
> BIG-5码 ：通行于台湾、香港地区的一个繁体字编码方案，俗称“大五码”。  
> Unicode：国际标准码，融合了多种文字。所有文字都用两个字节来表示,Java语言使用的就是unicode  
> UTF-8：最多用三个字节来表示一个字符。  
> 
> UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容：  
> 它将Unicode编码为00000000-0000007F的字符，用单个字节来表示  
> 它将Unicode编码为00000080-000007FF的字符用两个字节表示  
> 它将Unicode编码为00000800-0000FFFF的字符用3字节表示 

#### OutputStreamWriter和InputStreamReader

```java
InputStreamReader isr = new InputStreamReader(new FileInputStream(
		"a.txt"));
// 封装目的地
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(
		"b.txt"));

// 读写数据
// 方式1
// int ch = 0;
// while ((ch = isr.read()) != -1) {
// osw.write(ch);
// }

// 方式2
char[] chs = new char[1024];
int len = 0;
while ((len = isr.read(chs)) != -1) {
	osw.write(chs, 0, len);
	// osw.flush();
}

// 释放资源
osw.close();
isr.close();
```

#### FileWriter和FileReader

使用默认本地编码表的InputStreamReader和OutputStreamReader封装类

```java
// 基本字符流一次读写一个字符数组
private static void method2(String srcString, String destString)
		throws IOException {
	FileReader fr = new FileReader(srcString);
	FileWriter fw = new FileWriter(destString);

	char[] chs = new char[1024];
	int len = 0;
	while ((len = fr.read(chs)) != -1) {
		fw.write(chs, 0, len);
	}

	fw.close();
	fr.close();
}

// 基本字符流一次读写一个字符
private static void method1(String srcString, String destString)
		throws IOException {
	FileReader fr = new FileReader(srcString);
	FileWriter fw = new FileWriter(destString);

	int ch = 0;
	while ((ch = fr.read()) != -1) {
		fw.write(ch);
	}

	fw.close();
	fr.close();
}
```

#### BufferedReader和BufferedWriter

```java
// 字符缓冲流一次读写一个字符串
private static void method5(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	String line = null;
	while ((line = br.readLine()) != null) {
		bw.write(line);
		bw.newLine();
		bw.flush();
	}

	bw.close();
	br.close();
}

// 字符缓冲流一次读写一个字符数组
private static void method4(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	char[] chs = new char[1024];
	int len = 0;
	while ((len = br.read(chs)) != -1) {
		bw.write(chs, 0, len);
	}

	bw.close();
	br.close();
}
// 字符缓冲流一次读写一个字符
private static void method3(String srcString, String destString,String encoding)
		throws IOException {
	BufferedReader br = new BufferedReader(
							new InputStreamReader(new FileInputStream(srcString),encoding));
	BufferedWriter bw = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(destString),encoding));

	int ch = 0;
	while ((ch = br.read()) != -1) {
		bw.write(ch);
	}

	bw.close();
	br.close();
}
```

### 缓冲流与普通流区别

> 在FileInputStream里有一个说明是说此方法将阻塞，意思就是说在你读一个文件输入流的时候，当读到某个位置的时候，如果做一些其他处理（比如说接受一部分字节做一些处理等等）这个时候输入流在什么位置就是什么位置，不会继续往下读，而BufferedInputStream虽然也有一个read方法，但是从名字就可以看出，它带有一个缓冲区，它是一个非阻塞的方法，在你读到某个位置的时候，做一些处理的时候，输入流可能还会继续读入字节，这样就达到了缓冲的效果。

缓冲流默认的缓冲大小是8192，可以使用构造方法制定缓冲区大小，一般不用。  
缓冲区是缓冲流内部的数组，与传入的数组参数无关，最终使用arraycopy返回

### 数据操作流

可以操作基本类型的数据

* DataInputStream
* DataOutputStream

```java
private static void write() throws IOException {
	// DataOutputStream(OutputStream out)
	// 创建数据输出流对象
	DataOutputStream dos = new DataOutputStream(new FileOutputStream(
			"dos.txt"));

	// 写数据了
	dos.writeByte(10);
	dos.writeShort(100);
	dos.writeInt(1000);
	dos.writeLong(10000);
	dos.writeFloat(12.34F);
	dos.writeDouble(12.56);
	dos.writeChar('a');
	dos.writeBoolean(true);

	// 释放资源
	dos.close();

	// dos.txt
	// 0a00 6400 0003 e800 0000 0000 0027 1041
	// 4570 a440 291e b851 eb85 1f00 6101 
}

private static void read() throws IOException {
	// DataInputStream(InputStream in)
	// 创建数据输入流对象
	DataInputStream dis = new DataInputStream(
			new FileInputStream("dos.txt"));

	// 读数据
	byte b = dis.readByte();
	short s = dis.readShort();
	int i = dis.readInt();
	long l = dis.readLong();
	float f = dis.readFloat();
	double d = dis.readDouble();
	char c = dis.readChar();
	boolean bb = dis.readBoolean();

	// 释放资源
	dis.close();

	System.out.println(b);// 10
	System.out.println(s);// 100
	System.out.println(i);// 1000
	System.out.println(l);// 10000
	System.out.println(f);// 12.34
	System.out.println(d);// 12.56
	System.out.println(c);// a
	System.out.println(bb);// true
}
```

### 内存操作流

有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。

* ByteArrayInputStream,ByteArrayOutputStream
* CharArrayReader,CharArrayWriter
* StringReader,StringWriter

### 打印流概述

* 字节流打印流 PrintStream
* 字符打印流 PrintWriter

```java
// 复制文本文件
BufferedReader br = new BufferedReader(new FileReader("a.txt"));
PrintWriter pw = new PrintWriter(new FileWriter("b.txt"),true);// 启动自动刷新

String line = null;
while((line=br.readLine())!=null) {
	pw.println(line);
}

pw.close();
br.close();
```

#### 特点

* 只有写数据的，没有读取数据。只能操作目的地，不能操作数据源。
* 可以操作任意类型的数据
* 如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新
* 可以直接操作文件

### 标准输入输出流

System类中的字段：in，out

> 它们各代表了系统标准的输入和输出设备。  
> 默认输入设备是键盘，输出设备是显示器。

* System.in的类型是InputStream.
* System.out的类型是PrintStream,是OutputStream的子类FilterOutputStream 的子类.

#### 三种键盘录入方式

* main方法的args接收参数
* System.in通过BufferedReader进行包装
	- BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
* Scanner
	- Scanner sc = new Scanner(System.in);

#### 输出语句的原理

```java
System.out.println("helloworld");

PrintStream ps = System.out;
ps.println("helloworld");

// 把System.out用字符缓冲流包装一下使用
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
```

### 随机访问流

RandomAccessFile类不属于流，是Object类的子类。  
但它融合了InputStream和OutputStream的功能。  
支持对文件的随机访问读取和写入。  

```java
private static void write() throws IOException {
	// 创建随机访问流对象
	RandomAccessFile raf = new RandomAccessFile("raf.txt", "rw");

	// 怎么玩呢?
	raf.writeInt(100);
	raf.writeChar('a');
	raf.writeUTF("中国");

	raf.close();
}

private static void read() throws IOException {
	// 创建随机访问流对象
	RandomAccessFile raf = new RandomAccessFile("raf.txt", "rw");

	int i = raf.readInt();
	System.out.println(i);
	// 该文件指针可以通过 getFilePointer方法读取，并通过 seek 方法设置。
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	char ch = raf.readChar();
	System.out.println(ch);
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	String s = raf.readUTF();
	System.out.println(s);
	System.out.println("当前文件的指针位置是：" + raf.getFilePointer());

	// 我不想重头开始了，我就要读取a，怎么办呢?
	raf.seek(4);
	ch = raf.readChar();
	System.out.println(ch);
}
```

### 合并流

把多个输入流的数据写到一个输出流中

* SequenceInputStream(InputStream s1, InputStream s2) 
* SequenceInputStream(Enumeration<? extends InputStream> e) 

```java
// 两个
InputStream s1 = new FileInputStream("ByteArrayStreamDemo.java");
InputStream s2 = new FileInputStream("DataStreamDemo.java");
SequenceInputStream sis = new SequenceInputStream(s1, s2);

// 多个
// SequenceInputStream(Enumeration e)
// 通过简单的回顾我们知道了Enumeration是Vector中的一个方法的返回值类型。
// Enumeration<E> elements()
Vector<InputStream> v = new Vector<InputStream>();
InputStream s1 = new FileInputStream("ByteArrayStreamDemo.java");
InputStream s2 = new FileInputStream("CopyFileDemo.java");
InputStream s3 = new FileInputStream("DataStreamDemo.java");
v.add(s1);
v.add(s2);
v.add(s3);
Enumeration<InputStream> en = v.elements();
SequenceInputStream sis = new SequenceInputStream(en);
BufferedOutputStream bos = new BufferedOutputStream(
		new FileOutputStream("Copy.java"));

// 如何写读写呢，其实很简单，你就按照以前怎么读写，现在还是怎么读写
byte[] bys = new byte[1024];
int len = 0;
while ((len = sis.read(bys)) != -1) {
	bos.write(bys, 0, len);
}

bos.close();
sis.close();
```

### 序列化流

可以把对象写入文本文件或者在网络中传输

* 序列化流：把对象按照流一样的方式存入文本文件或者在网络中传输。对象 -- 流数据(ObjectOutputStream)
* 反序列化流:把文本文件中的流对象数据或者网络中的流对象数据还原成对象。流数据 -- 对象(ObjectInputStream)

```java
private static void read() throws IOException, ClassNotFoundException {
	// 创建反序列化对象
	ObjectInputStream ois = new ObjectInputStream(new FileInputStream(
			"oos.txt"));

	// 还原对象
	Object obj = ois.readObject();

	// 释放资源
	ois.close();

	// 输出对象
	System.out.println(obj);
}

private static void write() throws IOException {
	// 创建序列化流对象
	ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(
			"oos.txt"));

	// 创建对象
	Person p = new Person("林青霞", 27);

	// public final void writeObject(Object obj)
	oos.writeObject(p);

	// 释放资源
	oos.close();
}
```

#### 序列化和反序列化

对象序列化是将对象状态转换为可保持或传输的过程。一般的格式是与平台无关的二进制流，可以将这种二进制流持久保存在磁盘上，也可以通过网络将这种二进制流传输到另一个网络结点。  
对象反序列化，是指把这种二进制流数据还原成对象。

#### 如何实现序列化

* 让被序列化的对象所属类实现序列化接口。
* 该接口是一个标记接口。没有功能需要实现。
* 使用transient关键字声明不需要序列化的成员变量

**序列化数据后，再次修改类文件，读取数据会出问题，如何解决呢?**

在类文件中，给出一个固定的序列化id值。

### Properties集合

是一个集合类，Hashtable的子类

#### Properties和IO流的结合使用

* 把键值对形式的文本文件内容加载到集合中
	- public void load(Reader reader)
	- public void load(InputStream inStream)
* 把集合中的数据存储到文本文件中
	- public void store(Writer writer,String comments)
	- public void store(OutputStream out,String comments)

```java
private static void myStore() throws IOException {
	// 创建集合对象
	Properties prop = new Properties();

	prop.setProperty("林青霞", "27");
	prop.setProperty("武鑫", "30");
	prop.setProperty("刘晓曲", "18");
	
	//public void store(Writer writer,String comments):把集合中的数据存储到文件
	Writer w = new FileWriter("name.txt");
	prop.store(w, "helloworld");
	w.close();
}

private static void myLoad() throws IOException {
	Properties prop = new Properties();

	// public void load(Reader reader):把文件中的数据读取到集合中
	// 注意：这个文件的数据必须是键值对形式
	Reader r = this.getClass().getResourceAsStream("prop.txt");// 这里提供过getResourceAsStream()方法获取
	prop.load(r);
	r.close();

	System.out.println("prop:" + prop);
}
```

## NIO和Netty

> JDK4出现NIO。NIO使用了不同的方式来处理输入输出，采用内存映射文件的方式，将文件或者文件的一段区域映射到内存中，就可以像访问内存一样的来访问文件了，这种方式效率比旧IO要高很多。

* Path:路径
* Paths:有一个静态方法返回一个路径
	- public static Path get(URI uri)
* Files:提供了静态方法供我们使用
	- public static long copy(Path source,OutputStream out):复制文件
	- public static Path write(Path path,Iterable<? extends CharSequence> lines,Charset cs,OpenOption... options)

```java
Files.copy(Paths.get("ByteArrayStreamDemo.java"), new FileOutputStream("Copy.java"));

ArrayList<String> array = new ArrayList<String>();
array.add("hello");
array.add("world");
array.add("java");
Files.write(Paths.get("array.txt"), array, Charset.forName("GBK"));
```

### I/O基础入门

Java1.4之前的早期版本，Java对I/O的支持并不完善，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和困难。

* 没有数据缓冲区，I/O性能存在问题
* 没有C或者C++中的Channel概念，只有输入和输出流
* 同步阻塞式I/O通信（BIO），通常会导致通信线程被长时间阻塞
* 支持的字符集有限，硬件可移植性不好

#### Linux网络I/O模型

Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor（fd，文件描述符）。
而对一个socket的读写也会有相应的描述符，称为socketfd（socket描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。

根据UNIX网络编程对I/O模型的分类，UNIX提供了5种I/O模型：

_阻塞I/O模型：_

最常用的I/O模型就是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。以套接字接口为例来讲解此模型：

在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，
在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型。

![阻塞I/O模型](/static/img/2017-01-15-IO流/2018-07-16-12-56-00.png)

_非阻塞I/O模型：_

recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来。

![非阻塞I/O模型](/static/img/2017-01-15-IO流/2018-07-16-12-57-16.png)

_I/O复用模型：_

Linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。
select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。  
Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。

![I/O复用模型](/static/img/2017-01-15-IO流/2018-07-16-12-58-15.png)

_信号驱动I/O模型：_

首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。
当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。

![信号驱动I/O模型](/static/img/2017-01-15-IO流/2018-07-16-12-59-30.png)

_异步I/O：_

告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。

这种模型与信号驱动模型的主要区别是：

信号驱动I/O由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成。

![异步I/O](/static/img/2017-01-15-IO流/2018-07-16-13-00-12.png)

#### I/O多路复用技术

在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。

I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。
与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。

I/O多路复用的主要应用场景：

* 服务器需要同时处理多个处于监听状态或者多个连接状态的套接字；
* 服务器需要同时处理多种网络协议的套接字。

I/O多路复用的系统调用有select、pselect、poll、epoll，在Linux网络编程过程中，很长一段时间都使用select做轮询和网络事件通知，
然而select的一些固有缺陷导致了它的应用受到了很大的限制，最终Linux不得不在新的内核版本中寻找select的替代方案，最终选择了epoll。

epoll与select的原理比较类似，为了克服select的缺点，epoll作了很多重大改进：

1. 支持一个进程打开的socket描述符（FD）不受限制（仅受限于操作系统的最大文件句柄数）。
	* select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。对于那些需要支持上万个TCP连接的大型服务器来说显然太少了。
	* epoll并没有这个限制，它所支持的FD上限是操作系统的最大文件句柄数，这个数字远远大于1024。
2. I/O效率不会随着FD数目的增加而线性下降。
	* 传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，由于网络延时或者链路空闲，任一时刻只有少部分的socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。
	* epoll不存在这个问题，它只会对“活跃”的socket进行操作-这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的，那么，只有“活跃”的socket才会主动的去调用callback函数，其他idle状态socket则不会。在这点上，epoll实现了一个伪AIO。
	* 针对epoll和select性能对比的benchmark测试表明：如果所有的socket都处于活跃态-例如一个高速LAN环境，epoll并不比select/poll效率高太多；相反，如果过多使用epoll_ctl，效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境，epoll的效率就远在select/poll之上了。
3. 使用mmap加速内核与用户空间的消息传递。
	* 无论是select，poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存复制就显得非常重要，epoll是通过内核和用户空间mmap同一块内存实现。
4. epoll的API更加简单。
	* 包括创建一个epoll描述符、添加监听事件、阻塞等待所监听的事件发生，关闭epoll描述符等。

用来克服select/poll缺点的方法不只有epoll，epoll只是一种Linux的实现方案。在freeBSD下有kqueue，而dev/poll是最古老的Solaris的方案，使用难度依次递增。

### NIO入门

#### 传统的BIO编程

网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），
客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。

在基于传统同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功之后，双方通过输入和输出流进行同步阻塞式通信。

同步阻塞I/O服务端通信模型（一客户端一线程）：

![同步阻塞I/O服务端通信模型（一客户端一线程）](/static/img/2017-01-15-IO流/2018-07-16-13-32-05.png)

采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，
处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的一请求一应答通信模型。

该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1：1的正比关系，
由于线程是Java虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，
系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。

#### 伪异步I/O编程

采用线程池和任务队列可以实现一种叫做伪异步的I/O通信框架。

当有新的客户端接入的时候，将客户端的Socket封装成一个Task投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的任务进行处理。
由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。

伪异步I/O服务端通信模型（M：N）：

![伪异步I/O服务端通信模型（M：N）](/static/img/2017-01-15-IO流/2018-07-16-14-06-44.png)

伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。
但是由于它底层的通信依然采用同步阻塞模型，因此无法从根本上解决问题。

#### 伪异步I/O弊端分析

当对Socket的输入流进行读取操作的时候，它会一直阻塞下去，直到发生如下三种事件。

* 有数据可读；
* 可用数据已经读取完毕；
* 发生空指针或者I/O异常。

这意味着当对方发送请求或者应答消息比较缓慢、或者网络传输较慢时，读取输入流一方的通信线程将被长时间阻塞。

当调用OutputStream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。

读和写操作都是同步阻塞的，阻塞的时间取决于对方I/O线程的处理速度和网络I/O的传输速度。

### NIO编程

#### NIO类库简介

NIO弥补了原来同步阻塞I/O的不足，它在标准Java代码中提供了高速的、面向块的I/O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO不用使用本机代码就可以利用低级优化，这是原来的I/O包所无法做到的。

##### 缓冲区Buffer

Buffer是一个对象，它包含一些要写入或者要读出的数据。

在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中，可以将数据直接写入或者将数据直接读到Stream对象中。

在NIO库中，所有数据都是用缓冲区处理的。

* 在读取数据时，它是直接读到缓冲区中的；
* 在写入数据时，写入到缓冲区中。

任何时候访问NIO中的数据，都是通过缓冲区进行操作。

缓冲区实质上是一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。

* ByteBuffer：字节缓冲区
* CharBuffer：字符缓冲区
* ShortBuffer：短整型缓冲区
* IntBuffer：整形缓冲区
* LongBuffer：长整形缓冲区
* FloatBuffer：浮点型缓冲区
* DoubleBuffer：双精度浮点型缓冲区

![Buffer继承关系图](/static/img/2017-01-15-IO流/2018-07-16-16-11-07.png)

##### 通道Channel

Channel是一个通道，可以通过它读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。
通道与流的不同之处在于通道是双向的，流只是在一个方向上移动，而且通道可以用于读、写或者同时用于读写。

因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。特别是在UNIX网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。

![Channel继承关系类图](/static/img/2017-01-15-IO流/2018-07-16-16-22-02.png)

前三层主要是Channel接口，用于定义它的功能，后面是一些具体的功能类（抽象类），从类图可以看出，实际上Channel可以分为两大类：  
分别是用于网络读写的SelectableChannel和用于文件操作的FileChannel。

##### 多路复用器Selector

多路复用器提供选择已经就绪的任务的能力。

简单来讲，Selector会不断地轮询注册在其上的Channel，如果某个Channel上面有新的TCP连接接入、读和写事件，这个Channel就处于就绪状态，
会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。

一个多路复用器Selector可以同时轮询多个Channel，由于JDK使用了epoll()代替传统的select实现，所以它并没有最大连接句柄1024/2048的限制。
这也就意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端，这确实是个非常巨大的进步。

#### NIO服务端序列图

NIO服务端通信序列图：

![NIO服务端通信序列图](/static/img/2017-01-15-IO流/2018-07-16-16-28-10.png)

NIO客户端创建序列图：

![NIO客户端创建序列图](/static/img/2017-01-15-IO流/2018-07-16-19-31-34.png)

使用NIO编程的优点总结如下。

* 客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECT等待后续结果，不需要像之前的客户端那样被同步阻塞。
* SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样I/O通信线程就可以处理其他的链路，不需要同步等待这个链路可用。
* 线程模型的优化：由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制（只受限于操作系统的最大句柄数或者对单个进程的句柄限制），这意味着一个Selector线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降，因此，它非常适合做高性能、高负载的网络服务器。

NIO进行服务端开发的步骤：

1. 创建ServerSocketChannel，配置它为非阻塞模式；
2. 绑定监听，配置TCP参数，例如backlog大小；
3. 创建一个独立的I/O线程，用于轮询多路复用器Selector；
4. 创建Selector，将之前创建的ServerSocketChannel注册到Selector上，监听SelectionKey.ACCEPT；
5. 启动I/O线程，在循环体中执行Selector.select()方法，轮询就绪的Channel；
6. 当轮询到了处于就绪状态的Channel时，需要对其进行判断，如果是OP_ACCEPT状态，说明是新的客户端接入，则调用ServerSocketChannel.accept()方法接受新的客户端；
7. 设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数；
8. 将SocketChannel注册到Selector，监听OP_READ操作位；
9. 如果轮询的Channel为OP_READ，则说明SocketChannel中有新的就绪的数据包需要读取，则构造ByteBuffer对象，读取数据包；
10. 如果轮询的Channel为OP_WRITE，说明还有数据没有发送完成，需要继续发送。

没有考虑半包等问题的代码：

```java
public static void main(String[] args) throws IOException {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}
	}
	MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port);
	new Thread(timeServer, "NIO-MultiplexerTimeServer-001").start();
}
public class MultiplexerTimeServer implements Runnable {
    private Selector selector;
    private ServerSocketChannel serverSocketChannel;
    private volatile boolean stop;
    /**
     * 初始化多路复用器、绑定监听端口
     */
    public MultiplexerTimeServer(int port) {
        try {
            selector = Selector.open();
            serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            System.out.println("The time server is start in port : " + port);
        } catch (IOException e) {
            e.printStackTrace();
            System.exit(1);
        }
    }
    public void stop() {
        this.stop = true;
    }
    @Override
    public void run() {
        while (!stop) {
            try {
                selector.select(1000);
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> it = selectedKeys.iterator();
                SelectionKey key = null;
                while (it.hasNext()) {
                    key = it.next();
                    it.remove();
                    try {
                        handleInput(key);
                    } catch (Exception e) {
                        if (key != null) {
                            key.cancel();
                            if (key.channel() != null)
                                key.channel().close();
                        }
                    }
                }
            } catch (Throwable t) {
                t.printStackTrace();
            }
        }
        // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源
        if (selector != null) {
            try {
                selector.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    private void handleInput(SelectionKey key) throws IOException {
        if (key.isValid()) {
            // 处理新接入的请求消息
            if (key.isAcceptable()) {
                // Accept the new connection
                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                SocketChannel socketChannel = serverSocketChannel.accept();
                socketChannel.configureBlocking(false);
                // Add the new connection to the selector
                socketChannel.register(selector, SelectionKey.OP_READ);
            }
            if (key.isReadable()) {
                // Read the data
                SocketChannel socketChannel = (SocketChannel) key.channel();
                ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                int readBytes = socketChannel.read(readBuffer);
                if (readBytes > 0) {
                    readBuffer.flip();
                    byte[] bytes = new byte[readBuffer.remaining()];
                    readBuffer.get(bytes);
                    String body = new String(bytes, "UTF-8");
                    System.out.println("The time server receive order : " + body);
                    String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body) ?
                            new java.util.Date(System.currentTimeMillis()).toString() :
                            "BAD ORDER";
                    doWrite(socketChannel, currentTime);
                } else if (readBytes < 0) {
                    // 对端链路关闭
                    key.cancel();
                    socketChannel.close();
                }
                // 读到0字节，忽略
            }
        }
    }
    private void doWrite(SocketChannel channel, String response)
            throws IOException {
        if (response != null && response.trim().length() > 0) {
            byte[] bytes = response.getBytes();
            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);
            writeBuffer.put(bytes);
            writeBuffer.flip();
            channel.write(writeBuffer);
        }
    }
}
```

```java
public static void main(String[] args) {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}
	}
	new Thread(new TimeClientHandle("127.0.0.1", port), "TimeClient-001").start();
}

public class TimeClientHandle implements Runnable {
    private String host;
    private int port;
    private Selector selector;
    private SocketChannel socketChannel;
    private volatile boolean stop;
    public TimeClientHandle(String host, int port) {
        this.host = host == null ? "127.0.0.1" : host;
        this.port = port;
        try {
            selector = Selector.open();
            socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(false);
        } catch (IOException e) {
            e.printStackTrace();
            System.exit(1);
        }
    }
    @Override
    public void run() {
        try {
            doConnect();
        } catch (IOException e) {
            e.printStackTrace();
            System.exit(1);
        }
        while (!stop) {
            try {
                selector.select(1000);
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> it = selectedKeys.iterator();
                SelectionKey key = null;
                while (it.hasNext()) {
                    key = it.next();
                    it.remove();
                    try {
                        handleInput(key);
                    } catch (Exception e) {
                        if (key != null) {
                            key.cancel();
                            if (key.channel() != null)
                                key.channel().close();
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
                System.exit(1);
            }
        }
        // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源
        if (selector != null) {
            try {
                selector.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
    private void handleInput(SelectionKey key) throws IOException {
        if (key.isValid()) {
            // 判断是否连接成功
            SocketChannel socketChannel = (SocketChannel) key.channel();
            if (key.isConnectable()) {
                if (socketChannel.finishConnect()) {
                    socketChannel.register(selector, SelectionKey.OP_READ);
                    doWrite(socketChannel);
                } else {
                    System.exit(1);// 连接失败，进程退出
                }
            }
            if (key.isReadable()) {
                ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                int readBytes = socketChannel.read(readBuffer);
                if (readBytes > 0) {
                    readBuffer.flip();
                    byte[] bytes = new byte[readBuffer.remaining()];
                    readBuffer.get(bytes);
                    String body = new String(bytes, "UTF-8");
                    System.out.println("Now is : " + body);
                    this.stop = true;
                } else if (readBytes < 0) {
                    // 对端链路关闭
                    key.cancel();
                    socketChannel.close();
                }
                // 读到0字节，忽略
            }
        }
    }
    private void doConnect() throws IOException {
        // 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答
        if (socketChannel.connect(new InetSocketAddress(host, port))) {
            socketChannel.register(selector, SelectionKey.OP_READ);
            doWrite(socketChannel);
        } else {
            socketChannel.register(selector, SelectionKey.OP_CONNECT);
        }
    }
    private void doWrite(SocketChannel socketChannel) throws IOException {
        byte[] req = "QUERY TIME ORDER".getBytes();
        ByteBuffer writeBuffer = ByteBuffer.allocate(req.length);
        writeBuffer.put(req);
        writeBuffer.flip();
        socketChannel.write(writeBuffer);
        if (!writeBuffer.hasRemaining()) {
            System.out.println("Send order 2 server succeed.");
        }
    }

}
```

#### AIO编程

JDK1.7升级了NIO类库，升级后的NIO类库被称为NIO2.0，Java正式提供了异步文件I/O操作，同时提供了与UNIX网络编程事件驱动I/O对应的AIO。

NIO2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供两种方式获取获取操作结果。

* 通过java.util.concurrent.Future类来表示异步操作的结果；
* 在执行异步操作的时候传入一个java.nio.channels。

CompletionHandler接口的实现类作为操作完成的回调。

NIO2.0的异步套接字通道是真正的异步非阻塞I/O，它对应UNIX网络编程中的事件驱动I/O（AIO），
它不需要通过多路复用器（Selector）对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。

由JDK底层的ThreadPoolExecutor进行调度并驱动读写操作，不需要开线程，因此更加简单。

没有考虑半包等问题的代码：

```java
public static void main(String[] args) throws IOException {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}
	}
	AsyncTimeServerHandler timeServer = new AsyncTimeServerHandler(port);
	new Thread(timeServer, "AIO-AsyncTimeServerHandler-001").start();
}
public class AsyncTimeServerHandler implements Runnable {
    private int port;
    CountDownLatch latch;
    AsynchronousServerSocketChannel asynchronousServerSocketChannel;
    public AsyncTimeServerHandler(int port) {
        this.port = port;
        try {
            asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();
            asynchronousServerSocketChannel.bind(new InetSocketAddress(port));
            System.out.println("The time server is start in port : " + port);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void run() {
        latch = new CountDownLatch(1);
        doAccept();
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public void doAccept() {
        asynchronousServerSocketChannel.accept(this, new AcceptCompletionHandler());
    }
}
public class AcceptCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, AsyncTimeServerHandler> {
    @Override
    public void completed(AsynchronousSocketChannel result, AsyncTimeServerHandler asyncTimeServerHandler) {
        asyncTimeServerHandler.asynchronousServerSocketChannel.accept(asyncTimeServerHandler, this);
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        result.read(buffer, buffer, new ReadCompletionHandler(result));
    }
    @Override
    public void failed(Throwable exc, AsyncTimeServerHandler attachment) {
        exc.printStackTrace();
        attachment.latch.countDown();
    }
}

public class ReadCompletionHandler implements CompletionHandler<Integer, ByteBuffer> {
    private AsynchronousSocketChannel channel;
    public ReadCompletionHandler(AsynchronousSocketChannel channel) {
        if (this.channel == null) {
            this.channel = channel;
        }
    }
    @Override
    public void completed(Integer result, ByteBuffer attachment) {
        attachment.flip();
        byte[] body = new byte[attachment.remaining()];
        attachment.get(body);
        try {
            String req = new String(body, "UTF-8");
            System.out.println("The time server receive order : " + req);
            String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(req) ? new java.util.Date(
                    System.currentTimeMillis()).toString() : "BAD ORDER";
            doWrite(currentTime);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }
    private void doWrite(String currentTime) {
        if (currentTime != null && currentTime.trim().length() > 0) {
            byte[] bytes = (currentTime).getBytes();
            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);
            writeBuffer.put(bytes);
            writeBuffer.flip();
            channel.write(writeBuffer, writeBuffer,
                    new CompletionHandler<Integer, ByteBuffer>() {
                        @Override
                        public void completed(Integer result, ByteBuffer buffer) {
                            // 如果没有发送完成，继续发送
                            if (buffer.hasRemaining()) {
                                channel.write(buffer, buffer, this);
                            }
                        }
                        @Override
                        public void failed(Throwable exc, ByteBuffer attachment) {
                            try {
                                channel.close();
                            } catch (IOException e) {
                                // ingnore on close
                            }
                        }
                    });
        }
    }
    @Override
    public void failed(Throwable exc, ByteBuffer attachment) {
        try {
            this.channel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public static void main(String[] args) {
	int port = 8080;
	if (args != null && args.length > 0) {
		try {
			port = Integer.valueOf(args[0]);
		} catch (NumberFormatException e) {
			// 采用默认值
		}

	}
	new Thread(new AsyncTimeClientHandler("127.0.0.1", port),"AIO-AsyncTimeClientHandler-001").start();

}

public class AsyncTimeClientHandler implements CompletionHandler<Void, AsyncTimeClientHandler>, Runnable {
    private AsynchronousSocketChannel client;
    private String host;
    private int port;
    private CountDownLatch latch;
    public AsyncTimeClientHandler(String host, int port) {
        this.host = host;
        this.port = port;
        try {
            client = AsynchronousSocketChannel.open();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void run() {
        latch = new CountDownLatch(1);
        client.connect(new InetSocketAddress(host, port), this, this);
        try {
            latch.await();
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
        try {
            client.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void completed(Void result, AsyncTimeClientHandler attachment) {
        byte[] req = "QUERY TIME ORDER".getBytes();
        ByteBuffer writeBuffer = ByteBuffer.allocate(req.length);
        writeBuffer.put(req);
        writeBuffer.flip();
        client.write(writeBuffer, writeBuffer,
                new CompletionHandler<Integer, ByteBuffer>() {
                    @Override
                    public void completed(Integer result, ByteBuffer buffer) {
                        if (buffer.hasRemaining()) {
                            client.write(buffer, buffer, this);
                        } else {
                            ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                            client.read(
                                    readBuffer,
                                    readBuffer,
                                    new CompletionHandler<Integer, ByteBuffer>() {
                                        @Override
                                        public void completed(Integer result, ByteBuffer buffer) {
                                            buffer.flip();
                                            byte[] bytes = new byte[buffer.remaining()];
                                            buffer.get(bytes);
                                            String body;
                                            try {
                                                body = new String(bytes, "UTF-8");
                                                System.out.println("Now is : " + body);
                                                latch.countDown();
                                            } catch (UnsupportedEncodingException e) {
                                                e.printStackTrace();
                                            }
                                        }
                                        @Override
                                        public void failed(Throwable exc, ByteBuffer attachment) {
                                            try {
                                                client.close();
                                                latch.countDown();
                                            } catch (IOException e) {
                                                // ingnore on close
                                            }
                                        }
                                    });
                        }
                    }
                    @Override
                    public void failed(Throwable exc, ByteBuffer attachment) {
                        try {
                            client.close();
                            latch.countDown();
                        } catch (IOException e) {
                            // ingnore on close
                        }
                    }
                });
    }
    @Override
    public void failed(Throwable exc, AsyncTimeClientHandler attachment) {
        exc.printStackTrace();
        try {
            client.close();
            latch.countDown();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 4种I/O对比

##### 概念

**异步非阻塞I/O**

在早期的JDK1.4和1.5 update10版本之前，JDK的Selector基于select/poll模型实现，它是基于I/O复用技术的非阻塞I/O，不是异步I/O。  
在JDK1.5 update10和Linux core2.6以上版本，Sun优化了Selctor的实现，它在底层使用epoll替换了select/poll，上层的API并没有变化，可以认为是JDK NIO的一次性能优化，但是它仍旧没有改变I/O的模型。  
由JDK1.7提供的NIO2.0，新增了异步的套接字通道，它是真正的异步I/O，在异步I/O操作的时候可以传递信号变量，当操作完成之后会回调相关的方法，异步I/O也被称为AIO。

**多路复用器Selector**

Java NIO的实现关键是多路复用I/O技术，多路复用的核心就是通过Selector来轮询注册在其上的Channel，当发现某个或者多个Channel处于就绪状态后，从阻塞状态返回就绪的Channel的选择键集合，进行I/O操作。

**伪异步I/O**

在通信线程和业务线程之间做个缓冲区，这个缓冲区用于隔离I/O线程和业务线程间的直接访问，这样业务线程就不会被I/O线程阻塞。

对于后端的业务侧来说，将消息或者Task放到线程池后就返回了，它不再直接访问I/O线程或者进行I/O读写，这样也就不会被同步阻塞。

类似的设计还包括前端启动一组线程，将接收的客户端封装成Task，放到后端的线程池执行，用于解决一连接一线程问题。

##### 对比

几种I/O模型的功能和特性对比：

![几种I/O模型的功能和特性对比](/static/img/2017-01-15-IO流/2018-07-17-14-23-24.png)

具体选择什么样的I/O模型或者NIO框架，完全基于业务的实际应用场景和性能诉求：

* 如果客户端并发连接数不多，周边对接的网元不多，服务器的负载也不重，那就完全没必要选择NIO做服务端；
* 如果是相反情况，那就要考虑选择合适的NIO框架进行开发。

#### 原生NIO与Netty对比

开发出高质量的NIO程序并不是一件简单的事情，除去NIO固有的复杂性和BUG不谈，作为一个NIO服务端，需要能够处理网络的闪断、客户端的重复接入、客户端的安全认证、消息的编解码、半包读写等情况，
如果你没有足够的NIO编程经验积累，一个NIO框架的稳定往往需要半年甚至更长的时间。更为糟糕的是，一旦在生产环境中发生问题，往往会导致跨节点的服务调用中断，严重的可能会导致整个集群环境都不可用，需要重启服务器，这种非正常停机会带来巨大的损失。

从可维护性角度看，由于NIO采用了异步非阻塞编程模型，而且是一个I/O线程处理多条链路，它的调试和跟踪非常麻烦，特别是生产环境中的问题，我们无法进行有效的调试和跟踪，往往只能靠一些日志来辅助分析，定位难度很大。

##### 不选择原生NIO编程的原因

1. NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。
2. 需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序。
3. 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。
4. JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该BUG发生概率降低了一些而已，它并没有被根本解决。

##### 为什么选择Netty

Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证。  
例如Hadoop的RPC框架avro使用Netty作为底层通信框架；很多其他业界主流的RPC框架，也使用Netty来构建高性能的异步通信能力。

* PI使用简单，开发门槛低；
* 功能强大，预置了多种编解码功能，支持多种主流协议；
* 定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；
* 性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；
* 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；
* 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；
* 经历了大规模的商业应用考验，质量得到验证。
	* 在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它已经完全能够满足不同行业的商业应用了。

正是因为这些优点，Netty逐渐成为Java NIO编程的首选框架。

### TCP粘包/拆包问题的解决

#### TCP粘包/拆包

TCP是个“流”协议，所谓流，就是没有界限的一串数据。

TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，
一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

TCP粘包/拆包问题：

![TCP粘包/拆包问题](/static/img/2017-01-15-IO流/2018-07-17-17-10-16.png)

1. 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；
2. 服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；
3. 服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；
4. 服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。
5. 如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。

#### TCP粘包/拆包问题原因

1. 应用程序write写入的字节大小大于套接口发送缓冲区大小；
2. 进行MSS大小的TCP分段；
3. 以太网帧的payload大于MTU进行IP分片。

![TCP粘包/拆包问题原因](/static/img/2017-01-15-IO流/2018-07-17-17-14-07.png)

#### 解决策略

由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，
这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。

1. 消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
2. 在包尾增加回车换行符进行分割，例如FTP协议；
3. 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；
4. 更复杂的应用层协议。

#### 利用LineBasedFrameDecoder解决TCP粘包问题

为了解决TCP粘包/拆包导致的半包读写问题，Netty默认提供了多种编解码器用于处理半包，只要能熟练掌握这些类库的使用，TCP粘包问题从此会变得非常容易，
你甚至不需要关心它们，这也是其他NIO框架和JDK原生的NIO API所无法匹敌的。

通过Netty的LineBasedFrameDecoder和StringDecoder来解决TCP粘包问题。

```java
public class TimeServer {
    public void bind(int port) throws Exception {
        // 配置服务端的NIO线程组
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 1024)
                    .childHandler(new ChildChannelHandler());
            // 绑定端口，同步等待成功
            ChannelFuture f = serverBootstrap.bind(port).sync();
            // 等待服务端监听端口关闭
            f.channel().closeFuture().sync();
        } finally {
            // 优雅退出，释放线程池资源
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
    private class ChildChannelHandler extends ChannelInitializer<SocketChannel> {
        @Override
        protected void initChannel(SocketChannel socketChannel) throws Exception {
			// 编解码器
            socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));
            socketChannel.pipeline().addLast(new StringDecoder());
            socketChannel.pipeline().addLast(new TimeServerHandler());
        }
    }
    public static void main(String[] args) throws Exception {
        int port = 8080;
        if (args != null && args.length > 0) {
            try {
                port = Integer.valueOf(args[0]);
            } catch (NumberFormatException e) {
                // 采用默认值
            }
        }
        new TimeServer().bind(port);
    }
}

public class TimeServerHandler extends ChannelHandlerAdapter {
    private int counter;
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        String body = (String) msg;
        System.out.println("The time server receive order : " + body + " ; the counter is : " + ++counter);
        String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body)
                ? new java.util.Date(System.currentTimeMillis()).toString()
                : "BAD ORDER";
        currentTime = currentTime + System.getProperty("line.separator");
        ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes());
        ctx.writeAndFlush(resp);
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        ctx.close();
    }
}
```

```java
public class TimeClient {
    public void connect(int port, String host) throws Exception {
        // 配置客户端NIO线程组
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap
                    .group(group)
                    .channel(NioSocketChannel.class)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        public void initChannel(SocketChannel ch)
                                throws Exception {
                            ch.pipeline().addLast(new LineBasedFrameDecoder(1024));
                            ch.pipeline().addLast(new StringDecoder());
                            ch.pipeline().addLast(new TimeClientHandler());
                        }
                    });
            // 发起异步连接操作
            ChannelFuture f = bootstrap.connect(host, port).sync();
            // 当代客户端链路关闭
            f.channel().closeFuture().sync();
        } finally {
            // 优雅退出，释放NIO线程组
            group.shutdownGracefully();
        }
    }
    public static void main(String[] args) throws Exception {
        int port = 8080;
        if (args != null && args.length > 0) {
            try {
                port = Integer.valueOf(args[0]);
            } catch (NumberFormatException e) {
                // 采用默认值
            }
        }
        new TimeClient().connect(port, "127.0.0.1");
    }
}

public class TimeClientHandler extends ChannelHandlerAdapter {
    private static final Logger LOGGER = Logger.getLogger(TimeClientHandler.class.getName());
    private int counter;
    private byte[] req;
    /**
     * Creates a client-side handler.
     */
    public TimeClientHandler() {
        req = ("QUERY TIME ORDER" + System.getProperty("line.separator")).getBytes();
    }
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        ByteBuf message = null;
        for (int i = 0; i < 100; i++) {
            message = Unpooled.buffer(req.length);
            message.writeBytes(req);
            ctx.writeAndFlush(message);
        }
    }
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        String body = (String) msg;
        System.out.println("Now is : " + body + " ; the counter is : " + ++counter);
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // 释放资源
        LOGGER.warning("Unexpected exception from downstream : " + cause.getMessage());
        ctx.close();
    }
}
```

LineBasedFrameDecoder的工作原理是它依次遍历ByteBuf中的可读字节，判断看是否有"\n"或者"\r\n"，
如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。
它是以换行符为结束标志的解码器，支持携带结束符或者不携带结束符两种解码方式，同时支待配置单行的最大长度。
如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读到的异常码流。

StringDecoder的功能非常简单，就是将接收到的对象转换成字符串，然后继续调用后面的Handler，LineBasedFrameDecoder+StringDecoder组合就是按行切换的文本解码器，它被设计用来⽀持TCP的粘包和拆包。

Netty提供了多种⽀持 TCP 粘包/拆包的解码器, 用来满⾜用户的不同诉求。

#### 分隔符和定长解码器

DelimiterBasedFrameDecoder和FixedLengthFrameDecoder，前者可以自动完成以分隔符做结束标志的消息的解码，后者可以自动完成对定长消息的解码，它们都能解决TCP粘包／拆包导致的读半包问题。

只要将DelimiterBasedFrameDecoder或FixedLengthFrameDecoder添加到对应ChannelPipeline的起始位即可。

```java
// 在传输数据时需要追加分隔符字符。
// server
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch)
					throws Exception {
				ByteBuf delimiter = Unpooled.copiedBuffer("$_".getBytes());
				ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
				ch.pipeline().addLast(new StringDecoder());
				ch.pipeline().addLast(new EchoServerHandler());
			}
		});
// client
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCP_NODELAY, true)
		.handler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ByteBuf delimiter = Unpooled.copiedBuffer("$_".getBytes());
				ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
				ch.pipeline().addLast(new StringDecoder());
				ch.pipeline().addLast(new EchoClientHandler());
			}
		});
```

使用DelimiterBasedFrameDecoder可以自动对采用分隔符做码流结束标识的消息进行解码。

```java
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ch.pipeline().addLast(new FixedLengthFrameDecoder(20));
				ch.pipeline().addLast(new StringDecoder());
				ch.pipeline().addLast(new EchoServerHandler());
			}
		});
```

利用FixedLengthFrameDecoder解码器，无论一次接收到多少数据报，它都会按照构造函数中设置的固定长度进行解码，
如果是半包消息，FixedLengthFrameDecoder会缓存半包消息并等待下个包到达后进行拼包，直到读取到一个完整的包。

### 编辑码技术

Java 序列化的目的主要有两个：

* 网络传输
* 对象持久化

当进行远程跨进程服务调用时，需要把被传输的Java对象编码为字节数组或者ByteBuffer对象。
而当远桯服务读取到ByteBuffer对象或者字节数组时，需要将其解码为发送时的Java对象。这被称为Java对象编解码技术。

评判一个编解码框架的优劣时，往往会考虑以下几个因素：

* 是否支持跨语言，支持的语言种类是否丰富；
* 一编码后的码流大小；
* 编解码的性能；
* 类库是否小巧，APl使用是否方便；
* 使用者需要手工开发的工作量和难度。

#### Java序列化的缺点

* 无法跨语言
	* 最致命的问题
* 序列化后码流太大
	* 1
* 序列化性能太低
* 序列化性能太低

```java
public byte[] codeC() {
	ByteBuffer buffer = ByteBuffer.allocate(1024);
	byte[] value = this.userName.getBytes();
	buffer.putInt(value.length);
	buffer.put(value);
	buffer.putInt(this.userID);
	buffer.flip();
	byte[] result = new byte[buffer.remaining()];
	buffer.get(result);
	return result;
}
```

序列化性能对比图：

![序列化性能对比图](/static/img/2017-01-15-IO流/2018-07-18-11-10-37.png)

#### 业界主流的编解码框架

##### Google的Protobuf

Protobuf全称Google Protocol Buffers,它由谷歌开源而来，在谷歌内部久经考验。
它将数据结构以proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。

* 结构化数据存储格式(XML,JSON等）；
* 高效的编解码性能；
* 语言无关、平台无关、扩展性好；
* 官方支持Java、C++和Python三种语言。

尽管XML的可读性和可扩展性非常好，也非常适合描述数据结构，但是XML解析的时间开销和XML为了可读性而牺牲的空间开销都非常大，因此不适合做高性能的通信协议。
Protobuf使用二进制编码，在空间和性能上具有更大的优势。

Protobuf另一个比较吸引人的地方就是它的数据描述文件和代码生成机制，利用数据描述文件对数据结构进行说明的优点如下：

* 文本化的数据结构描述语言，可以实现语言和平台无关，特别适合异构系统间的集成；
* 通过标识字段的顺序，可以实现协议的前向兼容；
* 自动代码生成，不需要手工编写同样数据结构的C++和Java版本；
* 方使后续的管理和维护。相比于代码，结构化的文档更容易管理和维护。

Protobuf编解码和其他几种序列化框架的响应时间对比：

![Protobuf编解码和其他几种序列化框架的响应时间对比](/static/img/2017-01-15-IO流/2018-07-18-11-24-32.png)

Protobuf和其他几种序列化框架的宇节数对比：

![Protobuf和其他几种序列化框架的宇节数对比](/static/img/2017-01-15-IO流/2018-07-18-11-26-28.png)

Protobuf的编解码性能远远高于其他几种序列化相架的序列化和反序列化，这也是很多RPC框架选用Protobuf做编解码框架的原因。

通过protoc.exe 命令行生成Java代码。

![SubscribeResp.proto文件定义](/static/img/2017-01-15-IO流/2018-07-18-16-28-18.png)

```java
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) {
				// netty的粘包半包支持
				ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());
				ch.pipeline().addLast(new ProtobufDecoder(SubscribeReqProto.SubscribeReq.getDefaultinstance()));
				ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());
				ch.pipeline().addLast(new ProtobufEncoder());
				ch.pipeline().addLast(new SubReqServerHandler());

			}
		});
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCPNODELAY, true)
		.handler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());
				ch.pipeline().addLast(new ProtobufDecoder(SubscribeRespProto.SubscribeResp.getDefaultinstance()));
				ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());
				ch.pipeline().addLast(new ProtobufEncoder());
				ch.pipeline().addLast(new SubReqClientHandler());
			}
		});
```

1. 使用Netty提供的Protobutvarint32FrameDecoder,它可以处理半包消息；
2. 继承Netty提供的通用半包解码器LengthFieldBasedFrameDecoder;
3. 继承ByteToMessageDecoder类，自己处理半包消息。

##### Facebook的Thrift介绍

创造Thrift是为了解决Facebook各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性，
因此Thrift可以支持多种程序语言，如C++、C#、Cocoa、Erlang、Haskell、Java、Ocami、Perl、PHP、Python、Ruby和Smalltalk。

在多种不同的语言之间通信，Thrift可以作为高性能的通信中间件使用，它支持数据（对象）序列化和多种类型的RPC服务。
Thrift适用于静态的数据交换，需要先确定好它的数据结构，当数据结构发生变化时，必须重新编辑IDL文件，生成代码和编译，这一点跟具他IDL工具相比可以视为是Thrift的弱项。
Thrift适用于搭建大型数据交换及存储的通用工具，对于大型系统中的内部数据传输，相对于JSON和XML在性能和传输大小上都有明显的优势。

Thrift主要由5部分组成。

1. 语言系统以及IDL编译器：负责由用户给定的IDL文件生成相应语言的接口代码；
2. TProtocol：RPC的协议层，可以选择多种不同的对象序列化方式，如JSON和Binary;
3. TTransport：RPC的传输层，同样可以选择不同的传输层实现，如socket、NIO、MemoryBuffer等
4. TProcessor：作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口：
5. TServer：聚合TProtocol、TTransport和TProcessor等对象。

由于Thrift的RPC服务调用和编解码框架绑定在一起，所以，通常我们使用Thrift的时候会采取RPC框架的方式。
但是，它的TProtocol编解码框架还是可以以类库的方式独立使用的。

与Protobuf比较类似的是，Thrift通过IDL描述接口和数据结构定义，它支持8种Java基本类型、Map、Set和List,支持可选和必选定义，功能非常强大。
因为可以定义数据结构中字段的顺序，所以它也可以支待协议的前向兼容。

Thrift支持三种比较典型的编解码方式。

* 通用的二进制编解码：
* 压缩二进制编解码；
* 优化的可选字段压缩编解码。

由于支持二进制压缩编解码，Thrift的编解码性能表现也相当优异，远远超过Java序列化和RMI。

![Thrift性能测试对比图](/static/img/2017-01-15-IO流/2018-07-18-11-37-54.png)

##### JBoss Marshalling介绍

JBoss Marshalling是一个Java对象的序列化API包，修正了JDK自带的序列化包的很多问题，但又保待跟java.io.Serializable接口的兼容；
同时增加了一些可调的参数和附加的特性，并且这些参数和特性可通过工厂类进行配置。

相比于传统的Java序列化机制，它的优点如下：

* 可插拔的类解析器，提供更加便捷的类加载定制策略，通过一个接口即可实现定制；
* 可插拔的对象替换技术，不需要通过继承的方式；
* 可插拔的预定义类缓存表，可以减小序列化的字节数组长度，提升常用类型的对象序列化性能；
* 无须实现java.io.Serializable 接口，即可实现Java 序列化；
* 通过缓存技术提升对象的序列化性能。

JBoss Marshalling更多是在JBoss内部使用，应用范围有限。

```java
public final class MarshallingCodeCFactory {
    /**
     * 创建Jboss Marshalling解码器MarshallingDecoder
     */
    public static MarshallingDecoder buildMarshallingDecoder() {
        final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
        final MarshallingConfiguration configuration = new MarshallingConfiguration();
        configuration.setVersion(5);
        UnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);
        MarshallingDecoder decoder = new MarshallingDecoder(provider, 1024);
        return decoder;
    }
    /**
     * 创建Jboss Marshalling编码器MarshallingEncoder
     */
    public static MarshallingEncoder buildMarshallingEncoder() {
        final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
        final MarshallingConfiguration configuration = new MarshallingConfiguration();
        configuration.setVersion(5);
        MarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);
        MarshallingEncoder encoder = new MarshallingEncoder(provider);
        return encoder;
    }
}
```

```java
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap
		.group(bossGroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) {
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
				ch.pipeline().addLast(new SubReqServerHandler());
			}
		});
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCP_NODELAY, true)
		.handler(new ChannelInitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch)
					throws Exception {
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
				ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
				ch.pipeline().addLast(new SubReqClientHandler());
			}
		});
```

Marshalling编解码器支持半包和粘包的处理。

##### MessagePack编解码

MessagcPack是一个高效的二进制序列化框架，它像JSON一样支持不同语言间的数据交换，但是它的性能更快，序列化之后的码流也更小。

MessagePack的特点如下：

* 编解码高效，性能高；
* 序列化之后的码流小；
* 支持跨语言。
	* Java、Python、Ruby、Haskell、C#、OCaml、Lua、Go、C、C++等

```xml
<dependencies>
  <dependency>
    <groupId>org.msgpack</groupId>
    <artifactId>msgpack</artifactId>
    <version>${msgpack.version}</version>
  </dependency>
</dependencies>
```

```java
// Create serialize objects.
List<String> src = new ArrayList<String>();
src.add("msgpack");
src.add("kumofs");
src.add("viver");
MessagePack msgpack = new MessagePack();
// Serialize
byte[] raw = msgpack.write(src);
// Deserialize directly using a template
List<String> dst1 = msgpack.read(raw, Templates.tList(Templates.TString));
// Or, Deserialze to Value then convert type.
Value dynamic = msgpack.read(raw);
List<String> dst2 = new Converter(dynamic).read(Templates.tList(Templates.TString));
```

```java
Bootstrap bootstrap = new Bootstrap();
bootstrap
		.group(group)
		.channel(NioSocketChannel.class)
		.option(ChannelOption.TCP_NODELAY, true)
		.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)
		.handler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				// 粘包、半包支持及编解码支持
				ch.pipeline().addLast("frameDecoder", new LengthFieldBasedFrameDecoder(65535, 0, 2, 0, 2));
				ch.pipeline().addLast("msgpack decoder", new MsgpackDecoder());
				// 增加头
				ch.pipeline().addLast("frameEncoder", new LengthFieldPrepender(2));
				ch.pipeline().addLast("msgpack encoder", new MsgpackEncoder());
				ch.pipeline().addLast(new EchoClientHandler(sendNumber));
			}
		});

ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap
		.group(acceptorGroup, IOGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 100)
		.handler(new LoggingHandler(LogLevel.INFO))
		.childHandler(new Channelinitializer<SocketChannel>() {
			@Override
			public void initChannel(SocketChannel ch) throws Exception {
				ch.pipeline().addLast("frameDecoder", new LengthFieldBasedFrameDecoder(65535, O, 2, 0, 2));
				ch.pipeline().addLast("msgpack decoder", new MsgpaclcDecoder());
				ch.pipeline().addLast("frameEncoder", new LengthFieldPrepender(2));
				ch.pipeline().addLast("msgpack encoder", new MsgpackEncoder());
				ch.pipeline().addLast(new EchoServerHandler());
			}

		});
```

在MessagePack编码器之前增加LengthFieldPrepender，它将在ByteBuf之前增加2个字节的消息长度字段。

![LengtbfieldPrepender原理示意图](/static/img/2017-01-15-IO流/2018-07-18-16-14-10.png)

在MessagePack解码器之前增加LengthFieldBasedFrameDecoder，用于处理半包消息，这样后面的MsgpackDecoder接收到的永远是整包消息。

![LengthFieldBasedFrameDecoder工作原理图](/static/img/2017-01-15-IO流/2018-07-18-16-15-19.png)

利用Netty的半包编码和解码器LengthFieldPrepender和LengthFieldBasedFrameDecoder，可以轻松地解决TCP粘包和半包问题。

### Netty多协议开发

#### Http协议介绍

HTTP是一个属千应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。

HTTP协议的主要特点：

* 支持Client/Server模式；
* 简单：客户向服务器请求服务时，只需指定服务URL,携带必要的请求参数或者消息体；
* 灵活：HTTP允许传输任意类型的数据对象，传输的内容类型由HTTP消息头中的Content-Type加以标记；
* 无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。
	* 缺少状态意味着如果后续处理衙要之前的信息，则它必须重传，这样可能导致每次连接传送的数据压增大。
	* 另一方面，在服务器不需要先前信息时它的应答就较快，负载较轻。

##### URL

```text
http://host[":"port)(abs_path]
```

##### 请求信息

* HTTP请求行；
* HTTP消息头；
* HTTP请求正文。

请求行以一个方法符开头，以空格分开，后面跟着请求的URI和协议的版本，格式为：Method Request-URI HTTP-Version CRLF。

其中Method表示请求方法，Request-URI是一个统一资源标识符，HTTP-Version表示请求的HTTP协议版本，CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。

请求方法有多种，各方法的作用：

* GET:请求获取Request-URI所标识的资源；
* POST:在Request-URI所标识的资源后附加新的提交数据；
* HEAD:请求获取由Request-URI所标识的资源的响应消息报头；
* PUT:请求服务器存储一个资源，并用Request-URI作为其标识；
* DELETE:诸求服务器删除Request-URI所标识的资源；
* TRACE:请求服务器回送收到的请求信息，主要用于刹试或诊断；
* CONNECT:保留将来使用；
* OPTIONS:请求查询服务器的性能，或者查询与资源相关的选项和需求。

GET方法：以在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源。

POST方法：要求被请求服务器接受附在请求后面的数据，常用于提交表单。

1. 根据HTTP规范，GET用于信息获取，而且应该是安全的和幕等的；POST则表示可能改变服务器上的资源的请求。
2. GET提交，请求的数据会附在URL之后，就是把数据放置在请求行(requestIine)中，以"?"分隔URL和传输数据，多个参数用"&"连接；而POST提交会把提交的数据放置在HTTP消息的包体中，数据不会在地址栏中显示出来。
3. 传输数据的大小不同。特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2KB+35B),因此GET携带的参数的长度会受到浏览器的限制；而POST由于不是通过URL传值，理论上数据长度不会受限。
4. 安全性。POST的安全性要比GET的安全性商。比如通过GET提交数据，用户名和密码将明文出现在URL上。
	* 登录页面有可能被浏览器缓存，其他人查看浏览器的历史记录，那么别人就可以拿到你的账号和密码了。
	* 除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。POST提交的内容由于在消息体中传输，因此不存在上述安全问题。

HTTP的部分请求消息头列表：

| 名称(KEY)       | 作用                                                                                                                               |
|:----------------|:-----------------------------------------------------------------------------------------------------------------------------------|
| Accept          | 用于指定客户端接受哪些类型的信息。                                                                                                 |
| Accept-Charset  | 用于指定客户茹接受的字符集。                                                                                                       |
| Accept-Encoding | 用于指定可接受的内容编码。                                                                                                         |
| Accept-Language | 用于指定一种自然语言。                                                                                                             |
| Authorization   | 主要用于证明客户端有权查看某个资源。服务器的响应代码为401，可以发送一个包含Authorization诸求报头域的诺求，要求服务器对其进行认证。 |
| Host            | 指定被谐求资源的Internet主机和端口号，它通常是从HTTP URL中提取出来的。                                                             |
| User-Agent      | 允许客户端将它的操作系统、浏览器和其他屈性告诉服务器。                                                                             |
| Content-Length  | 请求消息体的长度。                                                                                                                 |
| Content-Type    | 表示后面的文档属千什么MIME类型。                                                                                                   |
| Connection      | 连接类型                                                                                                                           |

##### 响应消息

三个部分组成，分别是：状态行、消息报头、响应正文。

状态行的格式为：HTTP-Version Status-Code Reason-Phrase CRLF, 其中HTTP-Version表示服务器HTTP协议的版本，Status-Code表示服务器返回的响应状态代码。

状态代码由三位数字组成，第一个数字定义了响应的类别，它有5种可能的取值。

1. lxx：指示信息。表示请求已接收，继续处理；
2. 2xx：成功。表示请求已被成功接收、理解、接受：
3. 3xx：重定向。要完成谓求必须进行更进一步的操作；
4. 4xx：客户端错误。请求有语法错误或请求无法实现；
5. 5xx：服务器端错误。服务器未能处理请求。

##### 响应状态代码和描述信息

| 状态码 | 状态描述                                                                     |
|:-------|:-----------------------------------------------------------------------------|
| 200    | OK：客户端诮求成功                                                           |
| 400    | Bad Request：客户端请求有语法错误，不能被服务器所理解                        |
| 401    | Unauthorized：诮求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 |
| 403    | Forbidden：服务器收到谐求，但是拒绝提供服务                                  |
| 404    | Not Found：请求资源不存在                                                    |
| 500    | Internal Server Error：服务器发生不可预期的错误                              |
| 503    | Server Uaavailable：服务器当前不能处理客户站的诸求，一段时间后可能恢复正常   |

响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。

常用的响应报头：

| 名称(KEY)        | 作用                                                                                                                                         |
|:-----------------|:---------------------------------------------------------------------------------------------------------------------------------------------|
| Location         | 用于重定向接收者到一个新的位置，Location响应报头域常用于更换域名的时候                                                                       |
| Server           | 包含了服务器用来处理i音求的软件信息，与User-Agent音求报头域是相对应的                                                                        |
| WWW-Authenticate | 必须被包含在401(未授权的）响应消息中．客户端收到401响应消息，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域 |

#### Netty HTTP服务器入门开发

由于Netty天生是异步事件驱动的架构，因此基于NIO TCP协议栈开发的HTTP协议栈也是异步非阻塞的。

Netty的HTTP协议栈无论在性能还是可靠性上，都表现优异，非常适合在非Web容器的场景下应用，
相比于传统的Tomcat、Jetty等Web容器，它更加轻址和小巧，灵活性和定制性也更好。

代码：

[HttpFileServer.java](https://github.com/songxianpeng/nettybook2/blob/master/src/com/phei/netty/protocol/http/fileServer/HttpFileServer.java)

[HttpFileServerHandler.java](https://github.com/songxianpeng/nettybook2/blob/master/src/com/phei/netty/protocol/http/fileServer/HttpFileServerHandler.java)

#### Netty HTTP+XML协议栈开发

由于HTTP协议的通用性，很多异构系统间的通信交互采用HTTP协议，通过HTTP协议承载业务数据进行消息交互，例如非常流行的HTTP+XML或者RESTful+JSON。

1. 需要一套通用、高性能的XML序列化框架，它能够灵活地实现POJO-XML的互相转换，最好能够通过工具自动生成绑定关系，或者通过XML的方式配置双方的映射关系；
2. 作为通用的HTTP+XML协议栈，XML-POJO对象的映射关系应该非常灵活，支待命名空间和自定义标签；
3. 提供HTTP+XML请求消息编码器，供HTTP客户端发送请求消息自动编码使用；
4. 提供HTTP+XML请求消息解码器，供HTTP服务端对请求消息自动解码使用；
5. 提供HTTP+XML响应消息编码器，供HTTP服务端发送响应消息自动编码使用；
6. 提供HTTP+XML响应消息解码器，供HTTP客户端对应答消息进行自动解码使用；
7. 协议栈使用者不需要关心HTTP+XML的编解码，对上层业务零侵入，业务只需要对上层的业务POJO对象进行编排。

##### 高效的XML绑定框架JiBx

[JiBx](http://jibx.sourceforge.net/)是一款非常优秀的XML(Extensible Markup Language)数据绑定框架。
它提供灵活的绑定映射文件，实现数据对象与XML文件之间的转换，并不需要修改既有的Java类。另外，它的转换效率是目前很多其他开源项目都无法比拟的。

* 转换效率高
* 配置绑定文件单
* 不需要操作xpath文件
* 不需要写属性的get/set方法
* 对象属性名与XML文件element名可以不同，等等。

在运行程序之前，盆要先配胃绑定文件并进行绑定，在绑定过程中它将会动态地修改程序中相应的class文件，
主要是生成对应对象实例的方法和添加被绑定标记的属性JiBX_bindingList等。
它使用的技术是BCEL(Byte Code Engineering Library)，BCEL是Apache Software Foundation的Jakarta项目的一部分，
也是目前Javaclassworking最广泛使用的一种框架，它可以让你深入JVM汇编语言进行类操作。

在JiBX运行时，它使用了目前比较流行的一个技术XPP(Xml Pull Parsing)，这也正是JiBX如此高效的原因。

JiBx有两个比较重要的概念：Unmarshal(数据分解）和Marshal(数据编排）。
从字面意思也很容易理解，Unmarshal是将XML文件转换成Java对象，而Marshal则是将Java对象编排成规范的XML文件。

JiBX在Unmarshal/Marshal上如此高效，这要归功于使用了XPP技术，而不是使用基于树型Ctree-based)方式，将整个文档写入内存，然后进行操作的DOM(Document Object Model)，
也不是使用基于事件流(event stream)的SAX(Simple API for Xml)。
XPP使用的是不断增加的数据流处理方式，同时允许在解析XML文件时中断。

通过JiBx提供的工具jar包，可以根据Schema自动生成POJO对象，也可以根据普通的POJO对象生成JiBx绑定文件和Schema定义XSD。

```xml
<!-- set classpath for compiling and running application with JiBX -->
<path id="classpath">
	<fileset dir="${jibx-home}/lib" includes="*.jar"/>
	<pathelement location="bin"/>
</path>
...
<!-- generate default binding and schema -->
<target name="bindgen">
	<echo message="Running BindGen tool"/>
	<java classpathref="classpath" fork="true" failonerror="true" classname="org.jibx.binding.generator.BindGen">
		<arg value="-s"/>
		<arg value="${baseDir}/src/main/com/songxp/pojo"/>
		<arg value="com.songxp.pojo.Order"/>
	</java>
</target>
```

```xml
<!-- 根据绑定文件和POJO对象的映射关系和规则动态修改POJO类 -->
<!-- Run JiBX binding compiler -->
<bind verbose="true" load="true" binding="binding.xml">
<classpath>
    <pathelement path="classes"/>
    <pathelement location="${jibx-lib}/jibx-run.jar"/>
</classpath>
</bind> 
```

```java
private IBindingFactory factory = null;
private StringWriter writer = null;
private StringReader reader = null;
private final static String CHARSET_NAME = "UTF-8";
private String encode2Xml(Order order) throws JiBXException, IOException {
    factory = BindingDirectory.getFactory(Order.class);
    writer = new StringWriter();
    IMarshallingContext marshallingContext = factory.createMarshallingContext();
    marshallingContext.setIndent(2);
    marshallingContext.marshalDocument(order, CHARSET_NAME, null, writer);
    String xmlStr = writer.toString();
    writer.close();
    System.out.println(xmlStr);
    return xmlStr;
}
private Order decode2Order(String xmlBody) throws JiBXException {
    reader = new StringReader(xmlBody);
    IUnmarshallingContext unmarshallingContext = factory.createUnmarshallingContext();
    Order order = (Order) unmarshallingContext.unmarshalDocument(reader);
    return order;
}
```

HTTP+XML协议代码：

[http](https://github.com/songxianpeng/nettybook2/tree/master/src/com/phei/netty/protocol/http/xml)

客户端：

在ChannelPipeline中新增了HttpResponseDecoder,它负责将二进制码流解码成为HTTP的应答消息；
随后新增了HttpObjectAggregator,它负责将1个HTTP请求消息的多个部分合并成一条完整的HTTP消息；
将开发的XML解码器HttpXmlResponseDecoder添加到ChannelPipelioe中，这样就实现了HTTP+XML应答消息的自动解码。

将HttpRequestEncoder编码器添加到ChannelPipeline中时，需要注意顺序，
编码的时候是按照从尾到头的顺序调度执行的，它后面放的是自定义开发的HTTP+XML请求消息编码器HttpXmIRequestEncoder。

最后是业务的逻辑编排类HttpXmlCiientHandle。

服务端：

```java
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .childHandler(
                new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch)
                            throws Exception {
                        ch.pipeline().addLast("http-decoder", new HttpRequestDecoder());
                        ch.pipeline().addLast("http-aggregator", new HttpObjectAggregator(65536));
                        ch.pipeline().addLast("xml-decoder", new HttpXmlRequestDecoder(Order.class, true));
                        ch.pipeline().addLast("http-encoder", new HttpResponseEncoder());
                        ch.pipeline().addLast("xml-encoder", new HttpXmlResponseEncoder());
                        ch.pipeline().addLast("xmlServerHandler", new HttpXmlServerHandler());
                    }
                });
ChannelFuture future = serverBootstrap.bind(new InetSocketAddress(port)).sync();
```

* 绑定HTTP请求消息解码器；
* 将我们自定义的HttpXmlRequestDecoder添加到HTTP解码器；
* 添加自定义的HttpXmlResponseEncoder编码器用于响应消息的编码。

本例开发的HTTP+XML协议栈是个高性能、通用的协议栈，但是，忽略了一些异常场景的处理、可扩展性的API和一些配置能力。
所以，如果在商用项目中使用HTTP+XML协议栈，仍需要做一些产品化的完善工作。

#### Http协议的弊端

长期以来存在着各种技术让服务器得知有新数据可用时，立即将数据发送到客户端。这些技术种类繁多，例如“推送”或Comet。
最常用的一种黑客手段是对服务器发起连接创建假象，被称为长轮询。利用长轮询，客户端可以打开指向服务器的HTTP连接，而服务器会一直保持连接打开，直到发送响应。
服务器只要实际拥有新数据，就会发送响应（其他技术包括Flash、XHR multipart请求和所谓的HTML Files)。
长轮询和其他技术都非常好用，在Gmail聊天等应用中会经常使用它们。  
但是，这些解决方案都存在一个共同的问题：由于HTTP协议的开销，导致它们不适用于低延迟应用。

为了解决这些问题，WebSocket将网络套接字引入到了客户端和服务端，浏览器和服务器之间可以通过套接宇建立持久的连接，
双方随时都可以互发数据给对方，而不是之前由客户端控制的一请求一应答模式。

将HTTP协议的主要弊端总结如下。

1. HTTP协议为半双工协议。半双工协议指数据可以在客户端和服务端两个方向上传输，但是不能同时传输。它意味着在同一时刻，只有一个方向上的数据传送；
2. HTTP消息冗长而繁琐。HTTP消息包含消息头、消息体、换行符等，通常情况下采用文本方式传输，相比于其他的二进制通信协议，冗长而繁琐；
3. 针对服务器推送的黑客攻击。例如长时间轮询。
在分布式组网环境下，每个Netty节点(Netty进程）之间建立长连接，使用Netty协议进行通信。Netty节点并没有服务端和客户端的区分，谁首先发起连接，谁就作为客户端，另一方自然就成为服务端。


现在，很多网站为了实现消息推送，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTPrequest，然后由服务器返回最新的数据给客户端浏览器。
这种传统的模式具有很明显的缺点，即浏览器需要不断地向服务器发出请求，然而HTTP request的Header是非常冗长的，里面包含的可用数据比例可能非常低，这会占用很多的带宽和服务器资源。

比较新的一种轮询技术是Comet，使用了AJAX。这种技术虽然可达到双向通信，但依然需要发出请求，而且在Comet中，普遍采用了长连接，这也会大世消耗服务器带宽和资源。

为了解决HTTP协议效率低下的问题，HTML5定义了WebSocket协议，能更好地节省服务器资源和带宽并达到实时通信。

#### WebSocket入门

在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道，两者就可以直接互相传送数据了。
WebSocket基于TCP双向全双工进行消息传递，在同一时刻，既可以发送消息，也可以接收消息，相比HTTP的半双工协议，性能得到很大提升。

WebSocket的特点：

* 单一的TCP 连接，采用全双工模式通信；
* 对代理、防火墙和路由器透明；
* 无头部信息、Cookie 和身份验证；
* 无安全开销；
* 通过"ping/pong" 帧保持链路激活；
* 服务器可以主动传递消息给客户端，不再需要客户端轮询。

##### WebSocket连接建立

为了建立一个WebSocket连接，客户端浏览器首先要向服务器发起一个HTTP请求，这个诸求和通常的HTTP请求不同，包含了一些附加头信息，
其中附加头信息"Upgrade: WebSocket"表明这是一个申请协议升级的HTTP请求。

![WebSocket客户端握手请求消息](/static/img/2017-01-15-IO流/2018-07-23-10-45-41.png)

服务器端解析这些附加的头信息，然后生成应答信息返回给客户端，客户端和服务器端的WebSocket连接就建立起来了，双方可以通过这个连接通道自由地传递信息，
并且这个连接会持续存在直到客户端或者服务器端的某一方主动关闭连接。

![WebSocket服务端返回的握手应答消息](/static/img/2017-01-15-IO流/2018-07-23-10-47-57.png)

##### WebSocket的生命周期

握手成功之后，服务端和客户端就可以通过"messages"的方式进行通信了，一个消息由一个或者多个帧组成，WebSocket的消息井不一定对应一个特定网络层的帧，它可以被分割成多个帧或者被合井。

帧都有自己对应的类型，属千同一个消息的多个帧具有相同类型的数据。从广义上讲，数据类型可以是文本数据(UTF-8[RFC3629]文字）、二进制数据和控制帧（协议级信令，如信号）。

![WebSocket生命周期](/static/img/2017-01-15-IO流/2018-07-23-10-50-41.png)

##### 连接关闭

为关闭WebSocket连接，客户端和服务端需要通过一个安全的方法关闭底层TCP连接以及TLS会话。如果合适，丢弃任何可能已经接收的字节，必要时（比如受到攻击）可以通过任何可用的手段关闭连接。

底层的TCP连接，在正常情况下，应该首先由服务器关闭。在异常情况下（例如在一个合理的时间周期后没有接收到服务器的TCP Close),客户端可以发起TCP Close。
因此，当服务器被指示关闭WebSocket连接时，它应该立即发起一个TCP Close操作；客户端应该等待服务器的TCP Close。

WebSocket的握手关闭消息带有一个状态码和一个可选的关闭原因，它必须按照协议要求发送一个Close控制帧，当对端接收到关闭控制帧指令时，需要主动关闭WebSocket连接。

#### Netty WebSocket协议开发

```java
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            protected void initChannel(SocketChannel ch)throws Exception {
                ChannelPipeline pipeline = ch.pipeline();
                pipeline.addLast("http-codec", new HttpServerCodec());
                pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
                pipeline.addLast("http-chunked", new ChunkedWriteHandler());
                pipeline.addLast("handler", new WebSocketServerHandler());
            }
        });

Channel ch = serverBootstrap.bind(port).sync().channel();
```

* 首先添加HttpServerCodec,将请求和应答消息编码或者解码为HTTP消息；
* 增加HttpObjectAggregator,它的目的是将HTTP消息的多个部分组合成一条完整的HTTP消息；
* 添加ChunkedWriteHandler,来向客户端发送HTML5文件，它主要用于支待浏览器和服务端进行WebSocket通信；
* 最后增加WebSocket服务端Handler。

```java
import static io.netty.handler.codec.http.HttpHeaders.isKeepAlive;
import static io.netty.handler.codec.http.HttpHeaders.setContentLength;
import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
import io.netty.util.CharsetUtil;
import java.util.logging.Level;
import java.util.logging.Logger;
public class WebSocketServerHandler extends SimpleChannelInboundHandler<Object> {
    private static final Logger logger = Logger.getLogger(WebSocketServerHandler.class.getName());
    private WebSocketServerHandshaker handshaker;
    @Override
    public void messageReceived(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        // 传统的HTTP接入
        if (msg instanceof FullHttpRequest) {
            handleHttpRequest(ctx, (FullHttpRequest) msg);
        }
        // WebSocket接入
        else if (msg instanceof WebSocketFrame) {
            handleWebSocketFrame(ctx, (WebSocketFrame) msg);
        }
    }
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
        // 如果HTTP解码失败，返回HHTP异常
        if (!req.getDecoderResult().isSuccess() || (!"websocket".equals(req.headers().get("Upgrade")))) {
            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
            return;
        }

        // 构造握手响应返回，本机测试
        WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory("ws://localhost:8080/websocket", null, false);
        handshaker = wsFactory.newHandshaker(req);
        if (handshaker == null) {
            WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());
        } else {
            handshaker.handshake(ctx.channel(), req);
        }
    }
    private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
        // 判断是否是关闭链路的指令
        if (frame instanceof CloseWebSocketFrame) {
            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
            return;
        }
        // 判断是否是Ping消息
        if (frame instanceof PingWebSocketFrame) {
            ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));
            return;
        }
        // 本例程仅支持文本消息，不支持二进制消息
        if (!(frame instanceof TextWebSocketFrame)) {
            throw new UnsupportedOperationException(String.format("%s frame types not supported", frame.getClass().getName()));
        }
        // 返回应答消息
        String request = ((TextWebSocketFrame) frame).text();
        if (logger.isLoggable(Level.FINE)) {
            logger.fine(String.format("%s received %s", ctx.channel(), request));
        }
        ctx.channel().write(new TextWebSocketFrame(request + " , 欢迎使用Netty WebSocket服务，现在时刻：" + new java.util.Date().toString()));
    }
    private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
        // 返回应答给客户端
        if (res.getStatus().code() != 200) {
            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8);
            res.content().writeBytes(buf);
            buf.release();
            setContentLength(res, res.content().readableBytes());
        }
        // 如果是非Keep-Alive，关闭连接
        ChannelFuture f = ctx.channel().writeAndFlush(res);
        if (!isKeepAlive(req) || res.getStatus().code() != 200) {
            f.addListener(ChannelFutureListener.CLOSE);
        }
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
```

第一次握手诸求消息由HTTP协议承载，所以它是一个HTTP消息，执行handleHttpRequest方法来处理WebSocket握手请求。
首先对握手请求消息进行判断，如果消息头中没有包含Upgrade字段或者它的值不是websocket，则返回HTTP400响应。

握手请求简单校验通过之后，开始构造握手工厂，创建握手处理类WebSocketServerHandshaker，通过它构造握手响应消息返回给客户端，
同时将WebSocket相关的编码和解码类动态添加到Channel和peline中，用于WebSocket消息的编解码。

```java
// 源码
if (ctx == null) {
    // this means the user use a HttpServerCodec
    ctx = p.context(HttpServerCodec.class);
    if (ctx == null) {
        promise.setFailure(
                new IllegalStateException("No HttpDecoder and no HttpServerCodec in the pipeline"));
        return promise;
    }
    p.addBefore(ctx.name(), "wsdecoder", newWebsocketDecoder());
    p.addBefore(ctx.name(), "wsencoder", newWebSocketEncoder());
    encoderName = ctx.name();
} else {
    p.replace(ctx.name(), "wsdecoder", newWebsocketDecoder());
    encoderName = p.context(HttpResponseEncoder.class).name();
    p.addBefore(encoderName, "wsencoder", newWebSocketEncoder());
}
```

```html
<!-- client -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    Netty WebSocket 时间服务器
</head>
<br>
<body>
<br>
<script type="text/javascript">
    var socket;
    if (!window.WebSocket) {
        window.WebSocket = window.MozWebSocket;
    }
    if (window.WebSocket) {
        socket = new WebSocket("ws://localhost:8080/websocket");
        socket.onmessage = function (event) {
            var ta = document.getElementById('responseText');
            ta.value = "";
            ta.value = event.data
        };
        socket.onopen = function (event) {
            var ta = document.getElementById('responseText');
            ta.value = "打开WebSocket服务正常，浏览器支持WebSocket!";
        };
        socket.onclose = function (event) {
            var ta = document.getElementById('responseText');
            ta.value = "";
            ta.value = "WebSocket 关闭!";
        };
    }
    else {
        alert("抱歉，您的浏览器不支持WebSocket协议!");
    }

    function send(message) {
        if (!window.WebSocket) {
            return;
        }
        if (socket.readyState == WebSocket.OPEN) {
            socket.send(message);
        } else {
            alert("WebSocket连接没有建立成功!");
        }
    }
</script>
<form onsubmit="return false;">
    <input type="text" name="message" value="Netty最佳实践"/>
    <br><br>
    <input type="button" value="发送WebSocket请求消息" onclick="send(this.form.message.value)"/>
    <hr color="blue"/>
    <h3>服务端返回的应答消息</h3>
    <textarea id="responseText" style="width:500px;height:300px;"></textarea>
</form>
</body>
</html>
```

#### 私有协议开发

绝大多数的私有协议传输层都基于TCP/IP，所以利用Netty的NIO TCP协议栈可以非常方便地进行私有协议的定制和开发。

在传统的Java应用中，通常使用以下4种方式进行跨节点通信：

1. 通过RMI进行远程服务调用；
2. 通过Java的Socket+Java序列化的方式进行跨节点调用；
3. 利用一些开源的RPC框架进行远程服务调用，例如Facebook的Thrift、Apache的Avro等；
4. 利用标准的公有协议进行跨节点服务调用，例如HTTP+XML、RESTful+JSON或者WebService。

跨节点的远程服务调用，除了链路层的物理连接外，还需要对请求和响应消息进行编解码。
在请求和应答消息本身以外，也需要携带一些其他控制和管理类指令，例如链路建立的握手请求和响应消息、链路检测的心跳消息等。
当这些功能组合到一起之后，就会形成私有协议。

#### Netty协议栈

Netty协议栈用于内部各模块之间的通信，它基于TCP/IP协议栈，是一个类HTTP协议的应用层协议栈，相比于传统的标准协议栈，它更加轻巧、灵活和实用。

##### 网络拓扑

在分布式组网环境下，每个Netty节点(Netty进程）之间建立长连接，使用Netty协议进行通信。Netty节点并没有服务端和客户端的区分，谁首先发起连接，谁就作为客户端，另一方自然就成为服务端。

![Netty协议网络拓扑示意图](/static/img/2017-01-15-IO流/2018-07-23-11-30-50.png)

##### 功能描述

Netty协议栈承载了业务内部各模块之间的消息交互和服务调用，它的主要功能如下：

1. 基于Netty的NIO通信框架，提供高性能的异步通信能力；
2. 提供消息的编解码框架，可以实现POJO的序列化和反序列化；
3. 提供基于IP地址的白名单接入认证机制；
4. 链路的有效性校验机制；
5. 链路的断连重连机制。

##### 通信模型

Netty协议栈通信交互图：

![Netty协议栈通信交互图](/static/img/2017-01-15-IO流/2018-07-23-11-32-47.png)

具体步骤：

1. Netty协议栈客户端发送握手请求消息，携带节点ID等有效身份认证信息；
2. Netty协议栈服务端对握手请求消息进行合法性校验，包括节点ID有效性校验、节点重复登录校验和IP地址合法性校验，校验通过后，返回登录成功的握手应答消息；
3. 链路建立成功之后，客户端发送业务消息；
4. 链路成功之后，服务端发送心跳消息；
5. 链路建立成功之后，客户端发送心跳消息；
6. 链路建立成功之后，服务端发送业务消息；
7. 服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。

Netty协议通信双方链路建立成功之后，双方可以进行全双工通信，无论客户端还是服务端，都可以主动发送请求消息给对方，通信方式可以是TWO WAY或者ONE WAY。
双方之间的心跳采用Ping-Pong机制，当链路处于空闲状态时，客户端主动发送Ping消息给服务端，服务端接收到Ping消息后发送应答消息Pong给客户端，
如果客户端连续发送N条Ping消息都没有接收到服务端返回的Pong消息，说明链路已经挂死或者对方处于异常状态，客户瑞主动关闭连接，间隔周期T后发起重连操作，直到重连成功。

##### 消息定义

* 消息头；
* 消息体。

| 名称   | 类型   | 长度 | 描述                                                                                   |
|:-------|:-------|:-----|:---------------------------------------------------------------------------------------|
| header | Header | 变长 | 消息头定义                                                                             |
| body   | Object | 变长 | 对于请求消息，它是方法的参数（作为示例，只支持携带一个参数）；对于响应消息，它是返问值 |

Netty协议消息头定义：

| 字段       | 类型               | 长度 | 描述                                                                                                                                |
|:-----------|:-------------------|:-----|:------------------------------------------------------------------------------------------------------------------------------------|
| crcCode    | Int                | 32   | Netty消息校验码，1. 0xAEF：固定值，表明该消息是Netty协议信息，2个字节；2. 主版本号： 1~255，1个字节；3. 次版本号： 1~255，1个字节； |
| Length     | Int                | 32   | 整个消息长度                                                                                                                        |
| sessionID  | Long               | 64   | 会话ID                                                                                                                              |
| Type       | Byte               | 8    | 0:业务请求消息；1：业务响应消息；2：业务one way消息；3握手请求消息；4握手应答消息；5：心跳请求消息；6：心跳应答消息                 |
| Priority   | Byte               | 8    | 消息优先级：0~255                                                                                                                   |
| Attachment | Map<String,Object> | 变长 | 可选字段，由于推展消息头                                                                                                            |

Netty协议支持的数据类型：

| 字段类型 | 备注说明                  |
|:---------|:--------------------------|
| boolean  | 包括它的包装类型Integer   |
| byte     | 包括它的包装类型Byte      |
| int      | 对应千C/C++的int32        |
| char     | 包括它的包装类型Character |
| shot     | 对应C/C++的in1l6          |
| long     | 对应C/C++的int64          |
| flat     | 包括它的包装类型Float     |
| double   | 包括它的包装类型Double    |
| string   | 对应C/C++的String         |
| list     | 支持各种List的实现        |
| array    | 支持各种数组的实现        |
| map      | 支持Map的嵌套和泛型       |
| set      | 支持Set的嵌套和泛型       |

##### Netty协议的编解码

编码：

* crcCode：java.nio.ByteBuffer.putInt(int value)，如果采用其他缓冲区实现，必须与其等价；
* length：java.nio.ByteBuffer.putInt(int value)，如果采用其他缓冲区实现，必须与其等价；
* sessionID：java.nio.ByteBuffer.putLong(int value)，如果采用其他缓冲区实现，必须与其等价；
* type：java.nio.ByteBuffer.put(byte value)，如果采用其他缓冲区实现，必须与其等价；
* priority：java.nio.ByteBuffer.put(byte value)，如果采用其他缓冲区实现，必须与其等价；
* attachMent：
    * 如果attachment长度为0，表示没有可选附件，则将长度编码设为0，java.nio.ByteBuffer.putInt(0);
    * 如果大于0，说明有附件需要编码，首先对附件的个数进行编码，java.nio.ByteBuffer.putInt(attachment.size());然后对Key进行编码，先编码长度，再将它转换成byte数组之后编码内容。
* Body的编码：通过JBoss Marshalling将其序列化为byte数组，然后调用java.nio.ByteBuffer.put(byte[] src)将其写入ByteBuffer缓冲区中。

```java
String key = null;
byte[] value = null;
for (Map.Entry<String, Object> param : attachment.entrySet()) {
    key = param.getKey ();
    buffer.writeString (key) ;
    value = marshaller.writeObject(param.getValue());
    buffer.writeBinary(value) ;
}
key = null;
value = null ;
```

由于整个消息的长度必须等全部字段都编码完成之后才能确认，所以最后需要更新消息头中的length字段，将其重新写入ByteBuffer中。

解码：

相对于Netty的编码，仍旧以java.nio.ByteBuffer为例，给出Netty协议的解码规范。

* crcCode：通过java.nio.ByteBuffer.getInt()获取校验码字段，其他缓冲区需要与其等价；
* length：通过java.nio.ByteBuffer.getInt()获取校验码字段，其他缓冲区需要与其等价；
* sessionID：通过java.nio.ByteBuffer.getLong()获取校验码字段，其他缓冲区需要与其等价；
* type：通过java.nio.byteBuffer.get()获取消息类型，其他缓冲区需要与其等价；
* priority：通过java.nio.byteBuffer.get()获取消息优先级，其他缓冲区需要与其等价；
* attachment：它的剑麻规则为--首先创建一个新的attachment对象，调用java.nio.ByteBuffer.getInt()获取附件的长度，如果为0,说明附件为空，解码结束，继续解码消息头；如果非空，则根据长度通过for循环进行解码。
* Body：通过Jboss的marshaller对其进行解码。

```java
String key = null;
Object value = null;
for (int i = 0 ; i < size ; i++) {
    key = buffer.readString();
}
value = unmarshaller.readObject(buffer.readBinary());
this. attachment.put(key,value) ;
key = null;
value = null;
```

##### 链路的建立

如果A节点需要调用B节点的服务，但是A和B之间还没有建立物理链路，则有调用方主动发起连接，此时，调用方为客户端，被调用方为服务端。

客户端与服务端链路建立成功之后，由客户端发送握手请求消息，服务端接收到客户端的握手请求消息之后，如果校验通过，返回握手成功应答消息给客户端，应用层链路建立成功。
链路建立成功之后，客户端和服务端就可以互相发送业务消息了。

##### 链路的关闭

由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。

但是，在以下情况下，客户端和服务端需要关闭连接：

* 当对方宕机或者重启时，会主动关闭链路，另一方读取到操作系统的通知信号，得知对方REST链路，需要关闭连接，释放自身的句柄等资源。由于采用TCP全双工通信，通信双方都需要关闭连接，释放资源；
* 消息读写过程中，发生了I/O异常，需要主动关闭连接；
* 心跳消息读写过程发生了I/O异常，需要主动关闭连接；
* 心跳超时，需要主动关闭连接；
* 发生编码异常等不可恢复错误时，需要主动关闭连接。

##### 可靠性设计

###### 心跳机制

在凌晨等业务低谷时段，如果发生网络闪断、连接被Hang住等问题时，由于没有业务消息，应用程序很难发现。到了白天业务高峰期时，会发生大量的网络通信失败，严重的会导致一段时间进程内无法处理业务消息。
为了解决这个问题，在网络空闲时采用心跳机制来检测链路的互通性，一旦发现网络故障，立即关闭链路，主动重连。

具体的设计思路如下：

1. 当网络处于空闲状态持续时间达到T（连续周期T没有读写消息）时，客户端主动发送Ping心跳消息给服务端；
2. 如果在下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者读取到服务端发送的其他业务消息，则心跳失败计数器加1；
3. 每当客户端接收到服务的业务消息或者Pong应答消息，将心跳失败计数器清零；当练习N次没有接收到服务端的Pong消息或者业务消息，则关闭链路，间隔INTERVAL时间后发起重连操作；
4. 服务端网络空闲状态持续时间达到T后，服务端将心跳失败计数器加1；只要接收到客户端发送的Ping消息或者其他业务消息，计数器清零；
5. 服务端连续N次没有接收到客户端的ping消息或者其他业务消息，则关闭链路，释放资源，等到客户端重连。

通过Ping-Pong双向心跳机制，可以保证无论通信哪一方出现网络故障，都能被及时的检查出来，为了防止由于对方短时间内繁忙没有及时返回应答造成的误判，只有连续N次心跳检查都失败才认定链路已经损害，需要关闭链路并重建链路。

当读或者写心跳消息发生I/O异常的时候，说明已经中断，此时需要立即关闭连接，如果是客户端，需要重新发起连接。如果是服务端，需要清空缓存的半包信息，等到客户端重连。

###### 重连机制

如果链路中断，等到INTEVAL时间后，由客户端发起重连操作，如果重连失败，间隔周期INTERVAL后再次发起重连，直到重连成功。

为了保持服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待INTERVAL时间之后再发起重连，而不是失败后立即重连。

为了保证句柄资源能够及时释放，无论什么场景下重连失败，客户端必须保证自身的资源被及时释放，包括但不现居SocketChannel、Socket等。

重连失败后，需要打印异常堆栈信息，方便后续的问题定位。

###### 重复登录保护

当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复登录，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。

服务端接收到客户端的握手请求消息之后，首先对IP地址进行合法性校验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，如果登录，则拒绝重复登录，返回错误码-1，同时关闭TCP链路，并在服务端的日志中打印握手失败的原因。

客户端接收到握手失败的应答消息之后，关闭客户端的TCP连接，等待INTERVAL时间之后，再次发起TCP连接，知道认证成功。

为了防止由服务端和客户端对链路状态理解不一致导致的客户端无法握手成功问题，当服务端连续N次心跳超时之后需要主动关闭链路，清空改客户端的地址缓存信息，以保证后续改客户端可以重连成功，防止被重复登录保护机制拒绝掉。

###### 消息缓存重发

无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存的消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。

考虑到内存溢出的风险，建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续想该队列添加新的消息。

##### 安全性设计

如果在公网中，需要更复杂的认证机制，如密钥和ASE加密的用户名+密码的认证机制，也可以采用SSL/TSL安全传输。

##### 可扩展性设计

业务可以在消息头中自定义业务域字段。通过attachment字段，可以方便的扩展。

Netty协议栈架构需要具备一定的扩展能力，例如统一的消息拦截、接口日志、安全、加解密等可以被方便地添加和删除，不需要修改之前的逻辑代码，
类似Servlet的Filter Chain和AOP,但考虑到性能因素，不推荐通过AOP来实现功能的扩展。

#### Netty协议栈开发

[源代码](https://github.com/songxianpeng/nettybook2/tree/master/src/com/phei/netty/protocol/netty)

```java
public class NettyMessageDecoder extends LengthFieldBasedFrameDecoder {
    MarshallingDecoder marshallingDecoder;
    public NettyMessageDecoder(int maxFrameLength, int lengthFieldOffset,int lengthFieldLength) throws IOException {
        super(maxFrameLength, lengthFieldOffset, lengthFieldLength);
        marshallingDecoder = new MarshallingDecoder();
    }
    @Override
    protected Object decode(ChannelHandlerContext ctx, ByteBuf in)throws Exception {
        // LengthFieldBasedFrameDecoder支持半包处理和粘包处理
        // 只要给出标识消息长度的字段偏移量和消息长度自身所占的字节数，Netty就能够自动实现对半包的处理。
        ByteBuf frame = (ByteBuf) super.decode(ctx, in);
        // 如果是null说名是半包直接返回继续由I/O线程读取后续的码流。
        if (frame == null) {
            return null;
        }
        NettyMessage message = new NettyMessage();
        Header header = new Header();
        header.setCrcCode(frame.readInt());
        header.setLength(frame.readInt());
        header.setSessionID(frame.readLong());
        header.setType(frame.readByte());
        header.setPriority(frame.readByte());

        int size = frame.readInt();
        if (size > 0) {
            Map<String, Object> attch = new HashMap<String, Object>(size);
            int keySize = 0;
            byte[] keyArray = null;
            String key = null;
            for (int i = 0; i < size; i++) {
                keySize = frame.readInt();
                keyArray = new byte[keySize];
                frame.readBytes(keyArray);
                key = new String(keyArray, "UTF-8");
                attch.put(key, marshallingDecoder.decode(frame));
            }
            keyArray = null;
            key = null;
            header.setAttachment(attch);
        }
        if (frame.readableBytes() > 4) {
            message.setBody(marshallingDecoder.decode(frame));
        }
        message.setHeader(header);
        return message;
    }
}
```

```java
public class NettyClient {
    private static final Log LOGGER = LogFactory.getLog(NettyClient.class);
    private ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
    EventLoopGroup group = new NioEventLoopGroup();
    public void connect(int port, String host) throws Exception {
        // 配置客户端NIO线程组
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(group).channel(NioSocketChannel.class)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        public void initChannel(SocketChannel ch)
                                throws Exception {
                            // 防止由于单条消息过大导致内存溢出或者畸形码流导致解码错位引起内存分配失败
                            ch.pipeline().addLast(new NettyMessageDecoder(1024 * 1024, 4, 4));
                            ch.pipeline().addLast("MessageEncoder", new NettyMessageEncoder());
                            ch.pipeline().addLast("readTimeoutHandler", new ReadTimeoutHandler(50));
                            ch.pipeline().addLast("LoginAuthHandler", new LoginAuthReqHandler());
                            ch.pipeline().addLast("HeartBeatHandler", new HeartBeatReqHandler());
                        }
                    });
            // 发起异步连接操作
            ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port), new InetSocketAddress(NettyConstant.LOCALIP, NettyConstant.LOCAL_PORT)).sync();
            // 当对应的channel关闭的时候，就会返回对应的channel。
            // Returns the ChannelFuture which will be notified when this channel is closed. This method always returns the same future instance.
            future.channel().closeFuture().sync();
        } finally {
            // 所有资源释放完成之后，清空资源，再次发起重连操作
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        TimeUnit.SECONDS.sleep(1);
                        try {
                            // 发起重连操作
                            connect(NettyConstant.PORT, NettyConstant.REMOTEIP);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
    public static void main(String[] args) throws Exception {
        new NettyClient().connect(NettyConstant.PORT, NettyConstant.REMOTEIP);
    }
}
```

利用Netty的ChannefPipeline和ChannelHandler机制，可以非常方便地实现功能解耦和业务产品的定制。
例如心跳定时器、握手请求和后端的业务处理可以通过不同的Handler来实现，类似于AOP。
通过HandlerChain的机制可以方便地实现切面拦截和定制，相比于AOP它的性能更高。

```java
public class NettyServer {
    private static final Log LOG = LogFactory.getLog(NettyServer.class);
    public void bind() throws Exception {
        // 配置服务端的NIO线程组
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        ServerBootstrap serverBootstrap = new ServerBootstrap();
        serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
                .option(ChannelOption.SO_BACKLOG, 100)
                .handler(new LoggingHandler(LogLevel.INFO))
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch)
                            throws IOException {
                        ch.pipeline().addLast(new NettyMessageDecoder(1024 * 1024, 4, 4));
                        ch.pipeline().addLast(new NettyMessageEncoder());
                        // 实现超时主动关闭链路，这会触发handler的exceptionCaught方法释放资源
                        ch.pipeline().addLast("readTimeoutHandler", new ReadTimeoutHandler(50));
                        ch.pipeline().addLast(new LoginAuthRespHandler());
                        ch.pipeline().addLast("HeartBeatHandler", new HeartBeatRespHandler());
                    }
                });

        // 绑定端口，同步等待成功
        serverBootstrap.bind(NettyConstant.REMOTEIP, NettyConstant.PORT).sync();
        LOG.info("Netty server start ok : " + (NettyConstant.REMOTEIP + " : " + NettyConstant.PORT));
    }
    public static void main(String[] args) throws Exception {
        new NettyServer().bind();
    }
}
```

对于实际商用协议栈而言，是不足的。例如当链路断连的时候，已经放入发送队列中的消息不能丢失，
更加通用的做法是提供通知机制，将发送失败的消息通知给业务侧，由业务做决定：是丢弃还是缓存重发。

### 服务器端创建

Netty服务端创建需要的必备知识如下：

1. 熟悉JDK NIO主要类库的使用，例如ByteBuffer、Selector、ServerSocketChannel等；
2. 熟悉JDK的多线程编程；
3. 了解Reactor模式。

#### Netty服务器端创建时序图

![Netty服务端创建时序图](/static/img/2017-01-15-IO流/2018-07-23-16-34-25.png)

```java
// 配置服务端的NIO线程组
EventLoopGroup bossGroup = new NioEventLoopGroup();
EventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, 100)
        .handler(new LoggingHandler(LogLevel.INFO))
        .childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            public void initChannel(SocketChannel ch)
                    throws IOException {
                ch.pipeline().addLast(new NettyMessageDecoder(1024 * 1024, 4, 4));
                ch.pipeline().addLast(new NettyMessageEncoder());
                ch.pipeline().addLast("readTimeoutHandler", new ReadTimeoutHandler(50));
                ch.pipeline().addLast(new LoginAuthRespHandler());
                ch.pipeline().addLast("HeartBeatHandler", new HeartBeatRespHandler());
            }
        });

// 绑定端口，同步等待成功
serverBootstrap.bind(NettyConstant.REMOTEIP, NettyConstant.PORT).sync();
```

* 步骤1：创建ServerBootstrap实例。
    * ServerBootstrap是Netty服务端的启动辅助类，它提供了一系列的方法用于设笠服务端启动相关的参数。
    * 底层通过门面模式对各种能力进行抽象和封装，尽量不福要用户跟过多的底层API打交道，以降低用户的开发难度。
    * 无参构造器加Builder模式
* 步骤2：设置并绑定Reactor线程池。
    * Netty的Reactor线程池是EventLoopGroup，它实际就足EventLoop的数组。EventLoop的职责是处理所有注册到本线程多路复用器Selector上的Channel，Selector的轮询操作由绑定的EventLoop线程run方法驱动，在一个循环体内循环执行。
    * EventLoop的职责不仅仅是处理网络1/0事件，用户自定义的Task和定时任务Task也统一由EventLoop负责处理，这样线程模型就实现了统一。
    * 从调度层面看，也不存在从EventLoop线程中再启动其他类型的线程用于异步执行另外的任务，这样就避免了多线程并发操作和锁竞争，提升了1/0线程的处理和调度性能。
* 步骤3：设置并绑定服务端Channel。
    * Netty对原生的NIO 类库进行了封装，对应实现是NioServerSocketChannel。
    * Netty通过工厂类，利用反射创建NioServerSocketChannel对象。
* 步骤4：链路建立的时候创建并初始化ChannelPipeline。
    * 是一个负责处理网络事件的职责链，负责管理和执行ChannelHandler。
    * 网络事件以事件流的形式在ChannelPipeline中流转，由ChannelPipeline根据ChannelHandler的执行策略调度ChannelHandler的执行。
    * 典型的网络事件
        * 链路注册；
        * 链路激活；
        * 链路断开；
        * 接收到请求消息；
        * 诮求消息接收并处理完毕；
        * 发送应答消息：
        * 链路发生异常；
        * 发生用户自定义事件。
* 步骤5：初始化ChannelPipeline完成之后，添加并设置ChannelHandler。
    * ChannelHandler是Netty提供给用户定制和扩展的关键接口。利用ChannelHandler用户可以完成大多数的功能定制，例如消息编解码、心跳、安全认证、TSL/SSL认证、流量控制和流撮整形等。
    * Netty同时也提供了大量的系统ChannelHandler供用户使用
        * 系统编解码框架：ByteToMessageCodec
        * 通用基于长度的半包解码器：LengthFieldBasedFrameDecoder
        * 码流日志打印Handler：LoggingHandler
        * SSL安全认证Handler：SslHandler
        * 链路空闲检测Handler：IdleStateHandler
        * 流量整形Handler：ChannelTrafficShapingHandler
        * Base64编解码：Base64Decoder和Base64Encoder
* 步骤6：绑定并启动监听端口。
    * 在绑定监听端口之前系统会做一系列的初始化和检测工作，完成之后，会启动监听端口，并将ServerSocketChannel注册到Selector上监听客户端连接。
* 步骤7：Selector轮询。
    * 由Reactor线程NioEventLoop负责调度和执行Selector轮询操作，选择准备就绪的Channel集合
* 步骤8：当轮询到准备就绪的Channel之后，就由Reactor线程NioEventLoop执行ChannelPipeline的相应方法，最终调度并执行ChannelHandler。
* 步骤9：执行Netty系统ChannelHandler和用户添加定制的ChannelHandler。ChannelPipeline根据网络事件的类型，调度并执行ChannelHandler

#### Netty服务器端创建源码分析

首先通过构造函数创建ServerBootstrap实例，随后，通常会创建两个EventLoopGroup（并不是必须要创建两个不同的EventLoopGroup，也可以只创建一个并共享）。

```java
EventLoopGroup bossGroup = new NioEventLoopGroup();
EventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap serverBootstrap = new ServerBootstrap();
```

NioEventLoopGroup实际就是Reactor线程池，负责调度和执行客户端的接入、网络读写事件的处理、用户自定义任务和定时任务的执行。

---

通过指定Channel类型的方式创建Channel工厂。

ServerBootstrapChannelFactory是ServerBootstrap的内部静态类，职责是根据Channel的类型通过反射创建Channel的实例，服务端需要创建的是NioServerSocketChannel实例。

```java
@Override
public T newChannel(EventLoop eventLoop, EventLoopGroup childGroup) {
    try {
        Constructor<? extends T> constructor = clazz.getConstructor(EventLoop.class, EventLoopGroup.class);
        return constructor.newInstance(eventLoop, childGroup);
    } catch (Throwable t) {
        throw new ChannelException("Unable to create Channel from class " + clazz, t);
    }
}
```

---

指定NioServerSocketChannel后，需要设置TCP的一些参数，作为服务端，主要是要设置TCP的 backlog参数，底层C的对应接口定义如下：

```c++
int listen(int fd, int backlog);
```

backlog指定了内核为此套接口排队的最大连接个数，对于给定的监听套接口，内核要维护两个队列，未链接队列和已连接队列，根据TCP三路握手过程中三个分节来分隔这两个队列。

服务器处于listen状态时收到客户端syn分节(connect)时在未完成队列中创建一个新的条目，然后用三路握手的第二个分节即服务器的syn响应及对客户端syn的ack，此条目在第三个分节到达前(客户端对服务器syn的ack)一直保留在未完成连接队列中，
如果三路握手完成，该条目将从未完成连接队列搬到已完成连接队列尾部。

当进程调用accept时，从已完成队列中的头部取出一个条目给进程，当已完成队列为空时进程将睡眠，直到有条目在已完成连接队列中才唤醒。

backlog被规定为两个队列总和的最大值，大多数实现默认值为5，但在高并发web服务器中此值显然不够，lighttpd中此值达到128*8。
需要设置此值更大一些的原因是未完成连接队列的长度可能因为客户端SYN的到达及等待三路握手第三个分节的到达延时而增大。
Netty默认的backlog为100，当然，用户可以修改默认值，用户需要根据实际场景和网络状况进行灵活设置。

---

TCP参数设置完成后，用户可以为启动辅助类和其父类分别指定Handler，两类Handler的用途不同，子类中的Hanlder是NioServerSocketChannel对应的ChannelPipeline的Handler，父类中的Hanlder是客户端新接入的连接SocketChannel对应的ChannelPipeline的Handler。

ServerBootstrap的Hanlder模型：

![ServerBootstrap的Hanlder模型](/static/img/2017-01-15-IO流/2018-07-23-17-50-04.png)

本质区别就是：

* ServerBootstrap中的Handler是NioServerSocketChannel使用的，所有连接该监听端口的客户端都会执行它；
* 父类AbstractBootstrap中的Handler是个工厂类，它为每个新接入的客户端都创建一个新的Handler。

```java
serverBootstrap
        .group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, 100)
        // 父handler
        .handler(new LoggingHandler(LogLevel.INFO))
        // ServerBootstrap中的Handler
        .childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            public void initChannel(SocketChannel ch) throws IOException {
                ch.pipeline().addLast(new NettyMessageDecoder(1024 * 1024, 4, 4));
                ch.pipeline().addLast(new NettyMessageEncoder());
                ch.pipeline().addLast("readTimeoutHandler", new ReadTimeoutHandler(50));
                ch.pipeline().addLast(new LoginAuthRespHandler());
                ch.pipeline().addLast("HeartBeatHandler", new HeartBeatRespHandler());
            }
        });
```

---

服务端启动的最后一步，就是绑定本地端口，启动服务。

```java
private ChannelFuture doBind(final SocketAddress localAddress) {
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) {
        return regFuture;
    }
    final ChannelPromise promise;
    if (regFuture.isDone()) {
        promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
    } else {
        // Registration future is almost always fulfilled already, but just in case it's not.
        promise = new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE);
        regFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                doBind0(regFuture, channel, localAddress, promise);
            }
        });
    }
    return promise;
}
```

```java
final ChannelFuture initAndRegister() {
    Channel channel;
    try {
        // 由ServerBootStrap实现
        channel = createChannel();
    } catch (Throwable t) {
        return VoidChannel.INSTANCE.newFailedFuture(t);
    }
    try {
        // 初始化
        init(channel);
    } catch (Throwable t) {
        channel.unsafe().closeForcibly();
        return channel.newFailedFuture(t);
    }
    ChannelPromise regFuture = channel.newPromise();
    // 注册到多路复用器上监听新客户端的接入
    channel.unsafe().register(regFuture);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    return regFuture;
}
```

```java
@Override
Channel createChannel() {
    EventLoop eventLoop = group().next();
    return channelFactory().newChannel(eventLoop, childGroup);
}
```

* 参数一是从父类的NIO线程池中顺序获取一个NioEventLoop，它就是服务端用于监听和接收客户端连接的Reactor线程。
* 第二个参数就是所谓的workerGroup线程池，它就是处理IO读写的Reactor线程组。

NioServerSocketChannel创建成功后对它进行初始化，初始化工作主要有三点：

* 设置Socket参数和NioServerSocketChannel的附加属性
* 将AbstractBootstrap的Handler添加到NioServerSocketChannel的ChannelPipeline中
* 将用于服务端注册的Handler ServerBootstrapAcceptor添加到ChannelPipeline中

```java
void init(Channel channel) throws Exception {
    final Map<ChannelOption<?>, Object> options = options();
    synchronized (options) {
        channel.config().setOptions(options);
    }
    final Map<AttributeKey<?>, Object> attrs = attrs();
    // 设置参数和附加信息
    synchronized (attrs) {
        for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
            @SuppressWarnings("unchecked")
            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();
            channel.attr(key).set(e.getValue());
        }
    }
    ChannelPipeline p = channel.pipeline();
    if (handler() != null) {
        // 添加AbstractBootstrap的Handler
        p.addLast(handler());
    }
    final ChannelHandler currentChildHandler = childHandler;
    final Entry<ChannelOption<?>, Object>[] currentChildOptions;
    final Entry<AttributeKey<?>, Object>[] currentChildAttrs;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));
    }
    synchronized (childAttrs) {
        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));
    }
    p.addLast(new ChannelInitializer<Channel>() {
        @Override
        public void initChannel(Channel ch) throws Exception {
            // 添加服务器端注册的Handler
            ch.pipeline().addLast(new ServerBootstrapAcceptor(currentChildHandler, currentChildOptions,
                    currentChildAttrs));
        }
    });
}
```

NioServerSocketChannel的ChannelPipeline：

![NioServerSocketChannel的ChannelPipeline](/static/img/2017-01-15-IO流/2018-07-23-18-19-10.png)

---

注册NioServerSocketChannel到Reactor线程的多路复用器上，然后轮询客户端连接事件。

```java
@Override
public final void register(final ChannelPromise promise) {
    if (eventLoop.inEventLoop()) {
        register0(promise);
    } else {
        try {
            eventLoop.execute(new Runnable() {
                @Override
                public void run() {
                    register0(promise);
                }
            });
        } catch (Throwable t) {
            logger.warn(
                    "Force-closing a channel whose registration task was not accepted by an event loop: {}",
                    AbstractChannel.this, t);
            closeForcibly();
            closeFuture.setClosed();
            promise.setFailure(t);
        }
    }
}
```

* 首先判断是否是NioEventLoop自身发起的操作，如果是，则不存在并发操作，直接执行Channel注册；
* 如果由其它线程发起，则封装成一个Task放入消息队列中异步执行。
    * 由于是由ServerBootstrap所在线程执行的注册操作，所以会将其封装成Task投递到NioEventLoop中执行

```java
private void register0(ChannelPromise promise) {
    try {
        // check if the channel is still open as it could be closed in the mean time when the register
        // call was outside of the eventLoop
        if (!ensureOpen(promise)) {
            return;
        }
        // 注册
        doRegister();
        registered = true;
        // 注册成功
        promise.setSuccess();
        // 触发事件
        pipeline.fireChannelRegistered();
        // 传递完成后判断是否监听成功，如果成功出发active事件
        if (isActive()) {
            pipeline.fireChannelActive();
        }
    } catch (Throwable t) {
        // Close the channel directly to avoid FD leak.
        closeForcibly();
        closeFuture.setClosed();
        if (!promise.tryFailure(t)) {
            logger.warn(
                    "Tried to fail the registration promise, but it is complete already. " +
                            "Swallowing the cause of the registration failure:", t);
        }
    }
}
```

```java
@Override
protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            selectionKey = javaChannel().register(eventLoop().selector, 0, this);
            return;
        } catch (CancelledKeyException e) {
            if (!selected) {
                // Force the Selector to select now as the "canceled" SelectionKey may still be
                // cached and not removed because no Select.select(..) operation was called yet.
                eventLoop().selectNow();
                selected = true;
            } else {
                // We forced a select operation on the selector before but the SelectionKey is still cached
                // for whatever reason. JDK bug ?
                throw e;
            }
        }
    }
}
```

应该注册OP_ACCEPT(16)到多路复用器上，怎么注册0呢？0表示只注册，不监听任何网络操作。这样做的原因如下：

* 注册方法是多态的，它既可以被NioServerSocketChannel用来监听客户端的连接接入，也可以用来注册SocketChannel，用来监听网络读或者写操作；
* 通过SelectionKey的interestOps(int ops)方法可以方便的修改监听操作位。所以，此处注册需要获取SelectionKey并给AbstractNioChannel的成员变量selectionKey赋值。

注册成功之后，触发ChannelRegistered事件。

Netty的HeadHandler不需要处理ChannelRegistered事件，所以，直接调用下一个Handler，当ChannelRegistered事件传递到TailHandler后结束，TailHandler也不关心ChannelRegistered事件，因此是空实现。

ChannelRegistered事件传递完成后，判断ServerSocketChannel监听是否成功，如果成功，需要出发NioServerSocketChannel的ChannelActive事件。

isActive()也是个多态方法：

* 如果是服务端，判断监听是否启动，
* 如果是客户端，判断TCP连接是否完成。

ChannelActive事件在ChannelPipeline中传递，完成之后根据配置决定是否自动触发Channel的读操作。

```java
@Override
public ChannelPipeline fireChannelActive() {
    head.fireChannelActive();
    if (channel.config().isAutoRead()) {
        channel.read();
    }
    return this;
}
```

AbstractChannel的读操作触发ChannelPipeline的读操作，最终调用到HeadHandler的读方法：

```java
@Override
public void read(ChannelHandlerContext ctx) {
    unsafe.beginRead();
}
```

继续看AbstractUnsafe的beginRead方法：

```java
@Override
public void beginRead() {
    if (!isActive()) {
        return;
    }
    try {
        doBeginRead();
    } catch (final Exception e) {
        invokeLater(new Runnable() {
            @Override
            public void run() {
                pipeline.fireExceptionCaught(e);
            }
        });
        close(voidPromise());
    }
}
```

由于不同类型的Channel对读操作的准备工作不同，因此，beginRead也是个多态方法，对于NIO通信，无论是客户端还是服务端，都是要修改网络监听操作位为自身感兴趣的。

对于NioServerSocketChannel感兴趣的操作是OP_ACCEPT(16)，于是重新修改注册的操作位为OP_ACCEPT：

```java
@Override
protected void doBeginRead() throws Exception {
    if (inputShutdown) {
        return;
    }
    final SelectionKey selectionKey = this.selectionKey;
    if (!selectionKey.isValid()) {
        return;
    }
    final int interestOps = selectionKey.interestOps();
    if ((interestOps & readInterestOp) == 0) {
        selectionKey.interestOps(interestOps | readInterestOp);
    }
}
```

在某些场景下，当前监听的操作类型和Chanel关心的网络事件是一致的，不需要重复注册，所以增加了&操作的判断，只有两者不一致，才需要重新注册操作位。

JDK SelectionKey有四种操作类型，分别为：

* OP_READ = 1 << 0；
* OP_WRITE = 1 << 2；
* OP_CONNECT = 1 << 3；
* OP_ACCEPT = 1 << 4。

由于只有四种网络操作类型，所以用4 bit就可以表示所有的网络操作位，由于JAVA语言没有bit类型，所以使用了整形来表示，
每个操作位代表一种网络操作类型，分别为：0001、0010、0100、1000，这样做的好处是可以非常方便的通过位操作来进行网络操作位的状态判断和状态修改，提升操作性能。

由于创建NioServerSocketChannel将readInterestOp设置成了OP_ACCEPT，所以，在服务端链路注册成功之后重新将操作位设置为监听客户端的网络连接操作。

```java
public NioServerSocketChannel(EventLoop eventLoop, EventLoopGroup childGroup) {
    super(null, eventLoop, childGroup, newSocket(), SelectionKey.OP_ACCEPT);
    config = new DefaultServerSocketChannelConfig(this, javaChannel().socket());
}
```

#### 客户端接入源码分析

负责处理网络读写、连接和客户端请求接入的Reactor线程是NioEventLoop。

当多路复用器检测到新的准备就绪的Channel时，默认执行processSelectedKeysOptimized方法（NioEventLoop的run()方法中入口）。

```java
@Override
protected void run() {
    for (;;) {
        oldWakenUp = wakenUp.getAndSet(false);
        try {
            if (hasTasks()) {
                selectNow();
            } else {
                select();
                // 'wakenUp.compareAndSet(false, true)' is always evaluated
                // before calling 'selector.wakeup()' to reduce the wake-up
                // overhead. (Selector.wakeup() is an expensive operation.)
                //
                // However, there is a race condition in this approach.
                // The race condition is triggered when 'wakenUp' is set to
                // true too early.
                //
                // 'wakenUp' is set to true too early if:
                // 1) Selector is waken up between 'wakenUp.set(false)' and
                //    'selector.select(...)'. (BAD)
                // 2) Selector is waken up between 'selector.select(...)' and
                //    'if (wakenUp.get()) { ... }'. (OK)
                //
                // In the first case, 'wakenUp' is set to true and the
                // following 'selector.select(...)' will wake up immediately.
                // Until 'wakenUp' is set to false again in the next round,
                // 'wakenUp.compareAndSet(false, true)' will fail, and therefore
                // any attempt to wake up the Selector will fail, too, causing
                // the following 'selector.select(...)' call to block
                // unnecessarily.
                //
                // To fix this problem, we wake up the selector again if wakenUp
                // is true immediately after selector.select(...).
                // It is inefficient in that it wakes up the selector for both
                // the first case (BAD - wake-up required) and the second case
                // (OK - no wake-up required).
                if (wakenUp.get()) {
                    selector.wakeup();
                }
            }
            cancelledKeys = 0;
            final long ioStartTime = System.nanoTime();
            needsToSelectAgain = false;
            if (selectedKeys != null) {
                processSelectedKeysOptimized(selectedKeys.flip());
            } else {
                processSelectedKeysPlain(selector.selectedKeys());
            }
            final long ioTime = System.nanoTime() - ioStartTime;
            final int ioRatio = this.ioRatio;
            runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    break;
                }
            }
        } catch (Throwable t) {
            logger.warn("Unexpected exception in the selector loop.", t);
            // Prevent possible consecutive immediate failures that lead to
            // excessive CPU consumption.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // Ignore.
            }
        }
    }
}
```

```java
private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
    for (int i = 0;; i ++) {
        final SelectionKey k = selectedKeys[i];
        if (k == null) {
            break;
        }
        final Object a = k.attachment();
        if (a instanceof AbstractNioChannel) {
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            @SuppressWarnings("unchecked")
            NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;
            processSelectedKey(k, task);
        }
        if (needsToSelectAgain) {
            selectAgain();
            selectedKeys = this.selectedKeys.flip();
            i = -1;
        }
    }
}
```

由于Channel的Attachment是NioServerSocketChannel，所以执行processSelectedKey方法，根据就绪的操作位，执行不同的操作，
由于监听的是连接操作，所以执行unsafe.read()方法，由于不同的Channel执行不同的操作，所以NioUnsafe被设计成接口，由不同的Channel内部的NioUnsafe实现类负责具体实现，
read()方法的实现有两个，分别是NioByteUnsafe和NioMessageUnsafe，对于NioServerSocketChannel，它使用的是NioMessageUnsafe：

```java
@Override
public void read() {
    assert eventLoop().inEventLoop();
    if (!config().isAutoRead()) {
        removeReadOp();
    }
    final ChannelConfig config = config();
    final int maxMessagesPerRead = config.getMaxMessagesPerRead();
    final boolean autoRead = config.isAutoRead();
    final ChannelPipeline pipeline = pipeline();
    boolean closed = false;
    Throwable exception = null;
    try {
        for (;;) {
            // 接收新的客户端连接并创建NioSocketChannel
            int localRead = doReadMessages(readBuf);
            if (localRead == 0) {
                break;
            }
            if (localRead < 0) {
                closed = true;
                break;
            }
            if (readBuf.size() >= maxMessagesPerRead | !autoRead) {
                break;
            }
        }
    } catch (Throwable t) {
        exception = t;
    }
    int size = readBuf.size();
    for (int i = 0; i < size; i ++) {
        // 接收到新的客户端连接后，触发ChannelPipeline的ChannelRead方法
        pipeline.fireChannelRead(readBuf.get(i));
    }
    readBuf.clear();
    // 触发事件
    pipeline.fireChannelReadComplete();
    if (exception != null) {
        if (exception instanceof IOException) {
            // ServerChannel should not be closed even on IOException because it can often continue
            // accepting incoming connections. (e.g. too many open files)
            closed = !(AbstractNioMessageChannel.this instanceof ServerChannel);
        }

        pipeline.fireExceptionCaught(exception);
    }
    if (closed) {
        if (isOpen()) {
            close(voidPromise());
        }
    }
}

@Override
protected int doReadMessages(List<Object> buf) throws Exception {
    SocketChannel ch = javaChannel().accept();
    try {
        if (ch != null) {
            buf.add(new NioSocketChannel(this, childEventLoopGroup().next(), ch));
            return 1;
        }
    } catch (Throwable t) {
        logger.warn("Failed to create a new channel from an accepted socket.", t);
        try {
            ch.close();
        } catch (Throwable t2) {
            logger.warn("Failed to close a socket.", t2);
        }
    }
    return 0;
}
```

执行headChannelHandlerContext的fireChannelRead方法，事件在ChannelPipeline中传递，执行ServerBootstrapAcceptor的channelRead方法：

```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    Channel child = (Channel) msg;
    // 设置childHandler到Pipeline
    child.pipeline().addLast(childHandler);
    for (Entry<ChannelOption<?>, Object> e: childOptions) {
        try {
            // 设置TCP参数
            if (!child.config().setOption((ChannelOption<Object>) e.getKey(), e.getValue())) {
                logger.warn("Unknown channel option: " + e);
            }
        } catch (Throwable t) {
            logger.warn("Failed to set a channel option: " + child, t);
        }
    }
    for (Entry<AttributeKey<?>, Object> e: childAttrs) {
        child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());
    }
    // 注册SocketChinnel到多路复用器
    child.unsafe().register(child.newPromise());
}
```

该方法包含三个主要步骤：

* 第一步：将启动时传入的childHandler加入到客户端SocketChannel的ChannelPipeline中；
* 第二步：设置客户端SocketChannel的TCP参数；
* 第三步：注册SocketChannel到多路复用器。

NioSocketChannel的注册方法也是将Channel注册到Reactor线程的多路复用器上。

ChannelReadComplete在ChannelPipeline中的处理流程：

Netty的Header和Tail本身不关注ChannelReadComplete事件就直接透传，执行完ChannelReadComplete后，接着执行PipeLine的read()方法，最终执行HeadHandler的read()方法。

```java
@Override
public ChannelPipeline fireChannelReadComplete() {
    head.fireChannelReadComplete();
    if (channel.config().isAutoRead()) {
        read();
    }
    return this;
}
```

创建NioSocketChannel的时候已经将AbstractNioChannel的readInterestOp设置为OP_READ，这样，执行selectionKey.interestOps(interestOps | readInterestOp)操作时就会把操作位设置为OP_READ。

### 客户端创建

#### Netty客户端创建时序图

![Netty客户端创建时序图](/static/img/2017-01-15-IO流/2018-07-23-22-00-26.png)

#### Netty客户端流程分析

* 步骤1：用户线程创建Bootstrap实例，通过API设贺创建客户端相关的参数，异步发起客户端连接。
* 步骤2：创建处理客户端连接、通过构造函数指定I/0线程的个数，I/0读写的Reactor线程组NioEventLoopGroup。可以默认为CPU内核数的2倍；
* 步骤3：通过Bootstrap的ChannelFactory和用户指定的Channel类型创建用于客户端连接的NioSocketChannel，它的功能类似于JDK NIO类库提供的SocketChannel；
* 步骤4：创建默认的Channel Handler Pipeline，用于调度和执行网络事件；
* 步骤5：异步发起TCP连接，判断连接是否成功。如果成功，则直接将NioSocketChannel注册到多路复用器上，监听读操作位，用于数据报读取和消息发送；如果没有立即连接成功，则注册连接监听位到多路复用器，等待连接结果；
* 步骤6：注册对应的网络监听状态位到多路复用器；
* 步骤7：由多路复用器在I/0现场中轮询各Channel，处理连接结果；
* 步骤8：如果连接成功，设置Future结果，发送连接成功事件，触发ChannelPipeline执行；
* 步骤9：由ChannelPipeline调度执行系统和用户的CbannelHandler，执行业务逻辑。

---

*以上概念总结于传智播客Java基础课程、《Netty权威指南》*