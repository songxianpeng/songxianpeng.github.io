---  
layout: post  
title: Spring  
tags: Spring  
categories: JavaEE  
published: true  
---  

[TOC]

Spring是一个开源的轻量级一站式（对三层都提供了解决技术）框架，核心IOC和AOP

功能：简化开发。创建Spring的主要目的是用来替代更加重量级的企业级Java技术，尤其是EJB。相对于EJB来说，Spring提供了更加轻量级和简单的编程模型。它增强了简单老式Java对象（Plain Old Java object，POJO）的功能，使其具备了之前只有EJB和其他企业级Java规范才具有的功能。桥梁作用，整合其他框架

为了降低Java开发的复杂性，Spring采取了以下4种关键策略：

* 基于POJO的轻量级和最小侵入性编程
* 通过依赖注入和面向接口实现松耦合
* 基于切面和惯例进行声明式编程
* 通过切面和模板减少样板式代码

## Spring模块

![spring-overview.png](/static/img/spring/spring-overview.png "spring-overview.png")

核心依赖四个jar包：

* core
* beans
* expression
* context

* Spring核心容器
    - 容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Spring bean工厂，它为Spring提供了DI的功能。基于bean工厂，多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。
    - 除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度。
    - 所有的Spring模块都构建于核心容器之上。
* Spring的AOP模块
    - 在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。
* 数据访问与集成
    - Spring的JDBC和DAO（Data Access Object）模块抽象了样板式代码，使数据库代码变得简单明了，还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，再也不需要解释那些隐晦专有的SQL错误信息了！
    - Spring没有尝试去创建自己的ORM解决方案，而是对许多流行的ORM框架进行了集成，包括Hibernate、Java Persisternce API、Java Data Object和iBATIS SQL Maps。Spring的事务管理支持所有的ORM框架以及JDBC。
    - 本模块同样包含了在JMS（Java Message Service）之上构建的Spring抽象层，它会使用消息以异步的方式与其他应用集成。从Spring 3.0开始，本模块还包含对象到XML映射的特性，它最初是Spring Web Service项目的一部分。
    - 本模块会使用Spring AOP模块为Spring应用中的对象提供事务管理服务。
* Web与远程调用
    - 虽然Spring能够与多种流行的MVC框架进行集成，但它的Web和远程调用模块自带了一个强大的MVC框架，有助于在Web层提升应用的松耦合水平。
    - 该模块还提供了多种构建与其他应用交互的远程调用方案。Spring远程调用功能集成了RMI（Remote Method Invocation）、Hessian、Burlap、JAX-WS，同时Spring还自带了一个远程调用框架：HTTP invoker。Spring还提供了暴露和使用REST API的良好支持。
* Instrumentation
    - Spring的Instrumentation模块提供了为JVM添加代理（agent）的功能。
* 测试
    - Spring提供了测试模块以致力于Spring应用的测试。通过该模块，你会发现Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现。对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。

## Spring Portfolio

整个Spring Portfolio包括多个构建于核心Spring框架之上的框架和类库。概括地讲，整个Spring Portfolio几乎为每一个领域的Java开发都提供了Spring编程模型。

* Spring Web Flow
    - Spring Web Flow建立于Spring MVC框架之上，它为基于流程的会话式Web应用（可以想一下购物车或者向导功能）提供了支持。
* Spring Web Service
    - 虽然核心的Spring框架提供了将Spring bean以声明的方式发布为Web Service的功能，但是这些服务是基于一个具有争议性的架构（拙劣的契约后置模型）之上而构建的。这些服务的契约由bean的接口来决定。 Spring Web Service提供了契约优先的Web Service模型，服务的实现都是为了满足服务的契约而编写的。
* Spring Security
    - 安全对于许多应用都是一个非常关键的切面。利用Spring AOP，Spring Security为Spring应用提供了声明式的安全机制。
* Spring Integration
    - 许多企业级应用都需要与其他应用进行交互。Spring Integration提供了多种通用应用集成模式的Spring声明式风格实现。
* Spring Batch
    - 当需要对数据进行大量操作时，没有任何技术可以比批处理更胜任这种场景。如果需要开发一个批处理应用，你可以通过Spring Batch，使用Spring强大的面向POJO的编程模型。
* Spring Data
    - Spring Data使得在Spring中使用任何数据库都变得非常容易。为NoSQL数据库提供了使用数据的新方法，这些方法会比传统的关系型数据库更为合适。
    - 不管你使用文档数据库，如MongoDB，图数据库，如Neo4j，还是传统的关系型数据库，Spring Data都为持久化提供了一种简单的编程模型。这包括为多种数据库类型提供了一种自动化的Repository机制，它负责为你创建Repository的实现。
* Spring Social
    - 这是Spring的一个社交网络扩展模块。它能够帮助你通过REST API连接Spring应用
* Spring Mobile
    - Spring Mobile是Spring MVC新的扩展模块，用于支持移动Web应用开发。
* Spring for Android
    - 与Spring Mobile相关的是Spring Android项目。这个新项目，旨在通过Spring框架为开发基于Android设备的本地应用提供某些简单的支持。最初，这个项目提供了Spring RestTemplate的一个可以用于Android应用之中的版本。它还能与Spring Social协作，使得原生应用可以通过REST API进行社交网络的连接。
* Spring Boot
    - Spring Boot是一个崭新的令人兴奋的项目，它以Spring的视角，致力于简化Spring本身。
    - Spring Boot大量依赖于自动配置技术，它能够消除大部分（在很多场景中，甚至是全部）Spring配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都能减少Spring工程构建文件的大小。

## 容器

在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。

容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。

Spring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。

* bean工厂（由org.springframework. beans. factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。
* 应用上下文（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。

虽然可以在bean工厂和应用上下文之间任选一种，但bean工厂对大多数应用来说往往太低级了，因此，应用上下文要比bean工厂更受欢迎。

### 应用上下文

Spring自带了多种类型的应用上下文。

* AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。
* AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载Spring Web应用上下文。
* ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。
* FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。
* XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。

### bean的生命周期

bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制

![bean-life-cycle](/static/img/spring/bean-life-cycle.png "bean-life-cycle")

1. Spring对bean进行实例化
2. Spring将值和bean的引用注入到bean对应的属性中
3. 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法
4. 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来
6. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法
7. 如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用
8. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法
9. 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁
10. 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用

## IOC

使用new实例创建对象耦合度太高，使用工厂模式仅与工厂耦合，将创建对象的工作交给spring工厂完成

创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。

### 优势

* 创建应用对象之间关联关系的传统方法（通过构造器或者查找）通常会导致结构复杂的代码，这些代码很难被复用也很难进行单元测试。如果情况不严重的话，这些对象所做的事情只是超出了它应该做的范围；而最坏的情况则是，这些对象彼此之间高度耦合，难以复用和测试。  
* 在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。

DI所带来的最大收益——松耦合。

耦合具有两面性

* 一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且典型地表现出“打地鼠”式的bug特性（修复一个bug，将会出现一个或者更多新的bug）。
* 另一方面，一定程度的耦合又是必须的——完全没有耦合的代码什么也做不了。

对依赖进行替换的一个最常用方法就是在测试的时候使用mock实现。


### 原理

* XML配置文件
* dom4j解析
* 工厂设计模式
* 反射

### bean的实例化方式

* 使用类无参构造方法创建
* 使用静态工厂创建
* 使用实例工厂创建

```xml
<!--通过无参构造-->
<bean id="myBean" class="com.xpress.model.MyBean"/>
<!--通过静态工厂-->
<bean id="myBean" class="com.xpress.factory.StaticBeanFactory" factory-method="getBean"/>
<!--通过实例工厂-->
<bean id="factory" class="com.xpress.factory.BeanFactory"/>
<bean id="myBean" factory-bean="factory" factory-method="getBean"/>
```

### 配置可选方案

三种主要的装配机制：

* 在XML中进行显式配置。
* 在Java中进行显式配置。
* 隐式的bean发现机制和自动装配。

建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置bean的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。

#### XML配置方式

使用XML文件进行配置的，所以选择ClassPathXmlApplicationContext

##### 配置文件加载

###### 手动加载

```java
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
MyBean myBean = (MyBean) applicationContext.getBean("myBean");
```

###### Web项目容器加载

实现思想：把加载配置文件和创建对象过程，在服务器启动的时候完成

实现原理：

* ServletContext对象
* 监听器

1. 在服务器启动的时候，每个项目会创建一个ServletContext对象
2. 在ServletContext对象创建的时候，使用监听器监听到ServletContext对象的创建，此时加载配置文件并创建对象
3. 把创建出来的对象放到ServletContext域中（setAttribute()方法）
3. 获取对象时，在ServletContext域中取出（getAttribute()方法）

引入spring-web.jar

```xml
<!-- 配置监听器 -->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
<!-- 配置文件位置 -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
```

##### 配置文件

缺点：

* 并没有JavaConfig那样强大，在JavaConfig配置方式中，你可以通过任何可以想象到的方法来创建bean实例。
* Spring的XML配置并不能从编译期的类型检查中受益。

* 配置文件：官方建议applicationContext.xml

dtd

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
        "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
<beans>
    <!-- bean definitions here -->
    <!-- 引入其他配置 -->
    <import resource="cd-config.xml"/>
    <!-- 引入配置类或者启动组件扫描 -->
    <bean class="soundsystem.CDConfig"/>
</beans>
```

schema

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- bean definitions here -->
</beans>
```

##### bean标签

###### 常用属性

* id：名称，不能包含特殊符号
* class：对象全路径
* name：同id，可以包含特殊符号（兼容struts1，已废弃）
* scope：作用域
    - singleton：单例的（默认）
    - prototype：多例的
    - 需要在web.xml中配置org.springframework.web.context.request.RequestContextListener支持
        + request：创建一个bean对象并存入request中，随request废弃而废弃
        + session：创建一个bean对象并存入session中，随session废弃而废弃
        + globalSession：应用在Portlet环境放到globalSession中，非Portlet环境相当于session，生命周期在portlet Session的生命周期范围
* lazy-init：懒加载，第一次获取bean时才初始化，singleton时默认容器启动就初始化bean
    - 在beans标签可以设置默认懒加载default-lazy-init="true"
* init-method：初始化方法，创建实例后调用
* destroy-method：销毁方法，在context正常关闭时调用
* autowire：配置当前bean的属性按何种方式自动装配
    - no：默认值，手动装配
    - byType：根据属性类型匹配，发现多个抛异常，没找到为null
    - byName：根据属性名称匹配，没找到为null
    - constructor：同byType，如果在容器中没有找到与构造器参数类型一致的bean，则抛异常
    - autodetect：通过bean的内省机制决定使用constructor还是byType方式，如果发现默认构造器，使用byType方式
    - 在beans标签可以设置默认装配方式default-autowire="byName"

##### 属性注入

作为一个通用的规则，我倾向于对强依赖使用构造器注入，而对可选性的依赖使用属性注入。

注入方式

* set方法注入（spring支持）
* 有参构造注入（spring支持）
* 接口注入（实现指定结口的方法）

**set方法注入**

需要注入的属性必须有相应的set方法

```xml
<bean id="myBean" class="com.xpress.model.MyBean">
    <property name="name" value="xpress"/>
</bean>
<!-- 声明service -->
<bean id="myService" class="com.xpress.service.MyService"/>
<bean id="myAction" class="com.xpress.action.MyAction">
    <!-- 注入service -->
    <property name="myService" ref="myService"/>
</bean>
```

**复杂类型注入**

* 数组
* list集合
* map集合
* properties集合

```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

util命名空间：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xmlns:util="http://www.springframework.org/schema/util"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/util 
    http://www.springframework.org/schema/util/spring-util.xsd">

  <bean id="compactDisc"
        class="soundsystem.properties.BlankDisc"
        p:title="Sgt. Pepper's Lonely Hearts Club Band"
        p:artist="The Beatles"
        p:tracks-ref="trackList" />

  <util:list id="trackList">  
    <value>Sgt. Pepper's Lonely Hearts Club Band</value>
    <value>With a Little Help from My Friends</value>
    <value>Lucy in the Sky with Diamonds</value>
  </util:list>
</beans>

```

Spring util-命名空间中的元素：

|       元 素        |                       描 述                        |
|--------------------|----------------------------------------------------|
| util:constant      | 引用某个类型的public static域，并将其暴露为bean    |
| util:list          | 创建一个java.util.List类型的bean，其中包含值或引用 |
| util:map           | 创建一个java.util.Map类型的bean，其中包含值或引用  |
| util:properties    | 创建一个java.util.Properties类型的bean             |
| util:property-path | 引用一个bean的属性（或内嵌属性），并将其暴露为bean |
| util:set           | 创建一个java.util.Set类型的bean，其中包含值或引用  |


**有参构造注入**

constructor-arg：

```xml
 <bean id="myBean" class="com.xpress.model.MyBean">
    <!-- index可以省略 -->
    <constructor-arg index="0" name="name" value="xpress"/>
    <constructor-arg name="userDao" ref="userDao"/>
</bean>
```

c命名空间：

```java
@Autowired
public CDPlayer(CompactDisc cd) {
    this.cd = this.cd;
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:c="http://www.springframework.org/schema/c"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="compactDisc" class="soundsystem.SgtPeppers" />
  <!-- 装配引用 -->
  <bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
  <!-- 使用索引而不是变量名 -->
  <bean id="cdPlayer1" class="soundsystem.CDPlayer" c:_0-ref="compactDisc"/>
  <!-- 只有一个省略数字 -->
  <bean id="cdPlayer2" class="soundsystem.CDPlayer" c:_-ref="compactDisc"/>

  <!-- 装配值 -->
  <bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band"  c:_1="The Beatles" />
  <bean id="cdPlayer" class="soundsystem.CDPlayer" c:_0="compactDisc" />
</beans>
```

![c-namespace](/static/img/spring/c-namespace.png "c-namespace")

**名称空间p注入**

p-命名空间中属性所遵循的命名约定与c-命名空间中的属性类似。

```xml
<!-- 引入名称空间p -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<bean id="myBean" class="com.xpress.model.MyBean" p:name="xpress"/>
<bean id="cdPlayer" class="soundsystem.properties.CDPlayer" p:compactDisc-ref="compactDisc" />
```

![p-namespace](/static/img/spring/p-namespace.png "p-namespace")

#### 注解方式

Spring从两个角度来实现自动化装配：

* 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。
* 自动装配（autowiring）：Spring自动满足bean之间的依赖。

对于基于Java的配置，Spring提供了AnnotationConfigApplicationContext

##### 开启注解

引入context包schema，并打开注解扫描

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--开启类，方法，属性上的注解扫描，完全使用注解-->
    <context:component-scan base-package="com.xpress.service,com.xpress.dao,com.xpress.model"/>
    <!--只开启属性上的注解扫描，仍然需要在配置文件中声明bean-->
    <!--<context:annotation-config/>-->
</beans>
```

如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。Spring将会扫描这个包以及这个包下的所有子包，查找带有注解的类，并且会在Spring中自动为其创建一个bean。

```java
@Configuration
@ComponentScan// 以配置类所在的包作为基础包（base package）来扫描组件
// @ComponentScan(basePackageClasses = {CDPlayer.class,SgtPeppers.class}) // 这些类所在的包将会作为组件扫描的基础包
// @ComponentScan(basePackages={"soundsystem","video"}) // 更加清晰地表明你所设置的是基础包
public class CDPlayerConfig { 
}
```

annotation-config配置隐式注册了多个对注解进行解析的处理器

* spring-beans:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor 处理@Autowired注解
* spring-beans:org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor 处理@Resource
* spring-context:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor 处理持久化相关注解
* spring-tx:org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor 处理@Required注解

##### 创建对象

目前提供的4个注解功能都是一样的，spring为了以后对注解功能进行拓展

* @Component 泛指组件
* @Controller WEB层
* @Service 业务层
* @Repository 持久层

```java
@Component(value = "myBean")// <bean id="myBean"
@Scope(value = "singleton")// 指定单例，不指定默认单例
public class MyBean {
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    // 注解指定init-method，在注入属性后执行
    @PostConstruct
    public void init(){}
    @PreDestroy
    public void destroy() {}
}
```

##### 注入属性

注解可以用于属性上和属性的set方法上

* @Autowired
    - 默认按类型进行装配，设置@Qualifier指定按名称装配
    - 默认要求必须存在，设置required属性为false允许null
    - 可以用在set方法上、属性上、构造器上和其他方法上
* @Resource(name = "userDao")
    - 默认按名称进行装配，找不到匹配名称才使用类型装配
    - name属性可以指定名称，指定名称后匹配不到将不会按类型装配
* @Inject

```java
@Service("userService")
public class UserService {
    @Resource(name = "userDao")
    private UserDao userDao;
    @Autowired
    @Qualifier("userDao")// 指定按名称进行装配
    private UserDao userDao;
}
```

```java
@Component
public class CDPlayer implements MediaPlayer {
  private CompactDisc cd;
  @Autowired // 能够用在构造器上
  public CDPlayer(CompactDisc cd) {
    this.cd = cd;
  }
  public void play() {
    cd.play();
  }
}
```

#### JavaConfig

在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。

它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样都使用相同的语言进行表述，但JavaConfig是配置代码。这意味着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码之中。

* 默认情况下，bean的ID与带有@Bean注解的方法名是一样的，也可以通过name属性指定一个不同的名字
* 方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。

```java
@Configuration
@Import({CDPlayerConfig.class,CDConfig.class})// 引入其他配置
@ImportResource("classpath:cd-config.xml")// 引入xml配置
public class CDPlayerConfig {
    @Bean//(name = "compactDisc")
    public CompactDisc compactDisc() {
        return new SgtPeppers();
    }
    // 自动装配合适的compactDisc
    // 你可以将配置分散到多个配置类、XML文件以及自动扫描和装配bean之中，只要功能完整健全即可。
    @Bean
    // @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE //控制实例为单例还是多例
    public CDPlayer cdPlayer(CompactDisc compactDisc) {
        return new CDPlayer(compactDisc);
    }
}
```

```java
@ContextConfiguration(classes=CDPlayerConfig.class)
public class CDPlayerTest {
    @Autowired
    private MediaPlayer player;
}
```

### profile

#### JavaConfig

在Spring 3.1中，只能在类级别上使用@Profile注解。从Spring 3.2开始，你也可以在方法级别上使用@Profile注解，与@Bean注解一同使用。

```java
@Configuration
public class DataSourceConfig {
    @Bean
    @Profile("dev")
    public DataSource embeddedDataSource() {
      return new EmbeddedDatabaseBuilder()
          .setType(EmbeddedDatabaseType.H2)
          .addScript("classpath:schema.sql")
          .addScript("classpath:test-data.sql")
          .build();
    }
    @Bean
    @Profile("prod")
    public DataSource jndiDataSource() {
      JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();
      jndiObjectFactoryBean.setJndiName("jdbc/myDS");
      jndiObjectFactoryBean.setResourceRef(true);
      jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);
      return (DataSource) jndiObjectFactoryBean.getObject();
  }

}
```

尽管每个DataSource bean都被声明在一个profile中，并且只有当规定的profile激活时，相应的bean才会被创建，但是可能会有其他的bean并没有声明在一个给定的profile范围内。  
没有指定profile的bean始终都会被创建，与激活哪个profile没有关系。

#### XML

* 可以通过`<beans>`元素的profile属性，在XML中配置profile bean。
* 还可以在根`<beans>`元素中嵌套定义`<beans>`元素，而不是为每个环境都创建一个profile XML文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xmlns:jee="http://www.springframework.org/schema/jee" xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="
    http://www.springframework.org/schema/jee
    http://www.springframework.org/schema/jee/spring-jee.xsd
    http://www.springframework.org/schema/jdbc
    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd" profile="dev">
</beans>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xmlns:jee="http://www.springframework.org/schema/jee" xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="
    http://www.springframework.org/schema/jee
    http://www.springframework.org/schema/jee/spring-jee.xsd
    http://www.springframework.org/schema/jdbc
    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">
  <beans profile="dev">
    <jdbc:embedded-database id="dataSource" type="H2">
      <jdbc:script location="classpath:schema.sql" />
      <jdbc:script location="classpath:test-data.sql" />
    </jdbc:embedded-database>
  </beans>
  <beans profile="prod">
    <jee:jndi-lookup id="dataSource"
      lazy-init="true"
      jndi-name="jdbc/myDatabase"
      resource-ref="true"
      proxy-interface="javax.sql.DataSource" />
  </beans>
</beans>
```

#### 激活profile

Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：

* spring.profiles.active
* spring.profiles.default

如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active属性的话，那Spring将会查找spring.profiles.default的值。如果均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。

有多种方式来设置这两个属性：

* 作为DispatcherServlet的初始化参数；
* 作为Web应用的上下文参数；
* 作为JNDI条目；
* 作为环境变量；
* 作为JVM的系统属性；
* 在集成测试类上，使用@ActiveProfiles注解设置。

*Tips：一种方式是使用DispatcherServlet的参数将spring.profiles.default设置为开发环境的profile，当应用程序部署到QA、生产或其他环境之中时，负责部署的人根据情况使用系统属性、环境变量或JNDI设置spring.profiles.active即可。*

**web.xml**

```xml
<!-- 为上下文设值默认的profile -->
<context-param>
    <param-name>spring.profiles.default</param-name>
    <param-value>dev</param-value>
</context-param>

<servlet>
    <servlet-name>spring-webmvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <!--为 Servlet设值默认profile -->
        <param-name>spring.profiles.default</param-name>
        <param-value>dev</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
```

**测试**

```java

public class DataSourceConfigTest {
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(classes = DataSourceConfig.class)
    @ActiveProfiles("prod")// 指定运行测试时要激活哪个profile
    public static class ProductionDataSourceTest {
        @Autowired
        private DataSource dataSource;
        @Test
        public void shouldBeEmbeddedDatasource() {
            // should be null, because there isn't a datasource configured in JNDI
            assertNull(dataSource);
        }
    }

    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration("classpath:datasource-config.xml")
    @ActiveProfiles("dev")
    public static class DevDataSourceTest_XMLConfig {
        @Autowired
        private DataSource dataSource;
        @Test
        public void shouldBeEmbeddedDatasource() {
            assertNotNull(dataSource);
            JdbcTemplate jdbc = new JdbcTemplate(dataSource);
            List<String> results = jdbc.query("select id, name from Things", new RowMapper<String>() {
                @Override
                public String mapRow(ResultSet rs, int rowNum) throws SQLException {
                    return rs.getLong("id") + ":" + rs.getString("name");
                }
            });
            assertEquals(1, results.size());
            assertEquals("1:A", results.get(0));
        }
    }
}
```

### 条件化的bean

Spring 4引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。

```java
@Configuration
public class MagicConfig {
    @Bean
    @Conditional(MagicExistsCondition.class)
    public MagicBean magicBean() {
        return new MagicBean();
    }
}
```

```java
public class MagicExistsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Environment env = context.getEnvironment();
        return env.containsProperty("magic");
    }
}
```

matches()方法会得到ConditionContext和AnnotatedTypeMetadata对象用来做出决策。

通过ConditionContext，可以做到如下几点：

* 借助getRegistry()返回的BeanDefinitionRegistry检查bean定义
* 借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性
* 借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么
* 读取并探查getResourceLoader()返回的ResourceLoader所加载的资源
* 借助getClassLoader()返回的ClassLoader加载并检查类是否存在

通过AnnotatedTypeMetadata，可以做到如下几点：

* 借助isAnnotated()方法，能够判断带有@Bean注解的方法是不是还有其他特定的注解
* 借助其他的那些方法，能够检查@Bean注解的方法上其他注解的属性

### 处理自动装配的歧义性

可以将可选bean中的某一个设为首选（primary）的bean，或者使用限定符（qualifier）来帮助Spring将可选的bean的范围缩小到只有一个bean。

#### 标示首选的bean

Spring将会使用首选的bean，而不是其他可选的bean。

```java
@Component
@Primary
public IceCream implements Dessert{}
```

```java
@Bean
@Primary
public Dessert iceCream{
    return new IceCream();
}
```

```xml
<bean id="iceCream" class="com.dessert.IceCream" primary="true"/>
```

#### 限定自动装配的bean

@Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用  
可以为bean设置自己的限定符，而不是依赖于将bean ID作为限定符。在这里所需要做的就是在bean声明上添加@Qualifier注解。它可以与@Component组合使用

```java
@Component
@Qualifier("dessert")
public IceCream implements Dessert{}
```

```java
@Autowired
@Qualifier("dessert")
public void setDessert(Dessert dessert){
    this.dessert = dessert;
}
```

### bean的作用域

Spring定义了多种作用域：

* 单例（Singleton）：在整个应用中，只创建bean的一个实例
* 原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例
* 会话（Session）：在Web应用中，为每个会话创建一个bean实例
* 请求（Rquest）：在Web应用中，为每个请求创建一个bean实例

如果选择其他的作用域，要使用@Scope注解，它可以与@Component或@Bean一起使用。

```java
@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.INTERFACES)
public class Notepad {
    // the details of this class are inconsequential to this example
}
```

proxyMode:

* proxyMode属性被设置成了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean。
* 一个具体的类的话，Spring就没有办法创建基于接口的代理了，它使用CGLib来生成基于类的代理，必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理

*XML的作用域参看上文XML配置中bean标签部分*

### 运行时值注入

Spring提供了两种在运行时求值的方式：

* 属性占位符（Property placeholder）。
* Spring表达式语言（SpEL）。

#### 注入外部的值

处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。

##### Environment

```java
@Configuration
@PropertySource("classpath:/com/soundsystem/app.properties")
public class EnvironmentConfig {
    @Autowired
    Environment env;
    @Bean
    public BlankDisc blankDisc() {
        return new BlankDisc(
                env.getProperty("disc.title"),
                env.getProperty("disc.artist"));
    }
}

```

##### 占位符

**开启**

```xml
<context:property-placeholder location="com/soundsystem/app.properties" />
```

```java
@Configuration
public class EnvConfig {
    @Bean
    public PropertyPlaceholderConfigurer propertyPlaceholderConfigurer() {
        PropertyPlaceholderConfigurer propertyPlaceholderConfigurer = new PropertyPlaceholderConfigurer();
        propertyPlaceholderConfigurer.setLocation(new ClassPathResource("/com/soundsystem/app.properties"));
        return propertyPlaceholderConfigurer;
    }
}
```

**使用**

```xml
<bean class="com.soundsystem.BlankDisc" c:_0 = "${disc.title}" c:_1 = "${disc.artist}"/>
```

```java
public BlankDisc(@Value("${disc.title}") String title,
                 @Value("${disc.artist}") String artist) {
    this.title = title;
    this.artist = artist;
}
```

#### 使用Spring表达式语言进行装配

Spring 3引入了Spring表达式语言（Spring Expression Language，SpEL），SpEL拥有很多特性，包括：

* 使用bean的ID来引用bean
* 调用方法和访问对象的属性
* 对值进行算术、关系和逻辑运算
* 正则表达式匹配
* 集合操作

SpEL可以在@Value注解和xml配置中使用

**SpEL通过ID引用其他的bean。**

```
#{artistSelect.selectArtist()?.toUpperCase()}
```

使用了“?.”运算符。这个运算符能够在访问它右边的内容之前，确保它所对应的元素不是null。所以，如果selectArtist()的返回值是null的话，那么SpEL将不会调用toUpperCase()方法。表达式的返回值会是null。

**要在SpEL中访问类作用域的方法和常量的话，要依赖T()这个关键的运算符。例**

```
T(java.lang.Math).PI
```

**运算符**

| 运算符类型 |                         运算符                         |
|------------|--------------------------------------------------------|
| 算术运算   | +、-、 * 、/、%、^                                     |
| 比较运算   | < 、 > 、 == 、 <= 、 >= 、 lt 、 gt 、 eq 、 le 、 ge |
| 逻辑运算   | and 、 or 、 not 、`│`                                 |
| 条件运算   | ?: (ternary) 、 ?: (Elvis)                             |
| 正则表达式 | matches                                                |

```
#{2 * T(java.lang.Math).PI * circle.radius ^ 2}
#{scoreRecord.score > 1000 ? "Winner" : "Loser"}
// 三元运算符的一个常见场景就是检查null值，并用一个默认值来替代null。
#{disk.title ?: 'Rattle and Hum'}
#{user.email mathces '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'}
```

**计算集合**

SpEL还提供了查询运算符（.?[]），它会用来对集合进行过滤，得到集合的一个子集

```
#{jukebox.songs.?[artist eq 'Joe']}
```

SpEL还提供了另外两个查询运算符：“.^[]”和“.$[]”，它们分别用来在集合中查询第一个匹配项和最后一个匹配项

```
#{jukebox.songs.^[artist eq 'Joe']}
```

SpEL还提供了投影运算符（.![]），它会从集合的每个成员中选择特定的属性放到另外一个集合中

```
#{jukebox.songs.![title]}
```

投影操作可以与其他任意的SpEL运算符一起使用

```
#{jukebox.songs.?[artist eq 'Joe'].![title]}
```


## IOC和DI

* IOC：控制反转，把对象创建交给spring配置
* DI：依赖注入，向对象属性中设置值
* 关系：DI不能单独存在，要在IOC基础上完成

## AOP

面向切面编程，采取横向抽取机制，取代了传统纵向继承体系和委托重复性代码（性能监视、事务处理、安全检查、缓存）

### 实现原理

* 针对有接口的情况，使用jdk的动态代理产生接口代理对象
* 针对没有接口的情况，使用cglib产生子类代理对象

直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。

Spring基于动态代理，所以Spring只支持方法连接点。这与一些其他的AOP框架是不同的，例如AspectJ和JBoss，除了方法切点，它们还提供了字段和构造器接入点。
Spring缺少对字段连接点的支持，无法让创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，就无法在bean创建时应用通知。
但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么可以利用Aspect来补充Spring AOP的功能。

### 操作术语

* Joinpoint:连接点，被拦截到的点，在spring中，指的是方法，spring只支持方法类型的拦截点
* Pointcut：切入点，要对哪些连接点进行拦截的定义
* Advice：通知/增强，拦截到连接点所要做的事
    - 前置通知：在方法之前执行
    - 后置通知：在方法之后执行
    - 异常通知：方法出现异常执行
    - 最终通知：后置之后执行
    - 环绕通知：在方法之前和之后执行
* Aspect：切面，是切入点和通知的结合的过程
* Introduction：引介，在运行期动态的添加的方法和Field
* Target：目标对象，代理的目标对象
* Weaving：织入，把增强应用到目标的过程
* Proxy：代理，结果代理类

### 定义切面

Spring借助AspectJ的切点表达式语言来定义Spring切面：

| AspectJ指示器 |                                             描述                                             |
|---------------|----------------------------------------------------------------------------------------------|
| arg()         | 限制连接点匹配参数为指定类型的执行方法                                                       |
| @args()       | 限制连接点匹配参数由指定注解标注的执行方法                                                   |
| execution()   | 用于匹配是连接点的执行方法                                                                   |
| this()        | 限制连接点匹配AOP代理的bean引用为指定类型的类                                                |
| target        | 限制连接点匹配目标对象为指定类型的类                                                         |
| @target()     | 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解                           |
| within()      | 限制连接点匹配指定的类型                                                                     |
| @within()     | 限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里） |
| @annotation   | 限定匹配带有指定注解的连接点                                                                 |

![aspectj-perform](/static/img/spring/aspectj-perform.png "aspectj-perform")

![aspectj-within](/static/img/spring/aspectj-within.png "aspectj-within")

使用了“&&”操作符形成与（and）关系，可以使用“`||`”操作符来标识或（or）关系，而使用“!”操作符来标识非（not）操作。  
因为“&”在XML中有特殊含义，所以在Spring的XML配置里面描述切点时，可以使用and来代替“&&”。同样，or和not可以分别用来代替“`||`”和“!”。

Spring还引入了一个新的bean()指示器，它允许我们在切点表达式中使用bean的ID来标识bean。

```
execution(* com.xpress.service.*.do(..) and !bean(excludeBeanId))
```

#### execution常用写法

> execution(<访问修饰符>?<返回类型><方法名>(<参数>)<异常>)

* 匹配所有public方法：execution(public * *(..))
* 匹配指定包下所有类方法,不包含子包：execution(* com.xpress.dao.*(..))
* 匹配指定包下所有类方法,包含子包：execution(* com.xpress.dao..*(..))
* 匹配指定类的所有方法：execution(* com.xpress.dao.UserService.*(..))
* 匹配实现特定接口所有类方法：execution(* com.xpress.dao.UserService+.*(..))
* 匹配所有save开头方法：execution(* save*(..))
* 匹配所有方法：execution(* *.*(..))
* 匹配返回值：execution(java.lang.String *.*(..)) or execution(!void *.*(..))
* 匹配参数：execution(* *.*(java.lang.String,..))


### AOP操作

Spring 2.0以后AOP使用AspectJ实现，AspectJ是一个切面框架，它有一个专门的编译器生成遵循java字节编码规范的class文件

* 基于AspectJ的xml方式
* 基于AspectJ的注解方式

#### 基于AspectJ的xml方式

##### 配置

Spring的AOP配置元素能够以非侵入性的方式声明切面：

|      AOP配置元素 用       |                                   途                                   |
|---------------------------|------------------------------------------------------------------------|
| `<aop:advisor>`           | 定义AOP通知器                                                          |
| `<aop:after>`             | 定义AOP后置通知（不管被通知的方法是否执行成功）                        |
| `<aop:after-returning>`   | 定义AOP返回通知                                                        |
| `<aop:after-throwing>`    | 定义AOP异常通知                                                        |
| `<aop:around>`            | 定义AOP环绕通知                                                        |
| `<aop:aspect>`            | 定义一个切面                                                           |
| `<aop:aspectj-autoproxy>` | 启用@AspectJ注解驱动的切面                                             |
| `<aop:before>`            | 定义一个AOP前置通知                                                    |
| `<aop:config>`            | 顶层的AOP配置元素。大多数的`<aop:*>`元素必须包含在`<aop:config>`元素内 |


引入aop schema

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"> <!-- bean definitions here -->
<!-- 定义advice，实现标记接口org.aopalliance.aop.Advice -->
<bean name="myAdvice" class="com.xpress.advice.MyAdvice"/>
<aop:config>
    <!-- 配置切入点 -->
    <aop:pointcut id="myPointcut"
                  expression="execution(* com.xpress.dao..*(..)) or execution(* com.xpress.dao..*(..))"/>
    <!-- 配置切面 -->
    <aop:aspect ref="myAdvice">
        <!-- 指定切入点和增强的方法 -->
        <aop:before method="before" pointcut-ref="myPointcut"/>
        <!-- 返回之后执行，是否有异常都执行 -->
        <aop:after method="after" pointcut-ref="myPointcut"/>
        <!-- 返回之后执行 -->
        <aop:after-returning method="afterReturn" pointcut-ref="myPointcut"/>
        <!-- 环绕执行 -->
        <aop:around method="around" pointcut-ref="myPointcut"/>
        <!-- 抛出异常后执行 -->
        <aop:after-throwing method="afterThrowing" pointcut-ref="myPointcut"/>
    </aop:aspect>
    <!-- 参数处理 -->
    <bean id="trackCounter" class="com.xpress.aspect.TrackCounter"/>
    <aop:aspect ref="trackCounter">
        <aop:pointcut id="trackPlayed" expression="execution(* com.xpress.CompactDisc.playTrack(list) and args(trackNumber))"/>
        <!-- 指定切入点和增强的方法 -->
        <aop:after method="countTrack" pointcut-ref="trackPlayed"/>
    </aop:aspect>
    <!-- 加入新功能 -->
    <aop:aspect>
        <aop:declare-parents types-matching="com.xpress.Performance+" implement-interface="com.xpress.Encoreable"
            default-impl="com.xpress.aspect.DefaultEncoreableImpl" />
        <!-- default-impl替代 -->
        <!-- delegate-ref="beanId" -->
    </aop:aspect>
</aop:config>
</beans>
```

![xml-aop](/static/img/spring/xml-aop.png "xml-aop")

##### 执行顺序

1. before方法
2. around的target方法前部分
3. target方法
4. around的target方法后部分
5. after-return方法
6. after方法

#### 基于AspectJ的注解方式

* @Before
* @AfterReturning
* @Around
* @AfterThrowing
* @After

开启AspectJ注解

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!-- 开启注解 -->
    <aop:aspectj-autoproxy/>
    <!-- 声明target -->
    <bean id="userDao" class="com.xpress.dao.UserDao"/>
    <!-- 声明切面 -->
    <bean id="myAdvice" class="com.xpress.advice.MyAdvice"/>
</beans>
```

```java
@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class MyAdviceConfig {
    @Bean
    public MyAdvice myAdvice(){
        return new MyAdvice();
    }
}
```
编写切面

```java
@Aspect
public class MyAdvice {
    @Before("execution(* com.xpress.dao..*(..)) || execution(* com.xpress.service..*(..))")
    public void before() {
        System.out.println("before..");
    }
}
```

pointcut形式

```xml
<context:component-scan base-package="com.xpress.service,com.xpress.dao,com.xpress.model,com.xpress.advice"/>
<aop:aspectj-autoproxy/>
```

```java
@Aspect
@Component //加载类，全部使用注解形式
public class AnnounceAdvice {
    //声明一个切入点
    @Pointcut("execution(* com.xpress.service..*(..))")
    private void pointcut() {
    }
    @Before("pointcut() && args(name)")// 获取参数，只会匹配有参数的方法
    public void doAccessCheck(String name) {
        System.out.println("前置通知:" + name);
    }
    @AfterReturning(pointcut = "pointcut()", returning = "result")// 获取返回值，只会匹配有返回值的方法
    public void doAfterReturning(String result) {
        System.out.println("后置通知:" + result);
    }
    @After("pointcut()")
    public void doAfter() {
        System.out.println("最终通知");
    }
    @AfterThrowing(pointcut = "pointcut()", throwing = "e")// 获取异常
    public void doAfterThrowing(Exception e) {
        System.out.println("例外通知:" + e);
    }
    // 你可以不调用proceed()方法，从而阻塞对被通知方法的访问，与之类似，你也可以在通知中对它进行多次调用。
    // 要这样做的一个场景就是实现重试逻辑，也就是在被通知方法失败后，进行重复尝试。
    @Around("pointcut()")
    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("进入方法");
        Object result = pjp.proceed();
        System.out.println("退出方法");
        return result;
    }
}
```

#### 处理参数

```java
public class Player {
    private List<String> musics;
    public void setMusics(List<String> musics) {
        this.musics = musics;
    }
    public void play(int index) {
        System.out.println("playing " + musics.get(index));
    }

}
```

```java
@Aspect
public class PlayerCounter {
    private Map<Integer, Integer> count = new HashMap<>();
    public Map<Integer, Integer> getCount() {
        return count;
    }
    @Pointcut("execution(* com.xpress.Player..*(int)) && args(index)")
    public void playCount(int index) {
    }
    @After(value = "playCount(index)", argNames = "index")
    public void saveCount(int index) {
        Integer value = 1;
        if (count.containsKey(index)) {
            value = count.get(index) + 1;
        }
        count.put(index, value);
    }
}
```

```java
@Configuration
@EnableAspectJAutoProxy
public class PlayerConfig {
    @Bean
    public Player player() {
        ArrayList<String> musics = new ArrayList<>();
        musics.add("music 0");
        musics.add("music 1");
        musics.add("music 2");
        musics.add("music 3");
        musics.add("music 4");
        musics.add("music 5");
        Player player = new Player();
        player.setMusics(musics);
        return player;
    }
    @Bean
    public PlayerCounter playerCounter() {
        return new PlayerCounter();
    }
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {PlayerConfig.class})
public class AspectjTest {
    @Autowired
    private Player player;
    @Autowired
    private PlayerCounter playerCounter;
    @Test
    public void testAspectJ() {
        player.play(1);
        player.play(1);
        player.play(2);
        player.play(3);
        player.play(5);
        player.play(2);
        System.out.println(playerCounter.getCount());
    }
}

```

#### 功能增强

```java
public interface Encoreable {
    void performEncore();
}
public class DefaultEncoreableImpl implements Encoreable {
    @Override
    public void performEncore() {
        System.out.println("perform....");
    }
}
```

```java
@Aspect
public class EncoreableIntroducer {
    @DeclareParents(value = "com.xpress.Player+", defaultImpl = DefaultEncoreableImpl.class)
    private Encoreable encoreable;
}
```

```java
@Around(value = "playCount(index)", argNames = "pjp,index")
public Object testEncore(ProceedingJoinPoint pjp, int index) {
    if (pjp.getThis() instanceof Encoreable) {// 可以在类似地方判断代理类是个增强后的实现类
        ((Encoreable) pjp.getThis()).performEncore();
    }
    //...
}
```

@DeclareParents注解由三部分组成：

* value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现Performance的类型。（标记符后面的+号表示是Performance的所有子类型，而不是Performance本身。）
* defaultImpl属性指定了为引入功能提供实现的类。在这里，我们指定的是DefaultEncoreable提供实现。
* @DeclareParents注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是Encoreable接口。

## 数据访问与集成

### 数据源配置

参看JDBC的数据源部分

#### jdbc.properties

```xml
<!-- 指定配置文件位置 -->
<context:property-placeholder location="classpath:jdbc.properties"/>
<!--datasource-->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
    <!-- 连接池启动时的初始值 -->
    <property name="initialSize" value="${jdbc.initialSize}"/>
    <!-- 连接池的最大值 -->
    <property name="maxActive" value="${jdbc.maxActive}"/>
    <!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 -->
    <property name="maxIdle" value="${jdbc.maxIdle}"/>
    <!-- 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 -->
    <property name="minIdle" value="${jdbc.minIdle}"/>
</bean>
<!--name-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="datasource"/>
</bean>
<!--dao-->
<bean id="userDao" class="com.xpress.dao.UserDao">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
</bean>
```

注入properties值

```java
@Value("${redis.creative.tag.rel}")
private static String CREATIVE_TAG_PREFIX;
@Value("${redis.creative.classify.rel}")
private static String CREATIVE_CLASSIFY_PREFIX;
```

#### JNDI

jndi方式配置数据源交个容器管理，如tomcat的context.xml中配置连接池属性

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:jee="http://www.springframework.org/schema/jee"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd 
        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd"
       default-lazy-init="true">

    <jee:jndi-lookup id="datasourceJndi" jndi-name="tomcatJndi" resource-ref="true"/>
    <bean id="dataSourceJndi" class="org.springframework.jndi.JndiObjectFactoryBean">
        <!--关联datasourceJndi配置-->
        <property name="jndiName" ref="datasourceJndi"/>
        <!--通过name直接配置-->
        <property name="jndiName" value="tomcatJndi"/>
    </bean>
</beans>
```

### ORM

随着应用程序变得越来越复杂，对持久化的需求也变得更复杂：

* 延迟加载（Lazy loading）：随着我们的对象关系变得越来越复杂，有时候我们并不希望立即获取完整的对象间关系。
* 预先抓取（Eager fetching）：这与延迟加载是相对的。借助于预先抓取，我们可以使用一个查询获取完整的关联对象。
* 级联（Cascading）：有时，更改数据库中的表会同时修改其他表。

Spring对ORM框架的支持提供了与这些框架的集成点以及一些附加的服务：

* 支持集成Spring声明式事务
* 透明的异常处理
* 线程安全的、轻量级的模板类
* DAO支持类
* 资源管理

#### Hibernate

Spring3.1以后hibernate4包下，支持xml和注解

```java
import org.springframework.orm.hibernate4.HibernateTransactionManager;
import org.springframework.orm.hibernate4.LocalSessionFactoryBean;
@Bean
public SessionFactory sessionFactoryBean() {
    try {
        LocalSessionFactoryBean localSessionFactoryBean = new LocalSessionFactoryBean();
        localSessionFactoryBean.setDataSource(dataSource());
        localSessionFactoryBean.setPackagesToScan("spittr.domain");
        Properties props = new Properties();
        props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
        localSessionFactoryBean.setHibernateProperties(props);
        localSessionFactoryBean.afterPropertiesSet();
        return localSessionFactoryBean.getObject();
    } catch (IOException e) {
        return null;
    }
}
```

```java
@Repository
public class HibernateSpittleRepository implements SpittleRepository {
    private SessionFactory sessionFactory;
    @Inject
    public HibernateSpittleRepository(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }
    private Session currentSession() {
        return sessionFactory.getCurrentSession();//<co id="co_RetrieveCurrentSession"/>
    }
    public long count() {
        return findAll().size(); 
    }
    public List<Spittle> findRecent() {
        return findRecent(10);
    }
    public List<Spittle> findRecent(int count) {
        return (List<Spittle>) spittleCriteria()
                .setMaxResults(count)
                .list();
    }
    public Spittle findOne(long id) {
        return (Spittle) currentSession().get(Spittle.class, id);
    }
    public Spittle save(Spittle spittle) {
        Serializable id = currentSession().save(spittle);
        return new Spittle(
            (Long) id, 
            spittle.getSpitter(), 
            spittle.getMessage(), 
            spittle.getPostedTime());
    }
    public List<Spittle> findBySpitterId(long spitterId) {
        return spittleCriteria()
                .add(Restrictions.eq("spitter.id", spitterId))
                .list();
    }
    public void delete(long id) {
        currentSession().delete(findOne(id));
    }
    public List<Spittle> findAll() {
        return (List<Spittle>) spittleCriteria().list(); 
    }
    private Criteria spittleCriteria() {
        return currentSession() 
                .createCriteria(Spittle.class)
                .addOrder(Order.desc("postedTime"));
    }
}
```

PersistenceExceptionTranslationPostProcessor是一个bean 后置处理器（bean post-processor），它会在所有拥有@Repository注解的类上添加一个通知器（advisor），这样就会捕获任何平台相关的异常并以Spring非检查型数据访问异常的形式重新抛出。

```java
@Bean
public BeanPostProcessor persistenceTranslation() {
    return new PersistenceExceptionTranslationPostProcessor();
}
```

#### Java持久化API

Java持久化API（Java Persistence API，JPA）诞生在EJB 2实体Bean的废墟之上，并成为下一代Java持久化标准。JPA是基于POJO的持久化机制，它从Hibernate和Java数据对象（Java Data Object，JDO）上借鉴了很多理念并加入了Java 5注解的特性。

##### 配置实体管理器工厂

基于JPA的应用程序需要使用EntityManagerFactory的实现类来获取EntityManager实例。JPA定义了两种类型的实体管理器：

* 应用程序管理类型（Application-managed）：当应用程序向实体管理器工厂直接请求实体管理器时，工厂会创建一个实体管理器。在这种模式下，程序要负责打开或关闭实体管理器并在事务中对其进行控制。这种方式的实体管理器适合于不运行在Java EE容器中的独立应用程序。
* 容器管理类型（Container-managed）：实体管理器由Java EE创建和管理。应用程序根本不与实体管理器工厂打交道。相反，实体管理器直接通过注入或JNDI来获取。容器负责配置实体管理器工厂。这种类型的实体管理器最适用于Java EE容器，在这种情况下会希望在persistence.xml指定的JPA配置之外保持一些自己对JPA的控制。

应用程序管理类型的EntityManager是由EntityManagerFactory创建的，

* 应用程序管理类型的EntityManagerFactory是通过PersistenceProvider的createEntityManagerFactory()方法得到的
* 与此相对，容器管理类型的EntityManagerFactory是通过PersistenceProvider的createContainerEntityManagerFactory()方法获得的

**配置应用程序管理类型的JPA**

对于应用程序管理类型的实体管理器工厂来说，它绝大部分配置信息来源于一个名为persistence.xml的配置文件。这个文件必须位于类路径下的META-INF目录下。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
             version="2.0">
    <persistence-unit name="CasPersistence" transaction-type="RESOURCE_LOCAL">
        <class>org.jasig.cas.services.AbstractRegisteredService</class>
        <class>org.jasig.cas.services.RegexRegisteredService</class>
        <class>org.jasig.cas.services.RegisteredServiceImpl</class>
        <class>org.jasig.cas.ticket.TicketGrantingTicketImpl</class>
        <class>org.jasig.cas.ticket.ServiceTicketImpl</class>
        <class>org.jasig.cas.ticket.registry.support.JpaLockingStrategy$Lock</class>
    </persistence-unit>
    <persistence-unit name="spittrPU">
        <class>spittr.domain.Spitter</class>
        <properties>
            <property name="toplink.jdbc.driver" value="org.h2.Driver"/>
            <property name="toplink.jdbc.url" value="jdbc:h2:tcp://localhost/~/spittr"/>
            <property name="toplink.jdbc.username" value="sa"/>
            <property name="toplink.jdbc.password" value="sa"/>
        </properties>
    </persistence-unit>
</persistence>
```

```java
@Bean
public LocalEntityManagerFactoryBean entityManagerFactoryBean() {
    LocalEntityManagerFactoryBean localEntityManagerFactoryBean = new LocalEntityManagerFactoryBean();
    // 赋给persistenceUnitName属性的值就是persistence.xml中持久化单元的名称。
    localEntityManagerFactoryBean.setPersistenceUnitName("spittrPU");
    return localEntityManagerFactoryBean;
}
```

创建应用程序管理类型的EntityManagerFactory都是在persistence.xml中进行的，而这正是应用程序管理的本意。在应用程序管理的场景下（不考虑Spring时），完全由应用程序本身来负责获取EntityManagerFactory，这是通过JPA实现的PersistenceProvider做到的。如果每次请求EntityManagerFactory时都需要定义持久化单元，那代码将会迅速膨胀。通过将其配置在persistence.xml中，JPA就能够在这个特定的位置查找持久化单元定义了。

但借助于Spring对JPA的支持，我们不再需要直接处理PersistenceProvider了。

**使用容器管理类型的JPA**

```java
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactoryBean(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
    LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
    // 尽管数据源还可以在persistence.xml中进行配置，但是这个属性指定的数据源具有更高的优先级。
    entityManagerFactoryBean.setDataSource(dataSource);
    entityManagerFactoryBean.setPersistenceUnitName("spittrPU");
    entityManagerFactoryBean.setJpaVendorAdapter(jpaVendorAdapter);
    entityManagerFactoryBean.setPackagesToScan("spittr.domain");// 配置包扫描
    return entityManagerFactoryBean;
    // 上面的配置可以取代persistence.xml的作用
}
@Bean
public JpaVendorAdapter jpaVendorAdapter() {
    HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
    adapter.setDatabase(Database.H2);
    adapter.setShowSql(true);
    adapter.setGenerateDdl(false);
    adapter.setDatabasePlatform("org.hibernate.dialect.H2Dialect");
    return adapter;
}
```

jpaVendorAdapter属性用于指明所使用的是哪一个厂商的JPA实现。Spring提供了多个JPA厂商适配器：

* EclipseLinkJpaVendorAdapter
* HibernateJpaVendorAdapter
* OpenJpaVendorAdapter
* TopLinkJpaVendorAdapter（在Spring 3.1版本中，已经将其废弃了）

Hibernate的JPA适配器支持多种数据库，可以通过其database属性配置使用哪个数据库：

|      数据库平台      | 属性database的值 |
|----------------------|------------------|
| IBM DB2              | DB2              |
| Apache Derby         | DERBY            |
| H2                   | H2               |
| Hypersonic           | HSQL             |
| Informix             | INFORMIX         |
| MySQL                | MYSQL            |
| Oracle               | ORACLE           |
| PostgresQL           | POSTGRESQL       |
| Microsoft SQL Server | SQLSERVER        |
| Sybase               | SYBASE           |

**从JNDI获取实体管理器工厂**

```xml
<jee:jndi-lookup jndi-name="persistence/spittrPU" id="entityManagerFactoryBean"/>
```

```java
@Bean
JndiObjectFactoryBean entityManagerFactoryBean() {
    JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();
    jndiObjectFactoryBean.setJndiName("persistence/spittrPU");
    return jndiObjectFactoryBean;
}
```

##### 基于JPA的Repository

```java
@Repository
@Transactional
public class JpaSpittrRepository {
    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;
    public void addSpittr(Spitter spitter) {
        entityManagerFactory.createEntityManager().persist(spitter);
    }
    public Spitter getSpittrById(long id) {
        return entityManagerFactory.createEntityManager().find(Spitter.class, id);
    }
    public void saveSpittr(Spitter spitter) {
        entityManagerFactory.createEntityManager().merge(spitter);
    }
}
```

问题在于每个方法都会调用createEntityManager()。除了引入易出错的重复代码以外，这还意味着每次调用Repository的方法时，都会创建一个新的EntityManager。这种复杂性源于事务。

这里的问题在于EntityManager并不是线程安全的，一般来讲并不适合注入到像Repository这样共享的单例bean中。但是，这并不意味着我们没有办法要求注入EntityManager。

```java
@Repository
@Transactional
public class JpaSpitterRepository implements SpitterRepository {
    @PersistenceContext
    private EntityManager entityManager;
    public long count() {
        return findAll().size();
    }
    public Spitter save(Spitter spitter) {
        entityManager.persist(spitter);
        return spitter;
    }
    public Spitter findOne(long id) {
        return entityManager.find(Spitter.class, id);
    }
    public Spitter findByUsername(String username) {        
        return (Spitter) entityManager.createQuery("select s from Spitter s where s.username=?").setParameter(1, username).getSingleResult();
    }
    public List<Spitter> findAll() {
        return (List<Spitter>) entityManager.createQuery("select s from Spitter s").getResultList();
    }
}
```

@PersistenceContext并不会真正注入EntityManager——至少，精确来讲不是这样的。它没有将真正的EntityManager设置给Repository，而是给了它一个EntityManager的代理。真正的EntityManager是与当前事务相关联的那一个，如果不存在这样的EntityManager的话，就会创建一个新的。这样的话，我们就能始终以线程安全的方式使用实体管理器。

@PersistenceUnit和@PersistenceContext并不是Spring的注解，它们是由JPA规范提供的。为了让Spring理解这些注解，并注入EntityManager Factory或EntityManager，我们必须要配置Spring的Persistence-AnnotationBeanPostProcessor。如果你已经使用了`<context:annotation-config>`或`<context:component-scan>`，那么你就不必再担心了，因为这些配置元素会自动注册PersistenceAnnotationBeanPostProcessor bean。否则的话，我们需要显式地注册这个bean：

```java
@Bean
public BeanPostProcessor persistenceTranslation() {
    return new PersistenceAnnotationBeanPostProcessor();
}
```

#### 借助Spring Data实现自动化的JPA Repository

```java
@Configuration
@EnableJpaRepositories(basePackages = "spittr.db")
public class JpaConfig {
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">
       <!-- 扫描带有Component注解的类 -->
    <jpa:repositories base-package="spittr.db"/>
</beans>
```

```java
public interface SpittleRepository extends JpaRepository<Spittle, Long>{
}
```

SpitterRepository接口，它扩展自JpaRepository，而JpaRepository又扩展自Repository标记接口（虽然是间接的）。因此，SpitterRepository就传递性地扩展了Repository接口，也就是Repository扫描时所要查找的接口。当Spring Data找到它后，就会创建SpitterRepository的实现类，其中包含了继承自JpaRepository、PagingAndSortingRepository和CrudRepository的18个方法。

##### 自定义查询方法

```java
public interface SpittleRepository extends JpaRepository<Spittle, Long> {
    List<Spittle> findBySpitterId(long spitterId);
}
```

当创建Repository实现的时候，Spring Data会检查Repository接口的所有方法，解析方法的名称，并基于被持久化的对象来试图推测方法的目的。本质上，Spring Data定义了一组小型的领域特定语言（domain-specific language ，DSL），在这里，持久化的细节都是通过Repository方法的签名来描述的。

![AutoJPA](/static/img/spring/AutoJPA.png "AutoJPA")

* Spring Data允许在方法名中使用四种动词：get、read、find和count。
    - 其中，动词get、read和find是同义的，这三个动词对应的Repository方法都会查询数据并返回对象。而动词count则会返回匹配对象的数量，而不是对象本身。
* 对于大部分场景来说，主题会被省略掉。要查询的对象类型是通过如何参数化JpaRepository接口来确定的，而不是方法名称中的主题。
    - readByFirstnameOrLastName
* 如果主题的名称以Distinct开头的话，那么在生成查询的时候会确保所返回结果集中不包含重复记录。
* 在断言中，会有一个或多个限制结果的条件。
    - IsAfter、After、IsGreaterThan、GreaterThan
    - IsGreaterThanEqual、GreaterThanEqual
    - IsBefore、Before、IsLessThan、LessThan
    - IsLessThanEqual、LessThanEqual
    - IsBetween、Between
    - IsNull、Null
    - IsNotNull、NotNull
    - IsIn、In
    - IsNotIn、NotIn
    - IsStartingWith、StartingWith、StartsWith
    - IsEndingWith、EndingWith、EndsWith
    - IsContaining、Containing、Contains
    - IsLike、Like
    - IsNotLike、NotLike
    - IsTrue、True
    - IsFalse、False
    - Is、Equals
    - IsNot、Not
* 要对比的属性值就是方法的参数。参数的名称是无关紧要的，但是它们的顺序必须要与方法名称中的操作符相匹配。
* 要处理String类型的属性时，条件中可能还会包含IgnoringCase或IgnoresCase，作为IgnoringCase/IgnoresCase的替代方案，我们还可以在所有条件的后面添加AllIgnoringCase或AllIgnoresCase
    - readByFirstnameOrLastNameIgnoresCase
    - readByFirstnameOrLastNameAllIgnoresCase
* 我们还可以在方法名称的结尾处添加OrderBy，实现结果集排序。如果要根据多个属性排序的话，只需将其依序添加到OrderBy中即可。
    - readByFirstnameOrLastNameOrderByLastnameAsc
    - readByFirstnameOrLastNameOrderByLastnameAscFirstnameDesc
* 条件部分是通过And或者Or进行分割的。
* 其他符合规范的例子
    - findPetsByBreedIn(List<String> breed)
    - countProductsByDiscontinuedTrue()
    - findByShippingDateBetween(Date start,Date end)

##### 声明自定义查询(@Query)

@Query标注使用了HQL(Hibernate Query Language)进行查询

```java
public interface SpittleRepository extends JpaRepository<Spittle, Long>, SpittleRepositoryCustom {
    @Query("select s from Spittle s where tittle like '%#{keywords}%'")
    List<Spittle> findByKeywords(String keywords);
}
```

```java
public interface GenericDao<T> extends JpaRepository<T, ID> {
    @Query("select t from #{#entityName} t where t.id= ?1")
    public T findById(Long id);
}
```

##### 混合自定义的功能

当Spring Data JPA为Repository接口生成实现的时候，它还会查找名字与接口相同，并且添加了Impl后缀的一个类。如果这个类存在的话，Spring Data JPA将会把它的方法与Spring Data JPA所生成的方法合并在一起。

```java
public class SpittleRepositoryImpl implements SpittleRepositoryCustom {
    @PersistenceContext
    private EntityManager entityManager;
    @Override
    public List<Spittle> findRecent() {
        return findRecent(10);
    }
    @Override
    public List<Spittle> findRecent(int count) {
        return (List<Spittle>) entityManager.createQuery("select s from Spittle s order by s.postedTime desc")
                .setMaxResults(count)
                .getResultList();
    }
}
```

我们还需要确保findRecent()方法会被声明在SpittleRepository接口中。要实现这一点，避免代码重复的简单方式就是修改SpittleRepository，让它扩展SpittleRepositoryCustom

Spring Data JPA将实现类与接口关联起来是基于接口的名称。但是，Impl后缀只是默认的做法，如果你想使用其他后缀的话，只需在配置@EnableJpaRepositories的时候，设置repositoryImplementationPostfix属性即可

```java
@EnableJpaRepositories(basePackages = "spittr.db",repositoryImplementationPostfix = "Helper")
```

在XML中使用`<jpa:repositories>`元素来配置Spring Data JPA的话，我们可以借助repository-impl-postfix属性指定后缀：

```xml
<jpa:repositories base-package="spittr.db" repository-impl-postfix="Helper"/>
```

#### Redis

##### 连接工厂

Spring Data Redis为四种Redis客户端实现提供了连接工厂：

* JedisConnectionFactory
* JredisConnectionFactory
* LettuceConnectionFactory
* SrpConnectionFactory

```java
@Bean
public RedisConnectionFactory redisCF() {
    JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory();
    jedisConnectionFactory.setHostName("127.0.0.1");
    jedisConnectionFactory.setPort(6379);
    jedisConnectionFactory.setPassword("53cr3t");
    return jedisConnectionFactory;
}
```

##### RedisTemplate

Spring Data Redis提供了两个模板：

* RedisTemplate
* StringRedisTemplate

RedisTemplate使用两个类型进行了参数化。第一个是key的类型，第二个是value的类型  
如果所使用的value和key都是String类型，那么可以考虑使用StringRedisTemplate来代替RedisTemplate

```java
@Bean
public RedisTemplate<String, Product> redisTemplate(RedisConnectionFactory cf) {
    RedisTemplate<String, Product> redis = new RedisTemplate<String, Product>();
    redis.setConnectionFactory(cf);
    return redis;
}
```

```java
@Bean
public StringRedisTemplate redisTemplate(RedisConnectionFactory cf) {
    return new StringRedisTemplate(cf);
}
```

RedisTemplate的很多功能是以子API的形式提供的，它们区分了单个值和集合值的场景：

|       方法       |         子API接口         |                          描述                          |
|------------------|---------------------------|--------------------------------------------------------|
| opsForValue()    | ValueOperations<K, V>     | 操作具有简单值的条目                                   |
| opsForList()     | ListOperations<K, V>      | 操作具有list值的条目                                   |
| opsForSet()      | SetOperations<K, V>       | 操作具有set值的条目                                    |
| opsForZSet()     | ZSetOperations<K, V>      | 操作具有ZSet值（排序的set）的条目                      |
| opsForHash()     | HashOperations<K, HK, HV> | 操作具有hash值的条目                                   |
| boundValueOps(K) | BoundValueOperations<K,V> | 以绑定指定key的方式，操作具有简单值的条目              |
| boundListOps(K)  | BoundListOperations<K,V>  | 以绑定指定key的方式，操作具有list值的条目              |
| boundSetOps(K)   | BoundSetOperations<K,V>   | 以绑定指定key的方式，操作具有set值的条目               |
| boundZSet(K)     | BoundZSetOperations<K,V>  | 以绑定指定key的方式，操作具有ZSet值（排序的set）的条目 |
| boundHashOps(K)  | BoundHashOperations<K,V>  | 以绑定指定key的方式，操作具有hash值的条目              |

```java
redisTemplate.opsForValue().set(product.getSku(), product);
Product found = redisTemplate.opsForValue().get(product.getSku());
redisTemplate.opsForList().rightPush("cart", product);
Product first = redisTemplate.opsForList().leftPop("cart");
Product last = redisTemplate.opsForList().rightPop("cart");
redisTemplate.opsForList().size("cart").longValue()
List<Product> products = redisTemplate.opsForList().range("cart", 2, 12);
redisTemplate.opsForSet().size("cart").longValue()
redisTemplate.opsForSet().add("cart1", product);
Set<Product> diff = redisTemplate.opsForSet().difference("cart1", "cart2");
Set<Product> union = redisTemplate.opsForSet().union("cart1", "cart2");
Set<Product> isect = redisTemplate.opsForSet().intersect("cart1", "cart2");
Product random = redisTemplate.opsForSet().randomMember("cart1");
```

绑定key操作

```java
BoundListOperations<String, Product> cart = redisTemplate.boundListOps("cart");
cart.rightPush(product);
cart.rightPush(product2);
cart.rightPush(product3);
```

**序列化器**

当某个条目保存到Redis key-value存储的时候，key和value都会使用Redis的序列化器（serializer）进行序列化。Spring Data Redis提供了多个这样的序列化器，包括：

* GenericToStringSerializer：使用Spring转换服务进行序列化
* JacksonJsonRedisSerializer：使用Jackson 1，将对象序列化为JSON
* Jackson2JsonRedisSerializer：使用Jackson 2，将对象序列化为JSON
* JdkSerializationRedisSerializer：使用Java序列化
* OxmSerializer：使用Spring O/X映射的编排器和解排器（marshaler和unmarshaler）实现序列化，用于XML序列化
* StringRedisSerializer：序列化String类型的key和value

这些序列化器都实现了RedisSerializer接口，如果其中没有符合需求的序列化器，那么你还可以自行创建。

* RedisTemplate会使用JdkSerializationRedisSerializer，这意味着key和value都会通过Java进行序列化。
* StringRedisTemplate默认会使用StringRedis-Serializer

自定义序列化器：

```java
@Bean
public RedisTemplate<String, Product> redisTemplate(RedisConnectionFactory cf) {
    RedisTemplate<String, Product> redisTemplate = new RedisTemplate<String, Product>();
    redisTemplate.setConnectionFactory(cf);
    redisTemplate.setKeySerializer(new StringRedisSerializer());
    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer<Product>(Product.class));
    return redisTemplate;
}

@Test
public void settingKeyAndValueSerializers() {
    // need a local version so we can tweak the serializer
    RedisTemplate<String, Product> redis = new RedisTemplate<String, Product>();
    redis.setConnectionFactory(cf);
    redis.setKeySerializer(new StringRedisSerializer());
    redis.setValueSerializer(new Jackson2JsonRedisSerializer<Product>(Product.class));
    redis.afterPropertiesSet(); // if this were declared as a bean, you wouldn't have to do this
    // ...
}
```

### 事务管理

#### TransactionManager

|                            事务管理器                            |                             说明                            |
|------------------------------------------------------------------|-------------------------------------------------------------|
| org.springframework.jdbc.datasource.DataSourcetransactionManager | 使用spring jdbc或ibatis进行持久化数据时                     |
| org.springframework.orm.hibernate5.HibernatetransactionManager   | 使用hibernate5.0版本进行持久化                              |
| org.springframework.orm.jpa.JpaTransactionManager                | 使用JPA进行持久化时使用                                     |
| org.springframework.orm.jdo.JdoTransactionManager                | 持久化机制是Jdo时                                           |
| org.springframework.transaction.jta.JtaTransactionManager        | 使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用 |

#### XML配置方式

```xml
<!--配置transactionManager事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="datasource"/>
</bean>
<!--配置advice-->
<tx:advice id="myTxAdvice">
    <tx:attributes>
        <tx:method name="get*" propagation="SUPPORTS"/>
        <tx:method name="delete*" propagation="REQUIRED"/>
        <tx:method name="update*" propagation="REQUIRED"/>
        <tx:method name="add*" propagation="REQUIRED"/>
        <tx:method name="*_FOR_NEW_TRANSACTION" propagation="REQUIRES_NEW"/>
    </tx:attributes>
</tx:advice>
<!--配置切面-->
<aop:config>
    <!-- 配置切入点 -->
    <aop:pointcut id="myTxPointcut" expression="execution(* com.xpress.service..*(..))"/>
    <!-- 配置切面 -->
    <aop:advisor advice-ref="myTxAdvice" pointcut-ref="myPointcut"/>
</aop:config>
```

#### 注解方式

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"
       default-lazy-init="true" default-autowire="byName">
    <!--配置transactionManager-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="datasource"/>
    </bean>
    <!-- 开启事务注解 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
</beans>
```

```java
// 添加事务控制注解
@Transactional(rollbackFor = ServiceException.class)
public class UserDao {
    private JdbcTemplate jdbcTemplate;
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    public void updateUser() {
        int n = jdbcTemplate.update("UPDATE users SET username = 'smith' WHERE id=2");
        System.out.println(n);
    }
}
```

##### @Transactional

* rollbackFor = ServiceException.class 指定回滚的异常类型
* noRollbackFor = NoRollbackException.class 指定不会滚的异常类型
* propagation = Propagation.REQUIRED 指定事务传播性
* readOnly = true 设置是否只读事务，只读事务只能读取
* timeout = 10000 事务超时时间 seconds
* isolation = Isolation.READ_COMMITTED 数据库的隔离级别

#### 事务控制

* 默认回滚RuntimeException，checked Exception不会回滚

##### 事务传播属性

* REQUIRED
    - 业务方法需要在一个事务中运行，如果方法运行时已经存在一个事务中，则加入到该事务，否则自己创建一个事务
* NOT_SUPPORTED
    - 声明方法不需要事务，如果方法没有关联到一个事务，容器不会为它开启事务，如果方法在一个事务中被调用，该事务会被挂起，方法执行结束后，原先的事务恢复执行
* REQUIRES_NEW
    - 不管是否存在事务，业务方法总会为自己发起一个新的事务，如果方法已经运行在一个事务中，则原有的事务会被挂起，新的事务会被创建，直到方法执行结束，新事务才算结束，原先的事务恢复执行
* MANDATORY
    - 业务方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务，如果业务方法没有在事务环境下调用，容器会抛出异常
* SUPPORTS
    - 如果业务方法在某个事务范围内被调用，则方法称为该事务的一部分，如果业务方法没有在事务范围内被调用，则方法在没有事务的环境下执行
* NEVER
    - 业务方法绝对不能在业务范围内执行，如果业务方法在某个事务中执行，容器会抛出异常
* NESTED
    - 如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动的事务，则按REQUIRED属性执行，它使用了单独的事务，这个事务拥有多个可回滚的保存点，内部事务回滚不会对外部事务造成影响，它只对DataSourceTransactionManager有效

## 缓存

### 启用缓存支持

```java
@Configuration
@EnableCaching
public class CachingConfig {
    @Bean
    public ConcurrentMapCacheManager cacheManager() {
        return new ConcurrentMapCacheManager();
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cache="http://www.springframework.org/schema/cache"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <cache:annotation-driven/>
    <bean id="cacheManager" class="org.springframework.cache.concurrent.ConcurrentMapCacheManager"/>
</beans>
```

其实在本质上，@EnableCaching和`<cache:annotation-driven>`的工作方式是相同的。它们都会创建一个切面（aspect）并触发Spring缓存注解的切点（pointcut）。根据所使用的注解以及缓存的状态，这个切面会从缓存中获取数据，将数据添加到缓存之中或者从缓存中移除某个值。

#### 配置缓存管理器

Spring 3.1内置了五个缓存管理器实现，如下所示：

* SimpleCacheManager
* NoOpCacheManager
* ConcurrentMapCacheManager
* CompositeCacheManager
* EhCacheCacheManager

Spring 3.2引入了另外一个缓存管理器，这个管理器可以用在基于JCache（JSR-107）的缓存提供商之中。除了核心的Spring框架，Spring Data又提供了两个缓存管理器：

* RedisCacheManager（来自于Spring Data Redis项目）
* GemfireCacheManager（来自于Spring Data GemFire项目）

**EhCache**

```java
@Configuration
@EnableCaching
public class CachingConfig {
    @Bean
    public EhCacheCacheManager cacheManager(CacheManager cacheManager) {
        return new EhCacheCacheManager(cacheManager);
    }
    @Bean
    public EhCacheManagerFactoryBean cacheManagerFactoryBean() {
        EhCacheManagerFactoryBean ehCacheFactoryBean = new EhCacheManagerFactoryBean();
        ehCacheFactoryBean.setConfigLocation(new ClassPathResource("spittr/cache/ehcache.xml"));
        return ehCacheFactoryBean;
    }
}
```

```xml
<ehcache>
  <cache name="spittleCache" maxBytesLocalHeap="50m" timeToLiveSeconds="100"/>
</ehcache>
```

**Redis**

```java
@Bean
public CacheManager cacheManager(RedisTemplate redisTemplate) {
    return new RedisCacheManager(redisTemplate);
}
@Bean
public RedisConnectionFactory redisConnectionFactory() {
    JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory();
    jedisConnectionFactory.setHostName("localhost");
    jedisConnectionFactory.setPort(6379);
    jedisConnectionFactory.setPassword("pass");
    return jedisConnectionFactory;
}
@Bean
public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
    RedisTemplate<String, String> redis = new RedisTemplate<>();
    redis.setConnectionFactory(redisConnectionFactory);
    return redis;
}
```

**使用多个缓存管理器**

```java
@Bean
public CacheManager cacheManager(net.sf.ehcache.CacheManager cm, javax.cache.CacheManager jm) {
    CompositeCacheManager compositeCacheManager = new CompositeCacheManager();
    List<CacheManager> cacheManagers = new ArrayList<>();
    cacheManagers.add(new JCacheCacheManager(jm));
    cacheManagers.add(new EhCacheCacheManager(cm));
    cacheManagers.add(new RedisCacheManager(redisTemplate(redisConnectionFactory())));
    compositeCacheManager.setCacheManagers(cacheManagers);
    return compositeCacheManager;
}
```

当查找缓存条目时，CompositeCacheManager首先会从JCacheCacheManager开始检查JCache实现，然后通过EhCacheCacheManager检查Ehcache，最后会使用RedisCacheManager来检查Redis，完成缓存条目的查找。

### 缓存注解

Spring提供了四个注解来声明缓存规则：

|     注解    |                                                                         描述                                                                         |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| @Cacheable  | 表明Spring在调用方法之前，首先应该在缓存中查找方法的返回值。如果这个值能够找到，就会返回缓存的值。否则的话，这个方法就会被调用，返回值会放到缓存之中 |
| @CachePut   | 表明Spring应该将方法的返回值放到缓存中。在方法的调用前并不会检查缓存，方法始终都会被调用                                                             |
| @CacheEvict | 表明Spring应该在缓存中清除一个或多个条目                                                                                                             |
| @Caching    | 这是一个分组的注解，能够同时应用多个其他的缓存注解                                                                                                   |

#### 填充缓存

* @Cacheable首先在缓存中查找条目，如果找到了匹配的条目，那么就不会对方法进行调用了。如果没有找到匹配的条目，方法会被调用并且返回值要放到缓存之中。
* @CachePut并不会在缓存中检查匹配的值，目标方法总是会被调用，并将返回值添加到缓存之中。

@Cacheable和@CachePut有一些共有的属性：

|    属性   |   类型   |                               描述                              |
|-----------|----------|-----------------------------------------------------------------|
| value     | String[] | 要使用的缓存名称                                                |
| condition | String   | SpEL表达式，如果得到的值是false的话，不会将缓存应用到方法调用上 |
| key       | String   | SpEL表达式，用来计算自定义的缓存key                             |
| unless    | String   | SpEL表达式，如果得到的值是true的话，返回值不会放到缓存之中      |

```java
public interface SpittleRepository {
    @Cacheable("spittleCache")
    Spittle findOne(long id);
}
```

当findOne()被调用时，缓存切面会拦截调用并在缓存中查找之前以名spittleCache存储的返回值。缓存的key是传递到findOne()方法中的id参数。

当为接口方法添加注解后，@Cacheable注解会被SpittleRepository的所有实现继承，这些实现类都会应用相同的缓存规则。

**计算缓存Key**

Spring提供了多个用来定义缓存规则的SpEL扩展：

|      表达式       |                          描述                          |
|-------------------|--------------------------------------------------------|
| #root.args        | 传递给缓存方法的参数，形式为数组                       |
| #root.caches      | 该方法执行时所对应的缓存，形式为数组                   |
| #root.target      | 目标对象                                               |
| #root.targetClass | 目标对象的类，是#root.target.class的简写形式           |
| #root.method      | 缓存方法                                               |
| #root.methodName  | 缓存方法的名字，是#root.method.name的简写形式          |
| #result           | 方法调用的返回值（不能用在@Cacheable注解上）           |
| #Argument         | 任意的方法参数名（如#argName）或参数索引（如#a0或#p0） |

```java
@CachePut(value="spittleCache", key="#result.id")
Spittle save(Spittle spittle);
```

**条件化缓存**

* unless属性只能阻止将对象放进缓存，但是在这个方法调用的时候，依然会去缓存中进行查找，如果找到了匹配的值，就会返回找到的值。
* 与之不同，如果condition的表达式计算结果为false，那么在这个方法调用的过程中，缓存是被禁用的。就是说，不会去缓存进行查找，同时返回值也不会放进缓存中。

```java
@Cacheable(value = "spittleCache", unless = "#result.message.contains('NoCache')")
void getSpittlePageable(int start, int end);
```

在一定的条件下，我们既不希望将值添加到缓存中，也不希望从缓存中获取数据。

```java
@Cacheable(value = "spittleCache", unless = "#result.message.contains('NoCache')", condition="#id >= 10")
void getSpittlePageable(int start, int end);
```
unless属性的表达式能够通过#result引用返回值。这是很有用的，这么做之所以可行是因为unless属性只有在缓存方法有返回值时才开始发挥作用。而condition肩负着在方法上禁用缓存的任务，因此它不能等到方法返回时再确定是否该关闭缓存。这意味着它的表达式必须要在进入方法时进行计算，所以我们不能通过#result引用返回值。

#### 移除缓存

@CacheEvict并不会往缓存中添加任何东西。相反，如果带有@CacheEvict注解的方法被调用的话，那么会有一个或更多的条目会在缓存中移除。

与@Cacheable和@CachePut不同，@CacheEvict能够应用在返回值为void的方法上，而@Cacheable和@CachePut需要非void的返回值，它将会作为放在缓存中的条目。因为@CacheEvict只是将条目从缓存中移除，因此它可以放在任意的方法上，甚至void方法。

```java
@CacheEvict(value = "spittleCache")
void delete(long id);
```

当remove()调用时，会从缓存中删除一个条目。被删除条目的key与传递进来的id参数的值相等。

@CacheEvict注解的属性，指定了哪些缓存条目应该被移除掉：

|       属性       |   类型   |                                               描述                                              |
|------------------|----------|-------------------------------------------------------------------------------------------------|
| value            | String[] | 要使用的缓存名称                                                                                |
| key              | String   | SpEL表达式，用来计算自定义的缓存key                                                             |
| condition        | String   | SpEL表达式，如果得到的值是false的话，缓存不会应用到方法调用上                                   |
| allEntries       | b oolean | 如果为true的话，特定缓存的所有条目都会被移除掉                                                  |
| beforeInvocation | b oolean | 如果为true的话，在方法调用之前移除条目。如果为false（默认值）的话，在方法成功调用之后再移除条目 |

### XML

Spring的cache命名空间提供了以XML方式配置缓存规则的元素：

|             元素            |                                      描述                                     |
|-----------------------------|-------------------------------------------------------------------------------|
| `<cache:annotation-driven>` | 启用注解驱动的缓存。等同于Java配置中的@EnableCaching                          |
| `<cache:advice>`            | 定义缓存通知（advice）。结合`<aop:advisor>`，将通知应用到切点上               |
| `<cache:caching>`           | 在缓存通知中，定义一组特定的缓存规则                                          |
| `<cache:cacheable>`         | 指明某个方法要进行缓存。等同于@Cacheable注解                                  |
| `<cache:cache-put>`         | 指明某个方法要填充缓存，但不会考虑缓存中是否已有匹配的值。等同于@CachePut注解 |
| `<cache:cache-evict>`       | 指明某个方法要从缓存中移除一个或多个条目，等同于@CacheEvict注解               |

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:cache="http://www.springframework.org/schema/cache"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">
    <cache:annotation-driven/>
    <bean id="cacheManager" class="org.springframework.cache.concurrent.ConcurrentMapCacheManager"/>
    <aop:config>
        <aop:advisor advice-ref="cacheAdvice" pointcut="execution(* spittr.db.SpitterRepository.*(..))"/>
    </aop:config>

    <cache:advice id="cacheAdvice" cache-manager="cacheManager">
        <cache:caching>
            <cache:cacheable cache="spittleCache" method="findRecent"/>
            <cache:cacheable cache="spittleCache" method="findOne"/>
            <cache:cacheable cache="spittleCache" method="findBySpittleId"/>
            <cache:cache-put cache="spittleCache" method="save" key="#result.id"/>
            <cache:cache-evict cache="spittleCache" method="remove"/>
        </cache:caching>
    </cache:advice>
</beans>
```

`<cache:caching>`有几个可以供`<cache:cacheable>`、`<cache:cache-put>`和`<cache:cache-evict>`共享的属性，包括：

* cache：指明要存储和获取值的缓存
* condition：SpEL表达式，如果计算得到的值为false，将会为这个方法禁用缓存
* key：SpEL表达式，用来得到缓存的key（默认为方法的参数）
* method：要缓存的方法名

`<cache:cacheable>`和`<cache:cache-put>`还有一个unless属性，可以为这个可选的属性指定一个SpEL表达式，如果这个表达式的计算结果为true，那么将会阻止将返回值放到缓存之中。

`<cache:cache-evict>`元素还有几个特有的属性：

* all-entries：如果是true的话，缓存中所有的条目都会被移除掉。如果是false的话，只有匹配key的条目才会被移除掉。
* before-invocation：如果是true的话，缓存条目将会在方法调用之前被移除掉。如果是false的话，方法调用之后才会移除缓存。

all-entries和before-invocation的默认值都是false。这意味着在使用`<cache:cache-evict>`元素且不配置这两个属性时，会在方法调用完成后只删除一个缓存条目。要删除的条目会通过默认的key（基于方法的参数）进行识别，当然也可以通过为名为key的属性设置一个SpEL表达式指定要删除的key。

## 乱码处理

配置CharacterEncodingFilter过滤器

```xml
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## i18n

```xml
<!-- 配置资源文件 -->
<!-- As an alternative to ResourceBundleMessageSource, 
     Spring provides a ReloadableResourceBundleMessageSource class. 
     This variant supports the same bundle file format but is more flexible 
     than the standard JDK based ResourceBundleMessageSource implementation. 
     In particular, it allows for reading files from any Spring resource location (not just from the classpath) 
     and supports hot reloading of bundle property files  -->
<bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name="basenames">
        <list>
            <!--xpress.properties
                xpress_en_US.properties
                xpress_zh_CN.properties-->
            <value>xpress</value>
            <!-- ReloadableResourceBundleMessageSource -->
            <!-- <value>classpath:xpress</value> -->
        </list>
    </property>
    <!--Set whether to use the message code as default message instead of throwing a NoSuchMessageException.-->
    <property name="useCodeAsDefaultMessage" value="true" />
</bean>
<!-- MessageSourceAccessor提供了省略Locale的调用方法 -->
<bean id="messageSourceAccessor" class="org.springframework.context.support.MessageSourceAccessor">
    <constructor-arg ref="messageSource" name="messageSource"/>
</bean>
```

```java
// 默认Locale
messageSource.getMessage("welcome", new Object[]{"admin", new Date()}, Locale.SIMPLIFIED_CHINESE);
new MessageSourceAccessor(messageSource).getMessage("welcome", new Object[]{"admin", new Date()});
// 当前ActionContext Locale
messageSource.getMessage("welcome", new Object[]{"admin", new Date()}, ActionContext.getContext().getLocale());
messageSourceAccessor.getMessage("welcome", new Object[]{"admin", new Date()}, ActionContext.getContext().getLocale());
```

## 事件发布及处理

spring event 可以简单实现业务解耦

Event handling in the `ApplicationContext` is provided through the `ApplicationEvent` class and `ApplicationListener` interface.

spring提供的默认事件

* ContextRefreshedEvent
* ContextStartedEvent
* ContextStoppedEvent
* ContextClosedEvent
* RequestHandledEvent

![event](/static/img/spring/event.png "event")

### 实现Spring事件发布

开启事务异步处理注解支持

```xml
<!-- 开启@AspectJ AOP代理 -->
<aop:aspectj-autoproxy/>
<!-- 任务调度器 -->
<task:scheduler id="scheduler" pool-size="10"/>
<!-- 任务执行器 -->
<task:executor id="executor" pool-size="10"/>
<!--开启注解调度支持 @Async @Scheduled-->
<task:annotation-driven executor="executor" scheduler="scheduler"/>
```

事件发布器实现接口ApplicationEventPublisherAware

```java
@Service("eventPublisherService")
public class EventPublisherServiceImpl implements EventPublisherService,ApplicationEventPublisherAware {
    private ApplicationEventPublisher applicationEventPublisher;

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {

        this.applicationEventPublisher = applicationEventPublisher;
    }

    public void executePublicEvent(ApplicationEvent event) {
        applicationEventPublisher.publishEvent(event);
    }
}
```

自定义事件

```java
public class MyEvent extends ApplicationEvent {
    private String eventCode;
    public MyEvent(Object source, String eventCode) {
        super(source);
        this.eventCode = eventCode;
    }
}
```

定义事件监听器

```java
@Component
public class MyEventListener implements ApplicationListener<MyEvent> {
    @Override
    @Async // 注解异步处理
    public void onApplicationEvent(MyEvent event) {
        System.out.println(event.getSource());// do something..
    }
}
//Spring 4.2以后
@EventListener(condition = "#event.shouldSendMsg")
public void afterRegisterSendMail(MessageEvent event) {
     mailService.send(event.getUser().getEmail(),"register successful");
}
```


### 异步

#### 全局异步

```xml
<!-- 任务执行器 -->
<task:executor id="executor" pool-size="10"/>
<!-- 名字必须是applicationEventMulticaster和messageSource是一样的，默认找这个名字的对象 -->
<!-- 名字必须是applicationEventMulticaster，因为AbstractApplicationContext默认找个 -->
<!-- 如果找不到就new一个，但不是异步调用而是同步调用 -->
<bean id="applicationEventMulticaster" class="org.springframework.context.event.SimpleApplicationEventMulticaster">
    <!-- 注入任务执行器 这样就实现了异步调用（缺点是全局的，要么全部异步，要么全部同步（删除这个属性即是同步））  -->
    <property name="taskExecutor" ref="executor"/>
</bean>
```

#### 非全局异步

见实现Spring事件发布部分，开启注解并根据@Async注解实现异步处理，非注解为同步处理

### 有序

实现SmartApplicationListener接口即可。  
或者使用@Order注解

### 事务控制

* 同步：同步会延用已经存在的事务控制
    - 在service中发布同步事件，事件处理中调用service，则在一个事务中处理
* 异步：分别开启不同的连接进行处理
    - 推荐开启第一个事务处理，结束后发布事件，防止在第一个事务中发布事件而事件执行时机不可预知第一个事务数据不能被事务处理读取的问题
    - 监控事务提交后处理事件

**监控事务提交后处理事件**

```java
@EventListener
public void afterRegisterSendMail(MessageEvent event) {
    // Spring 4.2 之前
    if (TransactionSynchronizationManager.isActualTransactionActive()) {
        TransactionSynchronizationManager.registerSynchronization(
                new TransactionSynchronizationAdapter() {
                    @Override
                    public void afterCommit() {
                        mailService.send(event);
                    }
                });
    } else {
        mailService.send(event);
    }
}
```

```java
// Spring 4.2 +
// BEFORE_COMMIT
// AFTER_COMMIT
// AFTER_ROLLBACK
// AFTER_COMPLETION
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void afterRegisterSendMail(MessageEvent event) {
    mailService.send(event);
}
```

## 框架整合

参看整合框架对应篇幅

------

*以上概念总结于传智播客Spring课程*