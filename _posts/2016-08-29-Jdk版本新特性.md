---
layout: post
title: Jdk版本新特性
tags: Java基础 Jvm
categories: Java
published: true
---

JDK各版本新特性总结

## JDK1.4

### NIO

## JDK 1.5

### 静态导入

* 被导入方法必须是静态的
* 如果有多个同名的静态方法，容易不知道使用谁?这个时候要使用，必须加前缀。由此可见，意义不大，所以一般不用，但是要能看懂。

```java
import static java.lang.Math.abs;
import static java.lang.Math.pow;
import static java.lang.Math.max;

//错误
//import static java.util.ArrayList.add;

public class test {
    public static void main(String[] args) {
        // System.out.println(java.lang.Math.abs(-100));
        // System.out.println(java.lang.Math.pow(2, 3));
        // System.out.println(java.lang.Math.max(20, 30));
        // 太复杂，我们就引入到import

        // System.out.println(Math.abs(-100));
        // System.out.println(Math.pow(2, 3));
        // System.out.println(Math.max(20, 30));
        // 太复杂，有更简单

//      System.out.println(abs(-100));
        System.out.println(java.lang.Math.abs(-100));
        System.out.println(pow(2, 3));
        System.out.println(max(20, 30));
    }
    
    public static void abs(String s){
        System.out.println(s);
    }
}
```

### 自动装箱、拆箱

```java
	Integer i = 1;//装箱
	int j = i;//拆箱
```

### switch可以使用枚举值

### 增强for循环

```java
public static int add(int x,int ...args) {
    int sum = x;
    for(int arg:args) {
        sum += arg;
    }
    return sum;
}
```

**注意**

* 集合变量可以是数组或实现了Iterable接口的集合类


### 可变参数

```java
public void game(int a,String ...args){
}
```

* 只能出现在参数列表的最后
* ...位于变量类型和变量名之间，前后有无空格都可以
    - `String...args`
    - `String ...args`
    - `String... args`
    - `String ... args`
* 这里的变量其实是一个数组，调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。
* 如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个
* Arrays.asList()虽然可以把数组转成集合，但是集合的长度不能改变。

```java
List<String> list = Arrays.asList("hello", "world", "java");
// UnsupportedOperationException
// list.add("javaee");
// UnsupportedOperationException
// list.remove(1);
```

### 枚举

枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。

**注意**

* 所有枚举类都是Enum的子类
* 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略
* 枚举类可以有构造器，但必须是private的，它默认的也是private的
* 枚举类也可以有抽象方法，但是枚举项必须重写该方法
* 枚举可以在switch语句中使用

```java
public enum Direction3 {
    FRONT("前") {
        @Override
        public void show() {
            System.out.println("前");
        }
    },
    BEHIND("后") {
        @Override
        public void show() {
            System.out.println("后");
        }
    },
    LEFT("左") {
        @Override
        public void show() {
            System.out.println("左");
        }
    },
    RIGHT("右") {
        @Override
        public void show() {
            System.out.println("右");
        }
    };

    private String name;

    private Direction3(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public abstract void show();
}
```

```java
Direction3.RIGHT.getClass().getName();// Direction3
```

#### 枚举的常用方法

```java
Direction d1 = Direction.FRONT;
Direction d2 = Direction.BEHIND;
Direction d3 = Direction.LEFT;
Direction d4 = Direction.RIGHT;

// int compareTo() 比较 根据编号 self.ordinal - other.ordinal
System.out.println(d1.compareTo(d1));

// String name() //获取枚举名称
System.out.println(d1.name());

// int ordinal() //获取编号
System.out.println(d1.ordinal());

// String toString() 默认返回枚举名称
System.out.println(d1.toString());

// <T> T valueOf(Class<T> type,String name) 通过name获取枚举对象
Direction d = Enum.valueOf(Direction.class, "FRONT");
System.out.println(d.getName());

// values() 遍历枚举对象
// 此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便
Direction[] dirs = Direction.values();
for (Direction d : dirs) {
    System.out.println(d);
    System.out.println(d.getName());
}
```

### 泛型

### 元数据

### Scanner类处理用户录入

### Lock


```java
// 定义票
private int tickets = 100;

// 定义锁对象
private Lock lock = new ReentrantLock();// ReentrantLock是Lock的实现类

@Override
public void run() {
    while (true) {
        try {
            // 加锁
            lock.lock();
            if (tickets > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()
                        + "正在出售第" + (tickets--) + "张票");
            }
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```

### 线程池

* public static ExecutorService newCachedThreadPool() 创建一个具有缓存功能的线程池
* public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用的，具有固定线程数的线程池
* public static ExecutorService newSingleThreadExecutor() 创建一个只有单线程的线程池，相当于上个方法的参数是1

### 注解

JDK默认提供的注解：

* Deprecated
* Override
* SuppressWarnings

### 元注解（注解的注解）

* @Retention 保留
    - RetetionPolicy.SOURCE java源文件
    - RetetionPolicy.CLASS class文件 (默认)
    - RetetionPolicy.RUNTIME 内存中的字节码
* @Target
    - ElementType.TYPE 类型 包括Class、Interface、Enum等的父,对类、接口和枚举等对象生效
    - ElementType.FIELD 成员变量
    - ElementType.METHOD 方法
    - ElementType.PARAMETER 参数
    - ElementType.CONSTRUCTOR 构造方法
    - ElementType.LOCAL_VARIABLE  局部变量
    - ElementType.ANNOTATION_TYPE 注解
    - ElementType.PACKAGE 包

### 注解属性

枚举的属性类型包括：基本数据类型，String，Class，枚举，其他注解，以及这些类型的数组。

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,ElementType.TYPE})
public @interface MyAnnotation {
    // 注解属性
    String color() default "blue"; //String类型并指定默认值
    String value();//特殊字段value
    int[] arrayAttr() default {3,4,4};//数组类型字段
    TrafficLamp lamp() default TrafficLamp.RED;//枚举类型
    MetaAnnotation annotationAttr() default @MetaAnnotation("test");//注解类型
    Class classValue() default String.class;//class类型
}
```

```java
public @interface MetaAnnotation {
    String value();
}
```

```java
public enum TrafficLamp{
    RED(30){
        public  TrafficLamp nextLamp(){
            return GREEN;
        }
    },
    GREEN(45){
        public  TrafficLamp nextLamp(){
            return YELLOW;
        }
    },
    YELLOW(5){
        public  TrafficLamp nextLamp(){
            return RED;
        }
    };
    public abstract TrafficLamp nextLamp();
    private int time;
    private TrafficLamp(int time){this.time = time;}
}
```

```java
@MyAnnotation(annotationAttr=@MetaAnnotation("test"),color="red",value="abc",arrayAttr=1)//数组类型只有一个值可以省略花括号
public class AnnotationTest {
    @MyAnnotation("xyz")//只有value字段可以省略字段名和等号
    public static void main(String[] args) throws Exception{
        if(AnnotationTest.class.isAnnotationPresent(MyAnnotation.class)){
            MyAnnotation annotation = (MyAnnotation)AnnotationTest.class.getAnnotation(MyAnnotation.class);
            System.out.println(annotation.color());// red
            System.out.println(annotation.value());// abc
            System.out.println(annotation.arrayAttr()[0]);// 1
            System.out.println(annotation.lamp().nextLamp().name());// GREEN
            System.out.println(annotation.annotationAttr().value());// test
            System.out.println(annotation.classValue().getName());// java.lang.String
        }
    }
}
```

**@Override、@SuppressWarnings和@Deprecated这三个注解的属性值分别是什么？**

@Override、@SuppressWarnings是SOURCE  
@Deprecated是RUNTIME，因为编译器拿到class文件加载到内存后才能检查是否已经过时，所以是RUNTIME

## JDK 1.6

* 

## JDK 1.7

### switch可以使用String

**switch语句的表达式可以是byte吗?可以是long吗?可以是String吗**

> 可以,不可以,JDK7以后可以

### 异常的多个catch合并

* 处理方式是一致的。(实际开发中，好多时候可能就是针对同类型的问题，给出同一个处理)
* 多个异常间必须是平级关系。

```java
// JDK7的处理方案
try {
    System.out.println(a / b);
    System.out.println(arr[3]);
} catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
    System.out.println("出问题了");
}
```

### try-with-resources 语句

**好处**

* 资源自动释放，不需要close()了
* 把需要关闭资源的部分都定义在这里就ok了
* 主要是流体系的对象是这个接口的子类(看JDK7的API)

```java
// try-with-resources 语句
// try(必须是java.lang.AutoCloseable的子类对象){…}

try {
    FileReader fr = new FileReader("a.txt");
    FileWriter fw = new FileWriter("b.txt");
    int ch = 0;
    while ((ch = fr.read()) != -1) {
        fw.write(ch);
    }
    fw.close();
    fr.close();
} catch (IOException e) {
    e.printStackTrace();
}

// 改进版的代码
try (FileReader fr = new FileReader("a.txt");
        FileWriter fw = new FileWriter("b.txt");) {
    int ch = 0;
    while ((ch = fr.read()) != -1) {
        fw.write(ch);
    }
} catch (IOException e) {
    e.printStackTrace();
}//自动释放资源 不用手动关闭
```

### NIO改进

* Path:与平台无关的路径。
* Paths:包含了返回Path的静态方法。
* Files:操作文件的工具类。提供了大量的方法

### 二进制的表现形式（二进制字面量）

JDK7开始，终于可以用二进制来表示整数（byte,short,int和long）。使用二进制字面量的好处是，可以使代码更容易被理解。语法非常简单，只要在二进制数值前面加 0b或者0B

```java
// 二进制字面量
int x = 0b100101;
```

### 用_分隔数据

为了增强对数值的阅读性，如我们经常把数据用逗号分隔一样。JDK7提供了_对数据分隔。

**注意**

* 不能出现在进制标识和数值之间
* 不能出现在数值开头和结尾
* 不能出现在小数点旁边


```java
// 数字字面量可以出现下划线
int y = 1_1123_1000;
// 不能出现在进制标识和数值之间
int z = 0x111_222;
// 不能出现在数值开头和结尾
int a = 0x11_22;
// 不能出现在小数点旁边
double d = 12.3_4;
```

### 泛型推断(菱形泛型)

泛型简化

```java
ArrayList<String> array = new ArrayList<>();
```

## JDK 1.8

### Lamba

### 接口中可以有方法实现

```java
interface Inter
{
        //抽象方法
        public abstract void show();
        
        //default方法
        public default void defaultPrint() 
        {
                System.out.println("defaultPrint 我爱林青霞");
        }

        //static方法
        public static void staticPrint()
        {
                System.out.println("staticPrint 我爱林青霞");
        }
}

//实现类
class InterImpl implements Inter
{
        public void show()
        {
                System.out.println("重写接口中的方法");
        }
}

//测试类
public class Demo01 
{
        public static void main(String[] args) 
        {
            //Inter.defaultPrint();  //非静态方法不能直接使用 
            Inter.staticPrint();
            
            Inter i = new InterImpl();
            i.defaultPrint();
            i.show();
        }
}
```
