---  
layout: post  
title: Java Idiom  
tags: JDK Idiom JavaSE  
categories: JavaSE  
published: true  
---  

来自Effective Java第二版的Java编程习惯用法

## 创建和销毁对象

* 何时以及如何创建对象
* 何时以及如何避免对象
* 如何确保他们能够适时销毁
* 如何管理对象销毁之前必须进行的各种清理动作

### 静态工厂方法替代构造函数

> 静态工厂方法并不直接对应设计模式中的工厂方法模式

**优势:**

1. 名称
    * 名称可以清楚表达目的而不是使用不同参数的构造函数区分
        - BigInteger.probablePrime()// 返回可能是素数
2. 避免创建不必要的重复对象
    * 重复使用不可变类或预先构造好的类，提升性能
        - Boolean.valueOf()
    * 实例受控，如不可变类和单例
3. 可以返回子类对象
    * API可以返回对象，同时又不会使对象的类变成共有的，使API简洁
        - Collections中返回同步集合、不可修改集合
    * 可以随参数返回不同子类实例
4. 创建参数化实例时更简洁
    * 泛型推断(Jdk1.7已支持)

**缺点:**

1. 类如果不含有共有的或者受保护的构造器，就不能被子类化
    * 如实现Collections Framework中类的子类
2. API文档中没有明确的标注
    * 使用注释标注可以使用静态工厂，同时使用标准命名
        - valueOf--实际上是类型转换方法
        - of--valueOf的简明代替
        - getInstance--通过方法参数描述，返回共享实例
        - newInstance--返回不同实例
        - getT--和getInstance一样，T表示返回的对象类型
        - newT--和newInstance一样，T表示返回的对象类型

### 遇到多个构造器参数时要考虑使用构造器(建造者模式)

> 静态工厂和构造器有共同局限性:不能很好的扩展到大量的可选在参数  
> 重叠构造器(多个参数不同的构造)虽然可行，但是参数多的时候客户端很难编写且不易阅读  
> 使用JavaBeans模式(新建实例后通过set方法设值)(可读性好)，这种方式使创建的实例不一致，不可控，可能导致线程问题

**优势:**

1. 可选参数可以通过setter方法来控制，而必选参数可使用builder的构造函数控制
2. 建造者模式与反射相比，后者破坏了编译时期检查(如没有对应构造函数和构造函数异常处理等)

**缺点:**

1. 增加了需要先创建Builder的性能消耗
2. 代码会比重叠构造器冗长

*注意事项:如果违反了约束条件，build方法应该抛出IllegalStateException，而在这之前，setter抛出IllegalArgumentException是个好做法*  
*注意事项:如果参数较多，优先使用建造者模式是一个好选择，因为后期添加的builder和先前的构造器还有静态工厂很不协调*  

### 用私有构造器或者枚举强化Singleton属性(单例模式)

> 私有构造函数方式可以修改构造函数在被要求创建第二个实例的时候抛出异常抵御反射攻击  
> 使用transient和readResolve方法保证反序列化后使用一个实例  
> 返回实例的工厂函数很灵活，如每个线程返回一个实例  

*Tips:单元素的枚举已经成为实现单例的最好方法，可以防止序列化和反射攻击*

### 通过私有构造强化不可实例化的能力

> 使用私有构造器防止编译器默认生产共有无参构造，并增加注释

*注意事项:不能使用抽象防止实例化，因为子类可以实例化*

### 避免创建不必要的对象

> 重用不可变对象，如不新建String的实例，使用工厂函数而不是构造，如Boolean.valueOf("true")代替new Boolean("true")  
> 使用静态初始化一个变量而不是每次访问都初始化，如Calendar对象和日期对象  
> 要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱，如在for中使用Long sum += i运算  

*注意事项:对象池只适用于昂贵的创建代价的资源，如数据库连接池，否则垃圾回收机制性能很容易就会超过轻量级对象池的性能*  
*注意事项:在提倡保护性拷贝的时候，重用对象的代价要远远大于创建对象付出的代价*  
*注意事项:必要时如果没能实施保护性拷贝，将会导致程序错误和安全漏洞*  
*注意事项:不必要的创建对象智慧影响程序的风格和性能*  

### 消除过期对象的引用

**内存泄漏常见来源:**

1. 只要类是自己管理内存，程序员就应该警惕内存泄漏问题
2. 内存泄漏的另一个常见来源是缓存
    * 使用WeakHashMap(缓存外存在对某个**键**的引用，该项才有意义)
    * 使用Timer、Schedule或者添加时清理，LinkedHashMap的removeEldestEntry也可以实现
    * 使用java.lang.ref
3. 第三个常见来源是监听器和其他回调
    * 显示取消注册
    * 使用WeakHashMap保存他们的弱引用

```java
// 原因1例子
public Object pop(){
    if(size==0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size]=null;// 解除引用
    return result;
}
```

*注意事项:清空对象引用是一种例外，而不是一种规范行为*  

### 避免使用终结方法(finalizer)

> 使用显示的终止方法(如close方法)，要求类的客户端在每个实例不适用的时候调用这个方法，显示的终结方法必须在一个私有成员中记录下是否有效，无效状态再次调用抛出IllegalStateException  
> Java中采用try-finally来配合完成非内存资源的回收  

**问题:**

1. finalize方法不能保证被及时执行  
2. finalize方法不能保证被执行  
3. 不应该依赖终结方法来更新重要的持久状态  
4. 未捕获异常在终结过程中被抛出来，这种异常可能被忽略，终结过程也会终止  
5. 终结方法有一个非常严重的性能损失

**finalizer用途**

> 为客户端忘记调用显示终结方法增加一层保障，如FileInputStream的finalize方法  
> 协助释放native方法的非关键资源  

*注意事项:终结方法需要使用try-finally调用父类的终结方法*  
*注意事项:为了防止父类终结方法忘记被调用，采用匿名内部类(终结方法守卫者finalizer guardian)释放外围实例*  

```java
public class Foo {
    private final Object finalizerGuardian = new Object() {
        @Override
        protected void finalize() throws Throwable {
            close();
        }
    };
    // 注意这里不是调用finalize方法，所以finalize方法是否被子类调用没有实际意义
    public void close() {
        //do finalize
    }
}
```

## 对象的通用方法

遵循通过约定(general contract)的方法:

* equals
* hashCode
* toString
* clone
* finalize(见`避免使用终结方法`部分)
* compareTo(非Object的方法，在本章介绍)

### 覆盖equals方法请遵循通用约定

**何时覆盖equals**

> 如果类具有自己特有的“逻辑相等”概念(不同于对象相等的概念)，且超类还没有覆盖equals方法以实现期望行为时，这也使得映射或者集合表现出预期的行为

*注意事项:值类在保证只存在一个对象时(如枚举)，逻辑相同等同于对象等同*

**Object规范的equals约定**

* 自反性(reflexive)
    - 对于任何非null值的引用x，x.equals(x)必须返回true
    - contains方法要求遵循这个原则
* 对称性(symmetric)
    - 对于任何非null值的引用x和y，当且仅当y.equals(x)返回true时，x.equals(y)也返回true
* 传递性(transitive)
    - 对于任何非null值的引用x、y和z，当y.equals(x)返回true时，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true
* 一致性(consistent)
    - 对于任何非null值的引用x和y，多次比较操作在对象中的所用信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false
* 非空性(Non-nullity)
    - 对于任何非null值的引用x，x.equals(null)必须返回false

*注意事项:在非抽象类的子类中覆写或继承equals方法时，很容易破环对称性和传递性，可以使用组合代替继承并提供一个返回被组合对象方法的方式，避免这个问题，而抽象的父类不能被实例化，所以不存在这样的问题*  
*注意事项:java.sql.Timestams对java.util.Data类进行了扩展，其equals方法违反了对称性，所以不能混用*  
*注意事项:java.net.URL的equals方法依赖于对URL中主机IP地址的比较，获得IP需要访问网络，随着时间的推移，不确保会产生相同的结果，违反了一致性*  

**高质量equals方法实现**

1. 使用==检查参数是否为这个对象的引用
    * 如果是，返回true。
    * 如果比较操作性能昂贵，这是一个值得做的性能优化
2. 使用instanceof操作符检查参数是否为正确类型
    * 如果不是，返回false。
    * 如果类实现的借口改进了equals约定，允许实现类之间比较，如集合接口
    * instanceof操作符在第一个操作数为null时，都会返回false，所以不需要单独的null检查
3. 把参数转化成正确的类型
4. 对于该类中的每个关键域，检查参数中的域是否与该对象中对应的域相匹配
    * 如果全部测试成功，返回true，否则返回false
    * 对于非float和double类型的基本类型，使用==比较
    * float类型使用Float.compare(),double使用Double.compare()
        - 由于存在Float.NaN，-0.0f及类似的double常量，特殊处理是有必要的，参看Float.equals文档
            + If f1 and f2 both represent Float.NaN, then the equals method returns true, even though Float.NaN==Float.NaN has the value false.
            + If f1 represents +0.0f while f2 represents -0.0f, or vice versa, the equal test has the value false, even though 0.0f==-0.0f has the value true.
    * 对于数组元素，使用Arrays.equals()
    * 对于允许null值的对象
        - (field==null?o.field==null:field.equals(o.field))
    * 对于通常不相等的对象引用的判断，递归调用equals
    * 对于通常是相等的对象引用的判断
        - (field==o.field||(field!=null)&&field.equals(o.field))
5. 问自己三个问题，是否对称，传递且一致，并测试

*注意事项:域的比较顺序可能会影响到equals方法的性能，应该先比较最有可能不一致的域或开销最低的域，最理想的情况是都满足的域先比较*  
*注意事项:覆盖euqals时总要覆盖hashCode*  
*注意事项:不要将equals声明中的Object对象换为其他类型，因为那就不是重写*  

### 覆盖equals使总要覆盖hashCode

**Object规范的hashCode约定**

* 程序执行其间，equals用到的信息没有被修改，多次调用hashCode应该返回同一个整数，程序的多次执行过程中，返回的整数可以不一致
* 两个对象equals方法相等，hashCode必须产生相同的结果
* 两个对象equals方法不相等，hashCode可以产生相同的结果，程序员应该为不相等的对象产生不同的散列码
    - 产生不同的结果有可能提高散列表(hash table)的性能
    - 如果相同，对象会被映射到同一个散列桶中，是散列表退化为链表，使得本该线性时间运行的程序变成了以平方时间在运行

*Tips:如果计算hashCode很麻烦，可以使用懒加载加缓存的形式存储hashCode*  
*注意事项:不要试图从计算中去除一个对象的关键部分来提高性能*  
*Tips:新版本的Jdk中提供了Objects.equals()和Objects.hash(id)帮助开发者实现equals和hashCode*  

### 始终要覆盖toString

**Object规范的toString约定**

* 被返回的字符串应该是一个“简洁的，但信息丰富，并且易于阅读的表达形式”
* 建议所有子类都应该覆盖这个方法

> toString方法应该返回对象中包含的所有值得关注的信息

**是否在文档中指定返回格式**

* 指定格式
    - 优点:可以作为一种标准的、明确的、是何人阅读的对象表示法，这种表示法也可以用于输入和输出，以及用在永久的适合人阅读的数据对象中
        + 指定格式最好提供一个相匹配的静态工厂或者构造器，以便在对象和它的字符串表示法之间来回转换，如绝大多数包装类型
    - 缺点:指定格式后一旦被广泛使用，就必须始终如一的坚持这种格式，否则会破坏相关代码和数据
* * 不指定格式
    - 优点:保留灵活性，以便以后改进格式

*注意事项:无论是否指定格式，都应在文档中明确的标明意图*  
*注意事项:无论是否指定格式，都应为toString中的信息提供一个编程式的访问路径，而不是从字符串中解析而引发潜在错误*  

### 谨慎的覆盖clone

**Object规范的clone约定**

* 创建和返回对象的一个拷贝
* x.clone()!=x
* x.clone().getClass()==x.getClass()
* x.clone().equals(x)

**Cloneable接口的作用**

> 如果一个类实现了Cloneable，对象的clone方法就返回该对象的逐域拷贝，或者抛出CloneNotSupportedException  

**clone方法实现**

> 所有实现了Cloneable接口的类，都应该用一个共有的方法覆盖clone，此共有方法首先调用super.clone，然后修正任何需要修正的域

*注意事项:clone架构与引用可变对象的final域的正常用法是不相兼容的，为了正常使用clone，需要删除final修饰符*  
*注意事项:调用方法重新构造一个对象没有直接操作对象及其克隆对象的内部状态clone方法快*  

**另一个实现对象拷贝的好方法是提供一个拷贝构造器或拷贝工厂**

* 拷贝构造器
    - public Yum(Yum yum)
* 拷贝工厂
    - public static Yum newInstance(Yum yum)
* 优点
    - 不依赖于语言之外的创建机制
    - 不要求遵守尚未制定好文档的规范
    - 不会与final域的正常使用冲突
    - 不会抛出不必要的受检异常
    - 不需要进行类型转换

*注意事项:拷贝构造器和拷贝工厂也需要对对象进行深拷贝*  

### 考虑实现Comparable接口

**compareTo方法的约定**

将这个对象与指定的对象进行比较，当对象小于、等于、大于指定对象的时候，分别返回一个负数、零或正整数，如果由于指定对象的类型无法与该对象进行不交，则抛出ClassCastException

* x.compareTo(y)==-y.compareTo(x)
    - 如果第一个对象小于第二个对象，则第二个对象一定大于第一个对象
    - 如果第一个对象等于第二个对象，则第二个对象一定等于第一个对象
    - 如果第一个对象大于第二个对象，则第二个对象一定小于第一个对象
* 传递性，(x.compareTo(y)>0&&y.compareTo(z)>0)，则x.compareTo(z)>0
    - 如果一个对象大于第二个对象，并且第二个对象大于第三个对象，则第一个对象一定大于第三个对象
* x.compareTo(y)==0,则所有的z，x.compareTo(z)==y.compareTo(z)
    - 比较时被认为相等的对象，它们跟别的对象比较时一定会产生相同的结果
* 强烈建议x.compareTo(y)==0，x.equals(y)，但不强制，如果违反应该给出说明

*注意事项:同equals方法，如果继承体系和compareTo一起使用会造成问题，可以使用组合避免问题，并提供一个方法返回被组合对象*  
*注意事项:BigDecimal的compareTo和equals不一致(objects equal only if they are equal in `value` and `scale`)，这使得hash结构和tree结构会产生不同的结果*  
*注意事项:比较整数型基本类型的域，使用关系操作符`<`和`>`，浮点域使用Double.compare和Float.compare*  
*注意事项:compareTo方法应该从相对关键的域开始比较，如果产生非0结果，就返回*  
*注意事项:比较时可以直接进行运算，返回运算结果而不是判断大小，这样可以直接得出大于还是小于，但是要考虑值溢出的问题*  

## 类和接口



------

*Effective Java*